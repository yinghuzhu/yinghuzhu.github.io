<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于配置中心属性,Dubbo Consumer动态切换调用RPC/本地方法</title>
    <url>/2018/07/06/Dubbo-Local-RPC-Switch/</url>
    <content><![CDATA[<h2 id="需求缘由"><a href="#需求缘由" class="headerlink" title="需求缘由"></a>需求缘由</h2><p>最近部分只读服务已经切换到了Dubbo提供的服务化接口；经过一段时间的生产验证, 各种监控指标显示非常稳定，所以打算开始切换写服务接口; 但大家对写操作跑服务化没有信心，于是提了一个需求能随时将远程rpc调用切换打本地jar方法调用；<span id="more"></span></p>
<h2 id="dubbo的stub"><a href="#dubbo的stub" class="headerlink" title="dubbo的stub"></a>dubbo的stub</h2><p>听到这个需求，马上想到dubbo的stub属性；但需要在原来代码中做部分改造,具体步骤是：</p>
<ol>
<li>原来的jar包实现方法中增加带自身接口类型参数的构造函数;</li>
<li>在所有的接口实现方法中判断开关状态决定调用RPC/本地方法;<br>但是，这样对原代码有极强入侵性；我们认为这不是最好的方案，于是有了下面的方案；</li>
</ol>
<h2 id="扩展dubbo-reference标签属性"><a href="#扩展dubbo-reference标签属性" class="headerlink" title="扩展dubbo:reference标签属性"></a>扩展dubbo:reference标签属性</h2><p>首先需要说明，我们在实际使用dubbo的过程中并没有直接使用dubbo这个命名空间，而是自定义了自己的命名空间，自定义命名空间兼容了dubbo命名空间的所有属性，而且扩展了自己的属性；于是针对该需求我们有了新的方案，具体流程如下 ：</p>
<ol>
<li>增加<strong>reference</strong>的属性<strong>localbean</strong>，这个属性值为一个本地bean的id；类似的xml配置如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localDemoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Service.impl.DemoServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mydubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.Service.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remoteDemoService&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">localbean</span> =<span class="string">&quot;localDemoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>继承ReferenceBean实现自定义属性locbean；</li>
<li>继承DubboNamespaceHandler重写init方法,如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> MyBeanDefinitionParser(LocalReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>自定义filter<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCLocalSwitchFilter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RPCLocalSwitchFilter.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory PROXY_FACTORY = (ProxyFactory)ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RPCLocalSwitchFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cfg.getBooleanProperty(<span class="string">&quot;&quot;</span>)) &#123;  <span class="comment">//判断配置中心开工状态</span></span><br><span class="line">            Object bean = <span class="keyword">this</span>.getLocalBean(invoker);</span><br><span class="line">            <span class="keyword">return</span> bean != <span class="keyword">null</span>?<span class="keyword">this</span>.executeLocalMethod(bean, invoker, invocation):invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result <span class="title">executeLocalMethod</span><span class="params">(T bean, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;execute local method instead of rpc &quot;</span> + bean.getClass().getCanonicalName() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Invoker localInvoker = PROXY_FACTORY.getInvoker(bean, invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        <span class="keyword">return</span> localInvoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getLocalBean</span><span class="params">(Invoker&lt;?&gt; invoker)</span> </span>&#123;</span><br><span class="line">        String refLocal = invoker.getUrl().getParameter(<span class="string">&quot;localBean&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(refLocal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ApplicationContext e = LocalReferenceBean.getSpringContext();</span><br><span class="line">                <span class="keyword">return</span> e.getBean(refLocal, invoker.getInterface());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">                logger.error(var4.getMessage() + <span class="string">&quot; couldn\&#x27;t find the bean[&quot;</span> + localBean + <span class="string">&quot;], please check&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置filter<br>在resources/META-INF/dubbo/com.alibaba.dubbo.rpc.Filter文件中增加如下内容:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reflocal=com.example.filter. RPCLocalSwitchFilter</span><br></pre></td></tr></table></figure>
配置consumer的filter属性<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mydubbo:consumer</span> <span class="attr">filter</span>=<span class="string">&quot;reflocal&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
至此可以通过配置中的开关状态来控制远程RPC/本地jar方法调用 ;</li>
</ol>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>一个三年前的Bug导致上线失败</title>
    <url>/2020/05/30/History-Bug-And-Code-Review/</url>
    <content><![CDATA[<p>上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。<span id="more"></span></p>
<h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol>
<li>17:10：开始发布B组 </li>
<li>17:20：开始出现内存，接口超时报警；开发和SA开始介入</li>
<li>17:25：认为是新版本有问题立刻回滚</li>
<li>回滚后持续半小时问题没有出现</li>
</ol>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>根据开发反馈，本次上线功能逻辑非常简单，只有20多行代码，而且测试过程中没发现任何问题；于是，大家开始review那段代码，review后得出一致多结论，该代码没问题。逻辑非常简单，只有一个地方调用了一个方法；这个方法已经存在了好你年了，而且被多个场景在调用；另外，这个方法逻辑复杂，团队内没有人了解。大家一致认为这个方法不会有问题，毕竟经历了「时间的考验」。</p>
<h3 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h3><p>在测试环境又做了一轮压力测试，一切正常。根据目前点情况看来这个bug跟数据有关；就是说，可能是某条数据触发了这个bug的临界条件.所以，我们决定在生产环境发布一台机器做测试; 这次发布后5分钟后出现了内存飙升现象,马上切掉该机器的流量而且dump Jvm内存 。</p>
<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>拿到dump文件后立刻启动MAT分析；发现占用内存最多一个对象有3000多万个，分析该对象的调用盏都指向了同一行代码；「这段代码正是经历过时间考验的代码」。review这行代码相关部分马上发现有死循环的问题，只是满足这个条件的数据不容易出现。而这次的数据正好满足了这个条件。找到了原因，解决方法就很容易了；修改完代码review后没问题，测试，上线后一切正常；至此，该问题解决。这里可能有人会说死循环一般会首先导致CPU报警，怎么没看到我们提到CPU到问题；因为这台机器是16核CPU，所以一个核跑满并没有触发报警规则 。</p>
<h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol>
<li>必须严格执行code review，从流程上去控制</li>
<li>需要监控各项指标到同比变化 </li>
</ol>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>我们总是强调code review到重要性，但执行的时候总有这样那样的原因导致落实不彻底；我不了解当时的情况，但这次的问题我相信只要做过code review是一定可以发现的。另外，我始终相信代码质量最终要依赖开发人员来保证，测试只能保证功能性问题。特别是一些非功能性的边界条件，只能依赖开发保证。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探</title>
    <url>/2020/03/29/JVM-NEW/</url>
    <content><![CDATA[<p>最近经常有人跟我一起讨论JVM的相关话题，所以将以前分享过的一篇JVM的基础知识在这里分享出来，欢迎大家指正.<span id="more"></span></p>
<div class="pdfobject-container" data-target="/pdf/jvm.pdf" data-height="500px"></div>]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Open Tracing(Jaeger) 遭遇多线程</title>
    <url>/2019/12/27/Jaeger-Thread/</url>
    <content><![CDATA[<p>我们知道在Java技术体系中，链路跟踪严重依赖ThreadLocal；因此在多线程的场景下会导致链路跟踪失效.<span id="more"></span></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>前几天一位开发同学反馈了一个问题，在链路跟踪UI上看到某个链路Rpc的span数量比实际调用少了很多；我听完第一反映是我们最近升级的SDK出问题了? 根据该同学反馈该接口是一个新接口，上线后一直没关注过链路；我们随即在链路跟踪UI上将多个系统的常用接口都检查了一遍发现一切正常，基本排除了SDK可能引起的问题。接着开始检查开发同学的代码,顺着该请求发现代码里面用到了<strong>线程池</strong> ,该同学解释该接口内部需要多次调用多个Rpc接口，为了提升效率所以采用了多线程。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析opentracing的源码发现tracing相关的的信息保存在<code>io.opentracing.util.ThreadLocalScopeManager</code>的ThreadLocal变量里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScopeManager</span> <span class="keyword">implements</span> <span class="title">ScopeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalScope&gt; tlsScope = <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalScope&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">activate</span><span class="params">(Span span, <span class="keyword">boolean</span> finishOnClose)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalScope(<span class="keyword">this</span>, span, finishOnClose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tlsScope.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就可以解释为什么多线程中的Rpc请求没有将相关Tracing信息传递下去;</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>多线程中ThreadLocal变量的传递:<br>关于多线程中ThreadLocal变量的传递我们可以用阿里巴巴的<a href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a> ,所以整个思路就是自己实现一遍<code>ThreadLocalScopeManager</code>用<code>TransmittableThreadLocal</code>替换<code>ThreadLocal</code>，以及跟它关联的类<code>ThreadLocalScope</code>(它里面申明了<code>ThreadLocalScopeManager</code>变量)； </p>
</li>
<li><p>修改Opentrcing里面默认的<code>ThreadLocalScopeManager</code>为用户自定义<code>ThreadLocalScopeManager</code><br>检查Jaeger的Springboot自动配置文件<code>io.opentracing.contrib.java.spring.jaeger.starter.JaegerAutoConfiguration</code>源码, 在构造Bean <code>io.opentracing.Tracer</code>时有用户自定义方法: <code>tracerCustomizers.forEach(c -&gt; c.customize(builder))</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JaegerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;TracerBuilderCustomizer&gt; tracerCustomizers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> io.opentracing.<span class="function">Tracer <span class="title">tracer</span><span class="params">(Sampler sampler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Reporter reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Metrics metrics,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      JaegerConfigurationProperties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> JaegerTracer.Builder builder =</span><br><span class="line">        <span class="keyword">new</span> JaegerTracer.Builder(properties.getServiceName())</span><br><span class="line">            .withReporter(reporter)</span><br><span class="line">            .withSampler(sampler)</span><br><span class="line">            .withTags(properties.determineTags())</span><br><span class="line">            .withMetrics(metrics);</span><br><span class="line"></span><br><span class="line">    tracerCustomizers.forEach(c -&gt; c.customize(builder));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>
<p>于是，我们只需要自定义<code>TracerBuilderCustomizer</code>调用<code>builder.withScopeManager</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlTracerBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title">TracerBuilderCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(JaegerTracer.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withScopeManager(<span class="keyword">new</span> TracingScopeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SpringBoot自动配置文件中构造Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TracerBuilderCustomizer&gt; <span class="title">tracerCustomizers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> TtlTracerBuilderCustomizer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，问题解决； 代码参考<a href="https://github.com/yinghuzhu/request-tracing">request-tracing</a></p>
</li>
</ol>
<h3 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h3><p>我不建议在互联网高并发请求接口内部采用多线程；以Java技术体系为例，请求到达系统后一般会有容器(Tomcat之类)或者Rpc框架先接收，然而这些框架本来就是多线程在运行,如果系统本来已经到瓶颈了，即使增加线程也不会提升效率；如果系统需要增加线程，首先我们应该增加容器或者Rpc框架的线程数量；另外如果接口性能差，我们首先应该考虑是Sql的问题还是代码逻辑的问题；或者系统达到了瓶颈是否可以通过增加机器提升性能；如果接口逻辑本身太复杂，可能是我们的方案或者设计有问题，或许可以考虑按照离线请求的模式设计接口。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个问题虽然没有对业务造成影响，但收集到链路肯定是有问题的；这也暴露出了我们开发过程中的一些问题，对非功能性验证做的不到位，这方面还需要加强。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>链路跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务框架选型之 Dubbo VS. Spring Cloud</title>
    <url>/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/</url>
    <content><![CDATA[<p>当前开源的微服务框架有Dubbo, Spring Cloud, Dubbox, Motan, Thrift, GRPC 等；以Dubbo和Spring Cloud使用最广，本文仅对这两个框架结合自己项目的情况进行比较。<span id="more"></span></p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><p><img src="/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/dubbo-architecture.png" alt="Dubbo 架构图"></p>
<p>从Dubbo的架构图中我们可以看出Dubbo重点是RPC框架,对应微服务相关的其它组件,如服务发现,配置管理等需要用户自己适配;</p>
<h2 id="Spring-Cloud架构"><a href="#Spring-Cloud架构" class="headerlink" title="Spring Cloud架构"></a>Spring Cloud架构</h2><p><img src="/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/diagram-distributed-systems.svg" alt="Spring Cloud架构图"></p>
<p>Spring Cloud架构中包括了微服务生态中的大部分组件，包括但不限于服务发现，配置管理，路由网关,限流熔断等</p>
<h2 id="详细比较"><a href="#详细比较" class="headerlink" title="详细比较"></a>详细比较</h2><p>我们结合自己项目的情况从10个方面对两个框架比较</p>
<h3 id="迁移成本"><a href="#迁移成本" class="headerlink" title="迁移成本"></a>迁移成本</h3><p>  现有的系统正在线上运行，所以迁移过程中不能影响现有的系统而且尽量不耽误新功能的开发；</p>
<ol>
<li>Dubbo迁移过程</li>
</ol>
<ul>
<li>分离服务接口到独立的jar包</li>
<li>在服务端xml文件中配置服务接口将服务暴露出去</li>
<li>在客户端引入接口jar包，在xml文件中引入服务端暴露的接口</li>
</ul>
<ol start="2">
<li>Spring Cloud迁移过程</li>
</ol>
<ul>
<li>为接口定义HTTP协议 </li>
<li>服务端在controller里面以rest API的方式暴露接口</li>
<li>客户端根据定义的http协议用FeignClient注解的形式定义访问接口</li>
<li>客户端代码引入FeignClient定义的协议接口</li>
</ul>
<p>由此可见，dubbo迁移不需要修改java 代码，spring cloud 需要为每个接口定义一套http协议，而且客户端需要定义访问接口</p>
<h3 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h3><p>社区支持我们参考github的数据</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>Star</td>
<td>18k+</td>
<td>2.1k+</td>
</tr>
<tr>
<td>Fork</td>
<td>12k+</td>
<td>1.1k+</td>
</tr>
<tr>
<td>Contribute</td>
<td>70+</td>
<td>130+</td>
</tr>
<tr>
<td>Open Issues</td>
<td>430+</td>
<td>380+</td>
</tr>
<tr>
<td>Close Issues</td>
<td>740+</td>
<td>1.9k+</td>
</tr>
<tr>
<td>Latest Updated</td>
<td>几个小时前，但是2014-10-30到2017-09-07断更</td>
<td>几个小时前</td>
</tr>
</tbody></table>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><ul>
<li>Dubbo服务治理不太完善</li>
<li>Spring Cloud有比较完善的服务治理组件,Zuul, Ribbon, Hystrix等</li>
</ul>
<h3 id="生态建设"><a href="#生态建设" class="headerlink" title="生态建设"></a>生态建设</h3><ul>
<li>Dubbo生态包括:   RPC框架，服务治理, 服务降级，其它相关组件可以集成第三方成熟的开源组件；</li>
<li>Spring Cloud生态包括: RPC框架，服务发现，配置服务，服务治理，服务降级，日志收集，任务管理，几乎包括了服务化相关的所有组件；</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>  Dubbo和Spring Cloud 都没有实现分布式事务 </p>
<h3 id="运维成本"><a href="#运维成本" class="headerlink" title="运维成本"></a>运维成本</h3><p>  运维需要关注以下组件</p>
<ol>
<li>服务发现</li>
</ol>
<ul>
<li>Dubbo采用Zookeeper公司有Zookeeper的使用经验</li>
<li>Spring Cloud采用Eureka,需要搭建新的eureka服务</li>
</ul>
<ol start="2">
<li>配置管理</li>
</ol>
<ul>
<li>Dubbo采用Apollo，公司已经投入生产环境</li>
<li>Spring Cloud 需要重新部署spring cloud config </li>
</ul>
<ol start="3">
<li>服务治理</li>
</ol>
<ul>
<li>Dubbo 需要独立部署Dubbo-OPS, Zipkin/hydp/cat</li>
<li>Spring Cloud 需要独立部署 Zuul, Zipkin<br>综上，Dubbo新部署2个组件，Sping Cloud新部署4个组件</li>
</ul>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul>
<li>Dubbo开发流程<ol>
<li>确保服务发现组件已启动</li>
<li>定义接口，生成接口jar包发布到maven仓库</li>
<li>服务端实现接口逻辑；同时客户端引入接口jar包,实现客户端逻辑, 完成自测</li>
<li>客户端服务端联调</li>
</ol>
</li>
<li>Spring Cloud开发流程<ol>
<li>确保服务发现组件已启动</li>
<li>定义http接口，形成文档</li>
<li>服务端实现接口逻辑而且以rest API的形式发布出去；同时客户端根据http接口约定实现客户端逻辑，完成自测</li>
<li>客户端服务端联调<br>所以，Dubbo的接口具有强依赖性，Spring Cloud主要依赖约定</li>
</ol>
</li>
</ul>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>Dubbo和Spring Cloud集成测试的时候都需要服务的和客户端配合完成</p>
<h3 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h3><ul>
<li>Dubbo主要提供Spring Xml配置的方式，同时社区也提供SpringBoot的注解方式Dubbo Spring Boot Project ，而且Dubbo官方提供了最佳实践；目前我们的项目中两种方式都存在，所以学习成本基本可以忽略；</li>
<li>Spring Clould是建立在SpringBoot基础上的，采用大量的注解方式，目前我们也大量使用SpringBoot, 所以学习成本基本可以忽略；</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>Dubbo默认采用Dubbo协议，Dubbo协议工作在TCP层,同等条件下性能优于HTTP协议</li>
<li>Spring Clould采用HTTP协议, 性能略逊与Dubbo</li>
</ul>
<p>最后将以上比较项目给出数值的形式 </p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>权重</th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>迁移成本</td>
<td>10</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>社区支持</td>
<td>9</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>服务治理</td>
<td>8</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>生态建设</td>
<td>7</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>分布式事务</td>
<td>6</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>运维成本</td>
<td>5</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>开发流程</td>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>集成测试</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>学习成本</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>性能</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>37</td>
<td>33</td>
</tr>
</tbody></table>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>  Dubbo优势在于从迁移成本低，能在尽可能不改动现有代码的基础上完成服务化的迁移，而且我们团队成员使用Dubbo的经验比使用Spring Cloud的经验丰富；Spring Cloud的优势在于生态比较完善，社区支持良好；最终根据我们项目当前实际情况,我们认为Dubbo是最好的选择，可以在业务开发的同时平滑地完成服务化;</p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化多项目测试环境隔离</title>
    <url>/2019/02/13/Multi-Project-Test-Env/</url>
    <content><![CDATA[<p>单体应用依赖比较少，大部分情况我们只需要启动一个应用就可以开始测试工作。架构升级到服务化后，每个应用依赖比较多，任何一个依赖有问题都会影响测试结果；如果服务化环境中多项目并行测试，测试效率会更差 。 <span id="more"></span> 为此，我们给出服务化多项目并行测试方案。</p>
<h3 id="版本号隔离"><a href="#版本号隔离" class="headerlink" title="版本号隔离"></a>版本号隔离</h3><p>首先能想到的方法就是利用版本号的特征「类dubb的RPC框架都有版本号属性」，对不同的项目给出不同的版本号; 比如有如下调用关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client -&gt; SA  </span><br></pre></td></tr></table></figure>
<p>在启动SA的时候对不同的项目指定不同的版本号,Client在调用SA的时候根据不同的项目指定与SA相匹配的版本号.</p>
<ul>
<li>优点: 简单，无需额外开发，类dubbo的RPC框架都支持 </li>
</ul>
<h3 id="多项目开发测试现状"><a href="#多项目开发测试现状" class="headerlink" title="多项目开发测试现状"></a>多项目开发测试现状</h3><p>实际项目中的调用关系： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client -&gt; SA -&gt; SB -&gt; SC -&gt; SD</span><br></pre></td></tr></table></figure>
<p>有两个项目在并行开发：</p>
<ul>
<li>project1「以下简称P1」代码变更部分是SA, SC</li>
<li>project2「以下简称P2」代码变更部分是SB, SD</li>
</ul>
<p>如果我们采用「版本号隔离」方案; 对于P1, 不但需要部署SA和SC，还需要部署Client和SB，因为Client调用SA，SB调用SC的<strong>版本号分别指向新部署的SA和SC</strong> 。P2也需要类似的部署方法；这样我们发现，几乎所有的服务在每个项目中都需要部署一套；造成资源大量浪费，显然不现实。 因此，我们有了下面的方案「动态路由」 。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由的思路是环境分<strong>一套稳定环境和每个项目对应一套项目测试环境,其中稳定环境包括所有的服务，项目测试环境仅包括该项目代码变更部分的服务</strong>,各个环境的所有服务采用同一注册中心；方案如下图所示 </p>
<p><img src="/2019/02/13/Multi-Project-Test-Env/multi-test-env.png" alt="服务化多项目测试环境"></p>
<ul>
<li>稳定环境: 部署所有的服务，保证稳定环境作为完整的系统；可以利用CI/CD每日从Master拉稳定版本的代码完成自动部署</li>
<li>P1: project1测试环境，仅部署有代码变更的SA1和SC1 </li>
<li>P2: project2测试环境，仅部署有代码变更的SB2和SD2</li>
<li>路由策略： Client发起调用的时候携带该调用链路所有测试环境的路由规则，如果没有指定路由规则请求默认环境的服务 </li>
</ul>
<h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h5><ul>
<li>每个服务启动时候在注册中心注册服务所在节点测试环境类型(P1，P2或者默认环境)，默认情况注册为默认环境 </li>
<li>自定义loadbalance，根据路由规则将RPC请求路由到指定节点上</li>
<li>每次RPC调用将该调用链路的路由规则隐士传递到下层服务</li>
<li>每个测试环境需要一个独立的入口，以WEB项目为例可以将nginx作为入口，路由规则可以配置在nginx的配置文件中</li>
<li>对接发布系统，有变更的服务发布到测试环境时候，该测试环境的路由规则自动写入测试环境的入口配置文件</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>一次OOM引发服务雪崩的思考</title>
    <url>/2018/12/01/OOM-Casue-Snowslide/</url>
    <content><![CDATA[<p>前几天核心基础服务(简称S,两节点)发生了一次线上故障，导致整个基础服务雪崩，最终，该基础服务故障导致整站多项功能失效；</p>
<span id="more"></span>
<h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol>
<li>4:15 开始S的多个上游服务开始出现大量超时,而且出现告警</li>
<li>4:30 S的节点S1出现OOM停止服务 ,同时告警系统发出了告警信息</li>
<li>4:50 S的节点S2由于操作系统内存不足被系统kill ,同时告警系统发出了告警信息<br> ….</li>
<li>8:00 运营同学反馈问题,技术同学开始排查</li>
<li>8:05 技术同学发现S故障,重启S服务，服务正常 </li>
</ol>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>S的上游应用某定时任务在凌晨4:10请求了大量(一次超过200w)的数据将S1先拖死，导致流量全部到S2，S2逐渐不堪重负,导致被系统kill </li>
<li>S对上游数据请求量没有限制，没有启用限流分组功能</li>
<li>告警信息没有引起足够重视,告警被忽略</li>
<li>告警信息仅仅报告给monitor，没有到系统的owner</li>
</ol>
<h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol>
<li>启用限流，分组功能</li>
<li>必须严格执行code review</li>
<li>告警信息必须分级，而且必须同时报告给monitor和系统owner;接警人接到报警后根据不同的级别进行处理</li>
</ol>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>在互联网领域我们为了追求n个9，会采取一系列的流程措施来保障系统的可用性;但，真正落实到位的有多少? 其实，线上故障不可怕，可怕的是没有相应的应对措施；更可怕的是有相应的应对措施，但没有落实到位; 比如: 在服务化推进的过程中架构团队已经提供了限流，分组等功能，而且也进行了宣讲；但，最终这些措施还是没有落实到位；也许这就是大厂和创业公司的区别，大厂里面的架构师大部分也是螺丝钉，只要自己有产出符合预期完成KPI就是一个合格的架构师；但是，创业公司的架构师要考虑更多的因素，从最初的技术方案到设计，实现，最终的落地执行都需要全程参与确保每一个功能真正落实到位</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>基础组件升级策略与实践</title>
    <url>/2023/08/26/Infra-Component-Upgrade/</url>
    <content><![CDATA[<p>基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法； <span id="more"></span></p>
<h2 id="为什么需要基础组件"><a href="#为什么需要基础组件" class="headerlink" title="为什么需要基础组件"></a>为什么需要基础组件</h2><p>为什么我们的系统要引入基础组件，使用基础组件由什么优势,以下根据个人体会列出了几点：</p>
<ol>
<li>提高开发效率：基础组件为提供了可重用、可定制和可扩展的组件和库。通过使用这些组件，开发团队能够快速搭建系统，并在不必从头开始编写代码的情况下实现常见功能。这大大提高了开发效率，缩短了产品上线时间</li>
<li>降低开发成本：通过使用成熟的基础组件，我们能够减少自主开发和维护的工作量。这意味着可以节省开发资源，并将精力集中在增值业务和创新上。</li>
<li>统一标准和规范：基础组件有助于确保在整个系统中使用一致的标准和规范。这种一致性使得不同团队的开发人员能够更好地协同工作，并减少因为不一致性而导致的问题。例如，使用统一的redis客户端组件限制一些危险命令的使用。</li>
<li>提升系统可靠性和稳定性：基础组件经过专业的设计和测试，通常具有高度可靠性和稳定性。它们被广泛使用和验证，可以减少系统中的错误和故障。而且，这些组件通常具有自动化的监控和错误处理机制，能够及时发现和处理潜在的问题，提高系统的稳定性。</li>
<li>解偶业务系统与中间件，平台之间的代码：提高系统的稳定性，方便维护，开发人员聚焦到业务功能开发；</li>
<li>提高管理效率，通过技术手段将操作流程规范化</li>
<li>安全性：确保系统采用安全大版本</li>
</ol>
<h2 id="为什么进行基础组件升级"><a href="#为什么进行基础组件升级" class="headerlink" title="为什么进行基础组件升级"></a>为什么进行基础组件升级</h2><ol>
<li>修复组件Bug,提高系统稳定性: 随着时间的推移,基础组件中会暴露出各种Bug,这些Bug可能会导致系统崩溃或业务异常。升级组件可以修复已知的Bug,提高系统稳定性。</li>
<li>获取最新功能特性,满足业务需要：基础组件推出新版本时,通常会提供新的功能和特性。业务需求瞬息万变,升级组件可以获得最新功能来满足业务需求。</li>
<li>改善性能,提升效率：新版本的基础组件通常在性能和效率上有改进,如增加缓存、优化算法等。升级后可以减少响应时长,提升系统吞吐量。</li>
<li>优化资源利用,降低成本：基础组件的新版本可能在资源调度和分配上进行了优化,可以提高资源利用率,降低系统运营成本。</li>
<li>提高开发效率：新版本组件通常会优化API设计,提高开发效率。同时修复Bug也可以减少开发调试时间。</li>
<li>解除对旧版的依赖：旧版本组件停止维护后,存在安全风险和兼容性问题。升级可以避免对旧版组件的依赖。</li>
<li>减少技术债务：使用了较旧版本的基础组件，可能会有技术债务积累，包括安全漏洞、性能瓶颈等；升级基础组件是控制技术债务的重要措施之一，积压的技术债务会制约公司发展</li>
<li>处理兼容性问题: 随着系统的发展和业务的扩展，可能需要与其他系统进行集成和交互，升级基础组件可以提供更好的兼容性和互操作性；</li>
</ol>
<h2 id="升级前的准备工作"><a href="#升级前的准备工作" class="headerlink" title="升级前的准备工作"></a>升级前的准备工作</h2><p>在进行基础组件升级之前，进行充分的准备工作是至关重要的，这可以帮助确保升级过程的顺利进行并最小化潜在风险。以下是升级前需要做的一些准备工作：</p>
<ol>
<li>明确目标： 定义升级的具体目标，明确您希望通过升级实现的业务和技术目标。了解升级所需的功能、性能、安全性等需求。</li>
<li>收集现有信息： 收集关于当前系统和基础组件的详细信息，包括版本、依赖关系、功能和性能特征等。这将有助于为升级过程做出更准确的决策。</li>
<li>评估风险和影响： 识别潜在的风险和影响范围，包括与升级相关的功能中断、兼容性问题、性能下降等。评估这些风险的严重程度，以便制定应对策略。</li>
<li>数据策略： 在进行升级之前，确保对系统进行完整的备份。如果升级中出现问题，可以回滚到之前的状态。对于数据库等有状态的组件，可以创建快照； </li>
<li>制定升级计划： 制定详细的升级计划，包括升级的步骤、时间表、责任人等。确定升级过程中需要涉及的各方，并为他们提供清晰的指导。对于较大范围升级工作，可以拆分为多个里程碑，尽可能保证每个步骤影响范围降到最低；</li>
<li>制定回滚计划： 确定如何还原系统到升级前的状态，以便在紧急情况下进行干预。原则上对升级操作的每个步骤都有对应的回滚步骤，如果不能回滚的场景下必须给出快速解决的方法。</li>
<li>测试环境预演： 在测试环境中进行升级的测试预演，以模拟真实生产环境。测试环境应该尽可能地与生产环境相似，以便更准确地预测升级可能的影响。</li>
<li>性能和压力测试： 在压测环境中进行压力测试，以评估新版本基础组件在不同负载条件下的表现。这有助于预测在生产环境中可能出现的问题。</li>
<li>制定上线计划通知所有相关方</li>
<li>用户培训： 如果新版本引入了新的特性或变化，为团队成员提供培训，确保他们熟悉和适应新版本。</li>
</ol>
<h2 id="升级实践"><a href="#升级实践" class="headerlink" title="升级实践"></a>升级实践</h2><ol>
<li>版本选择： 仔细评估新版本的功能、性能和安全特性。选择与业务需求最匹配的版本，同时考虑其稳定性和用户反馈,重点关注开源社区对issue list。</li>
<li>兼容性检查： 检查新版本与现有系统的兼容性。确保新版本不会破坏现有的功能和集成。</li>
<li>测试环境验证： 在测试环境中进行升级测试，尽量模拟真实生产环境，确保测试到各种可能影响到的场景。</li>
<li>自动化测试： 针对关键业务场景和功能，创建自动化测试用例。这有助于快速验证新版本的稳定性和正确性。</li>
<li>性能测试： 在压测环境中进行压力测试，以评估新版本在不同负载条件下的表现。识别潜在的性能问题。</li>
<li>数据迁移计划： 如果升级涉及数据存储系统，制定数据迁移计划。确保数据的完整性和一致性。</li>
<li>备份和回滚： 在进行任何升级操作之前，确保对系统进行全面备份。制定回滚计划，以便在升级过程中遇到问题时能够迅速还原。</li>
<li>灰度发布： 如果条件许可尽可能采用渐进式发布策略，将新版本逐步引入生产环境，以减少风险。</li>
<li>监控和报警： 升级后留意监控和报警，以便实时监控系统的性能和稳定性，及时发现并快速解决潜在问题。</li>
</ol>
<h2 id="升级后的监测与迭代"><a href="#升级后的监测与迭代" class="headerlink" title="升级后的监测与迭代"></a>升级后的监测与迭代</h2><ol>
<li>性能监测： 持续监测系统的性能，包括响应时间、吞吐量、延迟等。比较升级前后的性能数据，确保新版本不会导致性能下降。</li>
<li>稳定性监测： 监测系统的稳定性，识别是否存在崩溃、死锁、内存泄漏等问题。及时处理并解决这些问题，以确保系统不会因此而崩溃或变得不稳定。</li>
<li>资源利用率监测： 监测服务器、内存、CPU、网络等资源的利用率。确保新版本不会导致资源耗尽。</li>
<li>错误日志报警： 关注错误日志报警，确保升级后不会出现更多错误，防止问题升级为严重故障。</li>
<li>快速响应和修复： 如果发现了严重问题，确保能够快速响应并进行修复。灵活地进行紧急发布，以解决可能影响业务的问题。</li>
<li>收集用户的反馈: 了解用户在使用新版本时遇到的问题，帮助用户解决问题或在在后续版本修复。</li>
</ol>
<h2 id="设计基础组件的注意事项"><a href="#设计基础组件的注意事项" class="headerlink" title="设计基础组件的注意事项"></a>设计基础组件的注意事项</h2><p>在设计基础组件时，有一些注意事项可以考虑，以确保其可靠性、可扩展性和易用性。以下是一些常见的注意事项：</p>
<ol>
<li>定义清晰的接口：确保组件的功能和接口定义清晰明确。这将帮助其他开发人员理解如何正确使用组件，并减少潜在的集成问题。</li>
<li>高可用性和容错性：基础组件通常是系统中不可或缺的一部分，因此必须具备高可用性和容错性。考虑使用冗余、自动故障转移和负载均衡等机制来提高系统的可用性。</li>
<li>可扩展性：设计组件时要考虑到系统未来的扩展需求。确保组件可以水平扩展，以应对增加的负载和数据量。</li>
<li>安全性：基础组件通常处理敏感数据和关键业务逻辑，因此安全性是至关重要的。实施适当的安全措施，如身份验证、访问控制和数据加密等，以保护组件免受潜在的威胁。</li>
<li>性能优化：确保组件在处理大量请求和数据时能够提供良好的性能表现。使用高效的算法和数据结构，并进行性能测试和优化，以确保组件能够满足系统的性能需求。</li>
<li>文档和日志记录：提供清晰、详细的文档和日志记录，以便开发人员和运维团队能够理解组件的工作原理和故障排查方法。</li>
<li>监控和警报：实施监控和警报机制，以及时检测和响应组件的问题。监控关键指标，并设置警报以便在出现异常情况时及时通知相关人员。</li>
<li>版本控制和发布管理：使用版本控制系统来管理组件的代码和配置，确保可追溯性和可靠的发布管理。考虑使用自动化工具和流程来简化部署和升级过程。</li>
<li>可测试性：设计组件时要考虑到测试的可行性。提供适当的接口和工具，以便开发人员能够方便地编写和运行单元测试、集成测试和端到端测试。</li>
<li>与其他组件的集成：如果组件需要与其他组件进行集成，要确保接口和数据格式的兼容性，并进行充分的集成测试，以验证组件的正确性和稳定性。</li>
<li>遵循规范：组件实现需要遵循行业设计规范和标准,以提升互操作性</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>服务化准备工作</title>
    <url>/2018/06/18/Parepare-Service/</url>
    <content><![CDATA[<p>在决定进行服务化时，我们做了一些必要的准备工作；从服务治理，链路跟踪，监控以及报警方面到代码层面，运维，流程等多个方面做了相应的调整</p>
<span id="more"></span>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>我们的服务化是在dubbo的基础上进行的，首先适配了服务化需要的相关组件，包括配置中心，链路跟踪，监控，服务治理等，整体架构如图所示 </p>
<p><img src="/2018/06/18/Parepare-Service/arch.jpg" alt="架构图"></p>
<ul>
<li>配置中心: Apollo </li>
<li>链路跟踪: Zipkin, Kafka, ES</li>
<li>服务治理: dubbo官方的dubbo-admin</li>
<li>服务监控: dubbo官方的dubbo-monitor</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="服务化SDK"><a href="#服务化SDK" class="headerlink" title="服务化SDK"></a>服务化SDK</h3><p>我们提供了服务化SDK给业务团队使用；SDK自定义了xsd文件继承了dubbo的xml标签，在此基础上集成了apollo配置；这样业务团队在使用的过程中对一些系统配置不需要关注，比如注册中心，启用监控，启用链路跟踪等 .</p>
<h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><ol>
<li>分离Service的API接口到独立的Jar包</li>
<li>检查接口的输入输出参数是否实现了Serializable接口</li>
<li>是否使用了接口参数在方法内部修改后的值，代码如下:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*服务端*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">call</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户端*/</span> </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">service.call(list);</span><br><span class="line">list.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

 这个代码在同一个JVM是没有问题，但RPC调用并不能返还预期的结果；</li>
<li>本地事务改造为分布式事务</li>
<li>确保所有的单元测试通过</li>
</ol>
<h3 id="日志输出增加链路跟踪信息"><a href="#日志输出增加链路跟踪信息" class="headerlink" title="日志输出增加链路跟踪信息"></a>日志输出增加链路跟踪信息</h3><p>每条输出日志包括了zipkin的span id,这样每条日志都能清楚的跟踪到从整个调用链；</p>
<h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>dubbo-monitor对接现有的报警系统，将采集到监控数据上报到现有报警系统,做到实时报警 </p>
<h3 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h3><p>dubbo的服务在正常停止的过程中不再接受新的请求,但是启动后在注册中心完成注册马上开始接受新的请求；我们希望启动后由发布系统控制什么时候开始接受新请求；</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>服务化后对所有的依赖必须基于强版本，所以对每一个发布的服务都提供了强版本策略，而且正常情况下保证每个新版本必须兼容旧版本；版本路线如图所示:<br><img src="/2018/06/18/Parepare-Service/version.jpg" alt="版本"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>  改造现有的流程控制系统，做到每个团队可以独立开发，独立测试，独立部署，独立上线以及独立回滚; 而且保证CI, CD能正常工作,所有流程能自动完成; </p>
<h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>首先拆分出基础服务,包括地址服务，推送服务，图片服务，等与业务无关的服务；其次按照业务领域进行拆分，包括订单，用户中心，支付等</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul>
<li>服务安全</li>
<li>物理分组 </li>
<li>多维度监控</li>
<li>等…</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式调度系统选型</title>
    <url>/2019/03/30/Schedule-Job/</url>
    <content><![CDATA[<h4 id="为什么需要调度系统"><a href="#为什么需要调度系统" class="headerlink" title="为什么需要调度系统"></a>为什么需要调度系统</h4><p>我们可能有这样的需求:</p>
<ol>
<li>在某个指定的时间点执行一个任务, 比如凌晨对前一天的数据进行汇总;</li>
<li>在某个操作后的指定时刻执行某一操作，比如：电商下单后一小时没有支付的订单需要被取消; </li>
<li>微服务失败后补偿操作;<span id="more"></span></li>
</ol>
<p>类似的需求我们都可以通过定时任务去完成。当然对于需求2，我们也可以利用MQ的延时投递功能去实现；但是，与外部系统交互只能用定时任务。</p>
<h4 id="Java领域主要分布式调度系统"><a href="#Java领域主要分布式调度系统" class="headerlink" title="Java领域主要分布式调度系统"></a>Java领域主要分布式调度系统</h4><ol>
<li>xxl-job：是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 。</li>
<li>Elastic-Job： 当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成；Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务；Elastic-Job-Cloud采用自研Mesos Framework的解决方案，额外提供资源治理、应用分发以及进程隔离等功能；</li>
<li>Saturn：是唯品会开源的一个分布式任务调度平台，在当当开源的Elastic Job基础上，取代传统的Linux Cron/Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理；</li>
<li>light-task-scheduler：阿里员工开源的个人项目,主要用于解决分布式任务调度问题，支持实时任务，定时任务和Cron任务。有较好的伸缩性，扩展性，健壮稳定性</li>
<li>Quartz: Java定时任务的标配。利用数据库的锁机制实现集群调度，业务代码需要考虑调度的逻辑，对业务代码有入侵。</li>
</ol>
<p>可能还有一些其它的系统个人不太了解，或者长期不在维护，它不在我们讨论的范畴。在这些系统中以xxl-job和Elastic-Job影响力最大，所以在调研的过程中以这两个系统为主.</p>
<h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><ol>
<li><p>xxl-job架构 </p>
<p><img src="/2019/03/30/Schedule-Job/xxl-job.png" alt="xxl-job架构"></p>
</li>
<li><p>Elastic-Job-Lite架构</p>
<p><img src="/2019/03/30/Schedule-Job/Elastic-Job-Lite.png" alt="Elastic-Job-Lite架构"></p>
</li>
</ol>
<p>从两个系统的架构上可以看出最大的区别是xxl-job有中心化的调度中心，所有的job由调度中心统一调度。而Elastic-Job-Lite没有统一调度中心，由每个Job各自任务节点通过选举算法选出调度节点，确切的说各个job之间没有统一的调度中心 ；Elastic-Job-Cloud依赖Mesos完成调度，资源隔离等工作。</p>
<h4 id="主要功能特性"><a href="#主要功能特性" class="headerlink" title="主要功能特性"></a>主要功能特性</h4><table>
<thead>
<tr>
<th></th>
<th>xxl-job</th>
<th>Elastic-Job</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度中心HA</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>执行器HA</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>弹性扩容缩容</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>失效转移</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>任务失败重试</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>作业分片一致性</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>资源隔离</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>多语言</strong></td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><strong>权限管理</strong></td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<p>从主要功能看上去两者都能提供很好的支持；在多语言支持方面，xxl-job提供通用HTTP任务Handler,业务方只需要提供HTTP链接即可，不限制语言。Elastic-Job目前只能支持Java，其它语言支持需要自行扩展。</p>
<h4 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h4><p>对于开源项目的选择，社区支持是非常重要的因素；强大的社区意味着，在遇到问题的时候可以得到社区资源的支持，否则只能自己解决了；社区支持我们以github的数据为准:</p>
<table>
<thead>
<tr>
<th></th>
<th>xxl-job</th>
<th>Elastic-Job</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Star</strong></td>
<td>7408</td>
<td>4707</td>
</tr>
<tr>
<td><strong>Fork</strong></td>
<td>3121</td>
<td>2216</td>
</tr>
<tr>
<td><strong>Contributers</strong></td>
<td>17</td>
<td>17</td>
</tr>
<tr>
<td><strong>Open Issues</strong></td>
<td>82</td>
<td>115</td>
</tr>
<tr>
<td><strong>Close Issues</strong></td>
<td>602</td>
<td>384</td>
</tr>
<tr>
<td><strong>Latest Updated</strong></td>
<td>24天前</td>
<td>一年前</td>
</tr>
<tr>
<td><strong>已登记使用的公司</strong></td>
<td>163</td>
<td>63</td>
</tr>
</tbody></table>
<p>从以上数据可以看出来，xxl-job在社区支持方面有更大优势 。</p>
<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h4><ul>
<li>xxl-job可以做到开箱即用，配置信息在管理控制台有UI统一配置，更容易上手 ; 包括监控，报警都可以在管理控制台完成。</li>
<li>Elastic-Job配置信息在执行器的spring xml文件完成，监控，报警需要自己定制 。</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>从两者的架构可以发现，在大任务量的情况下，Elastic-Job性能要高于xxl-job 。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>  如果对于技术实力比较强大的团队，而且对性能要求比较搞的情况下，建议选择Elastic-Job，在该基础上进行定制开发，可以取得更好效果；对于技术实力不足，性能能要求不是很高，而且希望快速开发，快速上线建议选择了xxl-job 。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.xuxueli.com/xxl-job">http://www.xuxueli.com/xxl-job</a><br><a href="http://elasticjob.io/">http://elasticjob.io</a><br><a href="https://vipshop.github.io/Saturn">https://vipshop.github.io/Saturn</a><br><a href="https://github.com/ltsopensource/light-task-scheduler">https://github.com/ltsopensource/light-task-scheduler</a></p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化-服务拆分</title>
    <url>/2018/09/24/Service-Split/</url>
    <content><![CDATA[<p>服务化的过程中必然会面对服务拆分的问题；拆分粒度太粗不能体现服务化的优势，拆分过细会导致各项成本过高；所以架构师在服务拆分时要权衡各方面的利弊根据当前情况做出最优解;以下内容是我们团队在使用dubbo的过程，根据实际情况考虑的服务拆分方式；<span id="more"></span></p>
<h3 id="拆分考虑的因素"><a href="#拆分考虑的因素" class="headerlink" title="拆分考虑的因素"></a>拆分考虑的因素</h3><ul>
<li>业务领域</li>
<li>上下层级调用关系</li>
<li>技术因素</li>
<li>成本</li>
</ul>
<p>我们在拆分过程中充分考虑以上4个因素；特别是在业务领域方面有较多的争议；业务领域下可以继续分子领域，所以在实际方案设计过程中部分团队服务拆分太细；经过多次沟通后我们将部分模块合并为一个provider，因为拆分过细对我们会有如下问题：</p>
<ul>
<li>目前我们数据库没有拆分(下阶段会根据个业务线拆库)，服务过细会增加数据库的连接数量</li>
<li>增加了运维成本</li>
<li>增加硬件成本</li>
</ul>
<h3 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h3><ul>
<li>模块按照子业务领域和上下层级拆分</li>
<li>服务调用只能上层服务调用下层服务</li>
<li>禁止provider之间循环调用</li>
<li>相同层级的模块可以作为同一个服务对外发布</li>
<li>模块可以低成本的拆分为一个独立的provider</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                        ___Api</span><br><span class="line">                       |</span><br><span class="line">          ___Model_A--&gt;|</span><br><span class="line">          |            |___Impl</span><br><span class="line">          |            </span><br><span class="line">          |</span><br><span class="line">          |              ___Api</span><br><span class="line">          |             |</span><br><span class="line">Proider--&gt;|___Model_B--&gt;|</span><br><span class="line">          |             |</span><br><span class="line">          |             |___Impl</span><br><span class="line">          |              </span><br><span class="line">          |             </span><br><span class="line">          |____dubbo_provider.xml   </span><br></pre></td></tr></table></figure>

<h4 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h4><ul>
<li>Model_A和Model_B必须是同一层级的模块，比如: 同为数据访问层或者同为业务服务层</li>
<li>对外仅提供各个model的Api</li>
<li>同一个服务可以发布多个模块,节省成本</li>
<li>服务调用只能是上层服务调用下层服务，从而避免服务循环调用</li>
<li>各Model可以低成本的拆分为独立的provider</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Sharding-JDBC(ShardingSphere)多数据库与springboot集成 -- 读写分离</title>
    <url>/2020/04/11/ShardingSphere-Springboot/</url>
    <content><![CDATA[<p>Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入<code>sharding-jdbc-spring-boot-starter</code>可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。<span id="more"></span></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h3><ul>
<li><p> 实现<code>EnvironmentAware</code>接口 ，在方法<code>setEnvironment</code>解析properties配置可以获取所有配置信息</p>
</li>
<li><p>获取以<code>spring.ydal</code>为前缀的所有数据库配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; databases = PropertyUtil.handle(environment, &quot;spring.ydal&quot; , Map.class);</span><br></pre></td></tr></table></figure></li>
<li><p>构造每个数据库的数据库的MasterSlave数据源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;datasource&quot;, Map.class);</span><br><span class="line"> Preconditions.checkState(!dataSourceProps.isEmpty(), &quot;Wrong datasource properties!&quot;);</span><br><span class="line"></span><br><span class="line"> DataSource datasource = DataSourceUtil.getDataSource(dataSourceProps.get(&quot;type&quot;).toString(), dataSourceProps);</span><br><span class="line"> Optional&lt;DataSourcePropertiesSetter&gt; dataSourcePropertiesSetter = DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get(&quot;type&quot;).toString());</span><br><span class="line"> if (dataSourcePropertiesSetter.isPresent()) &#123;</span><br><span class="line">     dataSourcePropertiesSetter.get().propertiesSet(environment, prefix, dataSourceName, datasource);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">masterSlaveRule = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.masterslave&quot;, YamlMasterSlaveRuleConfiguration.class);</span><br><span class="line">MasterSlaveRuleConfiguration msConfig = new MasterSlaveRuleConfigurationYamlSwapper().swap(masterSlaveRule);</span><br><span class="line"></span><br><span class="line">Properties dsProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.props&quot;, Properties.class);</span><br><span class="line">MasterSlaveDataSourceFactory.createDataSource(datasource, msConfig, dsProps)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="禁用ShardingSphere的Springboot的自动配置"><a href="#禁用ShardingSphere的Springboot的自动配置" class="headerlink" title="禁用ShardingSphere的Springboot的自动配置"></a>禁用ShardingSphere的Springboot的自动配置</h3><p>实现该扩展后以jar包的形式提供出去供多个项目使用，所以我们必须在jar里面禁用ShardingSphere的Springboot的自动配置；可以实现如下接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class YdalAutoConfigurationImportFilter implements AutoConfigurationImportFilter &#123;</span><br><span class="line">    private static final Set&lt;String&gt; SHOULD_SKIP = new HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(&quot;org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration&quot;));</span><br><span class="line">    @Override</span><br><span class="line">    public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">        boolean[] matches = new boolean[autoConfigurationClasses.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt; autoConfigurationClasses.length; i++) &#123;</span><br><span class="line">            matches[i] = !SHOULD_SKIP.contains(autoConfigurationClasses[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return matches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>YdalAutoConfigurationImportFilter</code>加入<code>META-INF/spring.factories</code></li>
</ul>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><ul>
<li>详细代码： <a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a></li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Sharding-JDBC(ShardingSphere)SQL监控实践</title>
    <url>/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起<span id="more"></span>。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们的需求是监控应用程序对数据库的SQL执行情况，并将其与现有的指标集成。我们希望监控以下指标（但不限于）：</p>
<ul>
<li>SQL语句的执行时间</li>
<li>SQL语句的执行次数</li>
<li>SQL语句的执行结果</li>
<li>SQL语句的主库和备库路由</li>
</ul>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>我们现有数据库相关技术栈包括MySql, Sharding-JDBC,HikariDataSource和MyBaties；在方案设计阶段，我们考虑了以下三种方案：</p>
<h4 id="ShardingSphere的metrics"><a href="#ShardingSphere的metrics" class="headerlink" title="ShardingSphere的metrics"></a>ShardingSphere的metrics</h4><p> ShardingSphere的agent供了SQL监控的功能，具体可参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/observability/">ShardingSphere的可观测性</a>然而，该代理会暴露一个独立的监控指标页面，无法直接集成到我们现有的监控指标页面中。我们需要单独采集ShardingSphere代理的监控指标，并将其与现有指标进行整合，这增加了一定的复杂性，因此我们放弃了该方案。</p>
<h4 id="Mybaties的拦截器"><a href="#Mybaties的拦截器" class="headerlink" title="Mybaties的拦截器"></a>Mybaties的拦截器</h4><p> 使用MyBatis的拦截器实现SQL监控非常简单，只需实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可。以下是一个示例代码：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line">public class SqlMetricsInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];</span><br><span class="line">        SqlCommandType sqlCommandType = mappedStatement.getSqlCommandType();</span><br><span class="line">        /** 上报sql metrics**/</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        if (target instanceof Executor) &#123;</span><br><span class="line">            return Plugin.wrap(target, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  在容器启动后，我们将该拦截器注入到MyBatis的org.apache.ibatis.session.SqlSessionFactory中：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line">private ObjectProvider&lt;Interceptor&gt; interceptorsProvider;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ObjectProvider&lt;SqlSessionFactory&gt; sqlSessionFactories;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    for (SqlSessionFactory factory : sqlSessionFactories) &#123;</span><br><span class="line">        for (Interceptor interceptor : interceptorsProvider) &#123;</span><br><span class="line">            factory.getConfiguration().addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过以上步骤，我们可以在现有的监控指标页面中看到采集到的与SQL相关的监控指标。但是，该方案无法区分主库和备库的SQL。</p>
<h4 id="JDBC-Statement"><a href="#JDBC-Statement" class="headerlink" title="JDBC Statement"></a>JDBC Statement</h4><p>  我们知道，最终的SQL执行是通过JDBC的Statement完成的，因此我们可以直接在JDBC的Statement执行SQL的地方上报监控指标。我们可以自定义Statement来执行SQL，并同时上报SQL的监控指标。以下是类关系图示例：<br>   <img src="/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/ShardingSphere-JDBC-SQL-Metrics-class.png"></p>
<p>   在<code>DalStatement</code>和<code>PreparedStatement</code> 重载<code>executeQuery</code>和<code>executeUpdate</code> 方法增加相关监控指标，具体代码可参考<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">ydal-spring-boot-starter</a></p>
<p>   这样可以输出类似如下的metrics上报到prometheus<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql_execute_time_seconds_count&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 82.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 12.373654891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 14.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 167.934782891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 1.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 0.493257718</span><br></pre></td></tr></table></figure><br>   通过这种方式，我们可以在现有的监控指标页面中查看采集到的SQL监控指标，并区分主库和备库的SQL。 详细代码：<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次SQL监控的实践，我们成功地集成了SQL监控功能到我们的应用程序中，并将其与现有的指标集成在一起。这使得我们能够更好地了解应用程序对数据库的访问情况，并及时发现潜在的性能问题和瓶颈。我们选择了自定义的JDBC Statement来实现SQL监控，并通过上报监控指标的方式将其集成到现有的监控系统中。这种方案简单且有效，使我们能够对SQL执行进行精确监控，并根据需要进行进一步的优化和调整。尽管我们在本次实践中取得了成功，但我们也意识到SQL监控仅仅是性能优化和数据库访问管理的一部分。在未来的项目中，我们将继续探索更多的数据库访问优化技术，并进一步提高应用程序的性能和可伸缩性。</p>
]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>技术给业务赋能</title>
    <url>/2019/04/27/Tech-VS-Biz/</url>
    <content><![CDATA[<p>技术人员在技术选型的时候如何做好技术与业务的平衡，如何推广技术方案，甚至与产品人员沟通改变某些功能的实现方式，这些问题值得每一个技术人员思考。我们不管采用什么技术方案，最终目的是为了帮助业务发展，使公司在商业上获取回报。如果技术人员能有一些产品和运营的思维，对整个业务的发展会起到更好的效果。<span id="more"></span></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型我们要考虑很多因素：产品所处的阶段，技术栈，当前的技术实力，技术债务，时间,等… 。特别是产品的不同阶段其目标也不同：</p>
<ol>
<li><p>初创阶段：这个阶段重点考虑两个方面：</p>
<ul>
<li>1.1 <strong>快</strong>：这个时候重点是<strong>快速上线</strong>，快速验证。同时，技术人员应该注意到有些需求产品人员没有提出来，但以后肯定有这个需求，只是当前优先级比较低。所以技术人员应该考虑到这些需求对现有方案可能存在的影响；如果是举手之劳的事情就顺便实现，至少在设计表结构时应该考虑到。可能有人会说该阶段到底哪些需求应该考虑，哪些不应该考虑；我个人的想法是支撑半年内业务的发展不需要重构为目标。所以在出方案前一定要跟产品，运营等业务方充分沟通拿到所有的数据，比如：半年后PV到多少，单量是多少等业务数据，以此为目标。</li>
<li>1.2 <strong>可维护性</strong>：产品第一版上线后，会持续迭代和bug修复；从可维护性的角度应该考虑这几点：<ul>
<li>当前团队有相应的技术储备</li>
<li>业界有大量的工程师正在使用的技术</li>
<li>如果是开源项目,其社区足够庞大，如果是商业项目需要有充分的技术支持</li>
<li>一定是让团队内部最资深的工程师开始写第一行代码，因为所有的项目在重构前，代码一定会越写越烂 </li>
</ul>
</li>
</ul>
</li>
<li><p>成长阶段 ：这个阶段产品的商业模式已经被验证过，产品正在为大量的用户提供服务，而且业务正在快速发展中，此时的技术方案以不影响现有业务为前提，或者说将影响降到最低，就是行业内所说的<strong>给飞行中的飞机换引擎</strong> 。 个人认为此阶段的技术方案应该重点考虑<strong>可落地</strong> ,一般这个阶段团队也会扩大，同时会引入一些外部人才。这个时候会出现一些新的思想，新的方案，此时要特别注意这些方案是不是立足于本团队的实际情况。特别一些大厂背景的工程师，可能会给出一些高大上的方案，但是各项成本可能非常高。即便是一些规模相当友商团队的工程师过来给出的方案也不一定能马上落地，因为没有一家企业的流程，制度，文化跟另一家企业是完全一样的，技术方案本质是用技术的手段解决业务的问题，流程的问题，质量的问题，效率的问题，成本的问题。</p>
</li>
</ol>
<h3 id="技术方案推广"><a href="#技术方案推广" class="headerlink" title="技术方案推广"></a>技术方案推广</h3><p>有人说一个技术方案的效果只有在实施后才能知道，我个人认为一个技术方案如果推广成本太高一定不是一个好的方案。在出方案时候就应该考虑到如何去推广，一般情况下开发团队时间很紧迫，不可能为了一个技术改造耽误太多时间。我个人的做法是在出方案前跟相关团队沟通清楚当前面对的问题，以及各个团队的诉求。根据具体的问题给出适合的方案，接下来跟自己的领导沟通方案以及部分细节，确保能得到领导的支持「这点非常重要」；再准备方案，包括但不限于相应的文档，代码，工具，流程等；在正式推广之前，召集所有团队相关负责人「甚至所有技术人员」宣讲，主要包括几个方面：面对的问题，应对方案，如何实施，相关团队如何配合与执行，达到的效果，deadline 。特别是团队配合与执行部分给出详细的执行步骤，以及常见的QA。要站在执行团队的立场上考虑问题，让执行团队充分意识到，采用了新方案后可以提升效率，提升质量或者节省成本，等；可能经过多次沟通后仍有部分团队不能配合执行，此时只能将问题上升到更高一层管理者来协调 。技术方案的实施要充分权衡成本与业务的影响，比如一个案例：业务方要求实施方案不允许停机，然而跟业务方沟通告知不停机的成本太高，最终选择了凌晨业务低峰时期停机20分钟来完成，实际实施的过程中真正停机的时间只有5分钟；然而，该时间段对业务的影响也非常低，因此最终的方案都是权衡各方的利益后博弈的结果。方案实施后要监控各项指标，查看各项指标是否符合预期，如果没有达到预期目标，一定要找到根本原因是方案本身的问题，还是执行过程的问题，避免相同的问题再次出现。</p>
<h3 id="与产品人员沟通"><a href="#与产品人员沟通" class="headerlink" title="与产品人员沟通"></a>与产品人员沟通</h3><p>我们经常看到一些关于产品人员和技术人员相爱相杀的段子，我认为现实中这样的例子并不多「也许我经历少」。技术人员拿到PRD后要仔细分析PRD背后的逻辑和诉求，有些看似简单需求背后可能需要复杂的技术支撑，不是每一个产品人员都有技术背景，此时需要技术人员跟产品人员充分沟通该需求的实现成本「理论上来说所有的需求都是可以实现的」，帮助产品人员梳理出重点和优先级，适当的时候可以减少需求或者改变产品逻辑。切忌一句“这是一个伪需求”或“这个需求实现不了” ；如果认为是伪需求请给出具体的数据，一切以数据为依据 ，即使实现不了也应该告知当前的困难，是资源问题，还是时间的问题等。如果多次沟通都没效果建议换个产品人员伺候，如果你没有选择的余地或者你认为公司都是这种产品人员，建议还是换工作吧。</p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>技术的世界比较简单，确定的输入一定可以得到确定的输出，然而，我们的世界并不总是这样，有很多东西是没有绝对的对错之分。技术人员可以经常与非技术人员聊聊，听听他们看问题的角度，听听他们的诉求；也许这样可以让技术更好的帮助业务成长。</p>
]]></content>
  </entry>
  <entry>
    <title>RestTemplate使用Apache HttpClinet连接池默认大小引发耗时瞬间升高</title>
    <url>/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/</url>
    <content><![CDATA[<p>在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由<code>HttpURLConnection</code>,<code>Apache HttpComponents</code>和<code>OkHttp</code>三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高<span id="more"></span></p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>今天天收到报警说我们有一个服务A的接口TP95瞬间升高，打开监控检查发现流量瞬间升高时，耗时会瞬间升高，如图所示；<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/monitor.jpg" alt="图一"><br>打开链路跟踪查看调用链关系，发现该时接口耗时几乎全部耗费在调用下游服务B，如图所示；正常情况下服务B接口TP95耗时在500毫秒以内<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/opentracing.jpg" alt="图二"><br>而且该服务接口连接超时设置2秒，读取超时设置2秒；所以预期内该接口在4秒内应该结束。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="监控检查"><a href="#监控检查" class="headerlink" title="监控检查"></a>监控检查</h4><ol>
<li>查看服务B的监控发现服务B的耗时一直很稳定，几乎没有波动</li>
<li>查看服务C对服务B相同接口的调用在该时刻也很稳定</li>
<li>查看服务A的GC监控，gc最长耗时60ms，也不会引起该问题 </li>
<li>查看网络监控，一切正常</li>
</ol>
<p>通过监控数据基本确定问题不在服务B，另外Ops工程师反馈近期也没做过任何infrastrucre调整；基本确定问题仍然在服务A，接下来review服务A请求服务B的相关代码</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>服务A代码中用<code>RestTemplate</code>调用服务B的接口, <code>RestTemplate</code>的Bean采用默认注入的Builder来生成，而且设置了连接超时和读取超时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">    return builder.setReadTimeout(Duration.ofMillis(readTimeoutConfig)).setConnectTimeout(Duration.ofMillis(connectTimeoutConfig)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码形式<code>RestTemplate</code>底层实现采用了<code>Apache HttpComponents</code>作为HTTP客户端，<code>Apache HttpComponents</code>在初始化过程中会用默认参数初始化连接池，最终代码会执行到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PoolingHttpClientConnectionManager(</span><br><span class="line">    final HttpClientConnectionOperator httpClientConnectionOperator,</span><br><span class="line">    final HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span><br><span class="line">    final long timeToLive, final TimeUnit tunit) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.configData = new ConfigData();</span><br><span class="line">    this.pool = new CPool(new InternalConnectionFactory(</span><br><span class="line">            this.configData, connFactory), 2, 20, timeToLive, tunit);</span><br><span class="line">    this.pool.setValidateAfterInactivity(2000);</span><br><span class="line">    this.connectionOperator = Args.notNull(httpClientConnectionOperator, &quot;HttpClientConnectionOperator&quot;);</span><br><span class="line">    this.isShutDown = new AtomicBoolean(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码第7行构造<code>CPool</code>时传递的常量<code>2</code>表示连接池请求相同域名最大连接数，<code>20</code>表示连接池访问所有域名的最大连接数 。</p>
<p>至此，问题已然清楚，当zeus-order请求量瞬间升高时zeus-order访问zeus的并发量也瞬间增大，如果超过2个并发的HTTP请求只能等待，由于没有设置从连接池获取连接的超时时间，会无限等待，直到连接池内有空闲的HTTP连接然后获取连接继续发出HTTP请求，这样整个请求耗时将可能超过设置的HTTP超时时间</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>基于以上分析，我们使用自定义的HttpClient传递相关参数即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        PoolingHttpClientConnectionManager connectMgr = new PoolingHttpClientConnectionManager() ;</span><br><span class="line">        connectMgr.setDefaultMaxPerRoute(defaultMaxPerRoute);</span><br><span class="line">        connectMgr.setMaxTotal(maxTotal);</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connectMgr)</span><br><span class="line">                .build();</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">                new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        requestFactory.setConnectTimeout(connectTimeoutConfig);</span><br><span class="line">        requestFactory.setReadTimeout(readTimeoutConfig);</span><br><span class="line">        requestFactory.setConnectionRequestTimeout(connectRequestTimeoutConfig);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(requestFactory);</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>自定义三个超时时间：<br><strong>connectTimeout</strong>:            建立连接的超时时间<br><strong>readTimeout</strong>:               读取数据的超时时间<br><strong>connectionRequestTimeout</strong>:  从连接池获取连接的超时时间</p>
<p>修改以后上线观察一天即时出现上述问题的高峰瞬间，耗时始终保持平稳。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与Go之间gRPC调用失败问题排查</title>
    <url>/2019/06/02/gRPC-Go-Java/</url>
    <content><![CDATA[<p>最近接手了一个新项目，被告知Java代码的gRPC客户端无法访问当前项目中Go代码的gRPC服务。通过问题的排查和部分代码改造个人对gRPC的理解更深入了一层.<span id="more"></span></p>
<h3 id="项目背景："><a href="#项目背景：" class="headerlink" title="项目背景："></a>项目背景：</h3><p>接手该项目后跟该项目相关人员多次沟通后得到如下背景信息:</p>
<ol>
<li>该项目Go服务端采用的是2016年9月以前发布的gRPC ；</li>
<li>项目组对官方提供的Go语言gRPC类库做了部分改造，但，由于改造该代码的工程师已经离职，目前没有人知道具体修改了什么​；</li>
<li>由于项目周期紧张，没有富余的人力排查该问题；</li>
<li>目前Java与Go互相交互的接口不到10个，双方先采用HTTP交互;</li>
<li>服务端总是需要维护两套接口，HTTP和gRPC接口，链路跟踪等公共组件都要适配两套接口，增加了维护成本</li>
</ol>
<h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><ol>
<li>采用Java版本gRPC-Java-1.18.0访问现有的Go服务，请求发出以后被hang住没有任何反馈直到客户端设置的连接超时后断开，Java客户端和Go服务端没有任何输出信息；</li>
<li>抓包看包文发现在完成TCP的3次握手后，客户端发送了第一HTTP2的包文后，没有收到服务端的任何回复，整个过程被hang；初步估计是双方采用的HTTP2协议不兼容。</li>
<li>采用低版本的Java gRPC, 调研发现Java的gRPC在2016年9月以前的最新版本是1.0.0，所以从1.0.0开始测试，最终发现0.9.0可以完成正常请求。</li>
</ol>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>调研发现0.9.0版本的Java gRPC依赖了4.1.0.Beta6的Netty，该Netty版本发布与2015年9月， 而HTTP2在2015年有多次修订，版本号也升级到了17；我估计该版本的Netty是根据HTTP2修订版17以前的规范实现的,而且该版本为Beta版，导致跟其它语言的协议存在某些差异。</p>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>采用0.9.0版本的gRPC后会带来以下新问题：</p>
<ol>
<li>现有的Java项目框架采用springcloud2.0.0，该版本依赖了Netty的4.1.27.Final版本，项目集成后会出现版本冲突导致各种异常出现；</li>
<li>0.9.0版本的gRPC缺少很多重要的特性，比如：nameresolver，负载均衡 等 …</li>
<li>最终还是要升级到新版本</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>综合沟通下来最好的方案就是Go服务端升级gRPC到新版本 ，但是团队将官方代码改造后已经无法做到无缝升级，必须要做部分改造才能投入生产​；目前生产环境运行的Go服务超过50+，而且大部分是核心服务；改造后需要充分的测试，总体成本太大，而且目前没有更多的资源投入。最终决定才有用低版本的Java gRPC​，采用以下的措施应对低版本面临的问题:</p>
<ol>
<li>所有的Java项目提供统一的parent pom文件，所有的版本信息在parent pom的dependencyManagement中维护；</li>
<li>增加新功能：nameresolver，负载均衡，兼容Go服务的服务发现，等…</li>
</ol>
<h3 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h3><p>我们在技术选型的不能过于保守也不能过于激进；太过保守不能充分利用新技术的优势，甚至会影响到团队士气；太过激进会遭遇太多的不确定性，面临着遇到问题没有先例可以参考，遭遇新的bug，等；所以，在团队没有足够的技术支撑的情况下，我不太建议生产环境采用1.0以下的版本。作为技术人员应该随时关注业界的新技术，但在生产环境采用新技术前必须考虑清楚所面对的各种风险，包括以后的升级能否做到无缝升级。​</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h5><p><a href="https://grpc.io/">https://grpc.io/</a><br><a href="https://github.com/grpc/grpc-java">https://github.com/grpc/grpc-java</a><br><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/">https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/</a></p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务实现</title>
    <url>/2018/05/22/distributed-transaction/</url>
    <content><![CDATA[<p>在分布式系统中，同时满足“CAP定律”中的“一致性”、“可用性”和“分区容错性”三者是不可能的。在互联网领域的绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。<span id="more"></span></p>
<h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><p>XA规范主要定义了事务管理器(Transaction Manager)和资源管理器(Resource Manager)之间的接口. XA引入事务管理器是因为在分布式系统中，从理论上讲两台机器上无法达到一致的状态，需要引入一个外部点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源, 资源管理器负责控制和管理实际资源 。XA是一个两阶段提交协议，该协议分为以下两个阶段：</p>
<ol>
<li> 事务协调器要求每个涉及到事务的数据库预提交，并反映是否可以提交 。</li>
<li>事务协调器要求每个数据库提交数据 。</li>
</ol>
<p>如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息 。</p>
<h3 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h3><p>JTA作为JAVA平台上的事务规范，同时定义了对XA事务的支持；在JTA中，事务管理器抽象为javax.transaction.TransactionManager接口，通过底层事务服务（即JTS）实现,JTA仅仅定义了接口，具体的实现则是由供应商(如J2EE厂商)负责提供，目前JTA的实现主要由J2EE容器所提供的JTA实现(如JBOSS)和独立的JTA实现(如JOTM，Atomikos)。</p>
<blockquote>
<p>JTA本质上是两阶段提交，实现复杂，牺牲了可用性，对性能影响较大, 适合对数据强一致(<strong>其实也不能100%保证强一致</strong>)要求很高的关键领域; 大部分互联网业务都不会采用两阶段提交的方式 。</p>
</blockquote>
<h3 id="链式事务管理"><a href="#链式事务管理" class="headerlink" title="链式事务管理"></a>链式事务管理</h3><p>这种方式也Spring提供的，可以将两个或多个数据库资源的事务串联到一起，公用一个TransactionManager来实现对多个资源的事务。配置方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.data.transaction.ChainedTransactionManager&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;transactionManagers&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean</span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource1&quot; /&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">      &lt;bean</span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource2&quot; /&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> &lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>针对多个数据库实现事务。使用这种方式时，在Spring事务提交的时候，它会依次调用里面的多个dataSource的commit()方法，如果业务方法出错，就会按照相反的顺序调用rollback()方法。这种方法可能会出现先前的提交成功，之后的提交失败，所以还是会有事务失败的可能。</p>
<blockquote>
<p>实现简单，但可能会出现先前的提交成功，之后的提交失败，所以还是会有事务失败的可能</p>
</blockquote>
<h3 id="最大努力一次提交-Best-Efforts-1PC"><a href="#最大努力一次提交-Best-Efforts-1PC" class="headerlink" title="最大努力一次提交(Best Efforts 1PC)"></a>最大努力一次提交(Best Efforts 1PC)</h3><p>在一个系统中使用数据库和带事务功能的消息中间件，业务流程如下</p>
<ol>
<li>开始消息事务</li>
<li>发送消息</li>
<li>开始数据库事务</li>
<li>更新数据库</li>
<li>提交数据库事务</li>
<li>提交消息事务</li>
</ol>
<p>有两个事务，分别是DB的和JMS的事务，事务的开启和提交都是相互独立的。依次提交这两个事务，只要第二个事务顺利提交，整个方法就能够保证数据的一致性。实际上，在绝大多数情况下，只要数据库和MQ能够正常访问，这也确实能够保证。所以，这种方式就叫’最大努力’一次提交。</p>
<p>使用这种方式，事物提交的顺序是非常重要的。假设在提交messaging transaction的时候发生错误，这时数据库的事务已经提交，无法回滚，但是消息的事务被回滚，那么这一条消息会被重新放回队列中，该业务方法会被再次触发，再次在一个新的事务中处理。但是，这时数据的处理已经完成，只是最后JMS的事物提交出错，那么就需要通过防止重复提交的方式，来避免数据库的再次处理。</p>
<h3 id="事务补偿型-TCC型事务–Try-Confirm-Cancel"><a href="#事务补偿型-TCC型事务–Try-Confirm-Cancel" class="headerlink" title="事务补偿型(TCC型事务–Try/Confirm/Cancel)"></a>事务补偿型(TCC型事务–Try/Confirm/Cancel)</h3><p>其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的, 即：只要Try成功，Confirm一定成功</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放</li>
</ul>
<p>在一个长事务，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B所处理时间可能比较长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个<strong>补偿</strong>操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的事务模型，是牺牲了一定的隔离性和一致性的，但是提高了事务的可用性。</p>
<blockquote>
<p>与两阶段提交相比实现及流程相对简单，但应用层要写很多补偿代码(而且补偿也不能保证一定成功)</p>
</blockquote>
<h3 id="本地流水表实现最终一致性"><a href="#本地流水表实现最终一致性" class="headerlink" title="本地流水表实现最终一致性"></a>本地流水表实现最终一致性</h3><p>以电商下单场景为例，主要涉及到两个操作，<strong>扣减库存</strong>和<strong>生成订单</strong>,因为两个操作在不同的数据库，无法保证强一致性,可以通过本地流水表来实现最终一致性 ， 具体流程如下:</p>
<ul>
<li>生成交易操作唯一标示token</li>
<li>事务一(库存系统): <ul>
<li>冻结库存</li>
<li>根据下单流水号生成商品的库存冻结记录,冻结记录主要包括<strong>skuId</strong>,<strong>token</strong>,<strong>冻结数量</strong>,<strong>状态</strong> .状态有3种状态: <strong>已冻结</strong>，<strong>下单成功扣减</strong>，<strong>下单失败释放</strong>,初始状态为已冻结</li>
</ul>
</li>
<li>如果事务一失败，直接返回；如果成功进入事务二 </li>
<li>事务二(订单系统, 本地事务)：根据token生成订单,订单的状态主要包括：<strong>未支付</strong>,<strong>已支付</strong>,<strong>超时未支付</strong>,订单的初始状态为<strong>未支付</strong></li>
<li>事务二如果成功，则进行后续的流程,</li>
<li>事务二如果失败，调用库存系统的回滚接口，返回下单失败;</li>
<li>定时任务: 因为存在<strong>事务一成功</strong>而<strong>事务二</strong>失败的情况，这样会冻结商品的部分库存，所以可以捞取出创建超过一定时间状态为<strong>已冻结</strong>的所有冻结记录，根据每个冻结记录的token去订单表查询，若不存在对应的订单，则将冻结记录的状态更新为<strong>下单失败释放</strong>，并回滚商品库存数量</li>
</ul>
<h3 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h3><p>将一些有同步的事务操作变为异步操作，避免对数据库事务的争用；继续以以电商下单场景为例，支付成功后增加用户积分；</p>
<ul>
<li>事务一(订单系统)，订单状态修改为支付成功，发送支付成功消息</li>
<li>事务二(用户系统)，用户系统接到支付成功消息后，增加用户积分</li>
</ul>
<h3 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h3><p>一些第支持事务消息MQ，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，其思路大致为：</p>
<ul>
<li>第一阶段Prepared消息，会拿到消息的地址。</li>
<li>第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ul>
<p>在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，是回滚还是继续发送确认消息。这样就保证了消息发送保证与本地事务同时成功或同时失败 </p>
<h3 id="分布式事务实现的原则"><a href="#分布式事务实现的原则" class="headerlink" title="分布式事务实现的原则"></a>分布式事务实现的原则</h3><ul>
<li>大事务拆成小事务，每个小事务都是单机上的事务</li>
<li>补偿 + 重试， 业务上设计补偿机制，而且保证补偿失败后有重试机制</li>
<li>幂等, 保证每次事务操作是幂等的，保证幂等的方式可以采用：<ul>
<li>状态值，每次写操作的时候检查状态值</li>
<li>唯一标示，每次写操作都带入业务唯一标示</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提一个问题</title>
    <url>/2018/12/23/how-to-question/</url>
    <content><![CDATA[<p>在我们日常生活以及工作中经常会遇到提问题, 我们有没有想过如何提一个好问题？也许有人会说，「提问谁不回？会讲话的小孩子就会问为什么，这有什么值得说的？」没错，从这个角度上说机会每个人都会提问。但是，我们有没有想过，我们问问题的目的是什么？是得到对问题的解答。大家有没有遇到过这样的情况，自己问题发给对方后始终得不到回复，或者对方敷衍了事，更有甚者被对方怼回去。如果遇到这些情况，我们应该好好反思一下，我们是不是提了一个好问题；在说好问题之前结合个人的经历谈谈什么样的问题不是一个好问题。<span id="more"></span></p>
<ol>
<li>提问者在im上发一个截图，截图里面是一个异常栈，没有任何上下文，然后就没有然后了；解答者在那里等对方进一步的信息，结果什么也等到；过了很久(估计等很久没回复)，亲自过来说「帮我看看我的问题」；这个时候才开始沟通，问题是怎么出现的，什么环境，上下文，等… </li>
<li>有些问题在技术文档，产品文档上都已经说的很清楚；但提问者不看文档，直接把问题抛过来；也许是提问者自己没有按照文档要求操作，或者真的是一个问题但文档FAQ部分已经解释的很清楚 ；</li>
<li>提问者直接将问题抛出来，不做任何思考和尝试，只在那里等答案；不知道提问者有没有想过，解答者也要花费大量的时间去调研；</li>
<li>提问者提问道时候，发的关键信息是一张截图，截图中可能有id之类的标示，此时解答者可能需要根据id搜索，只能手工输入，这样既浪费时间也容易出错；</li>
</ol>
<p>对于以上的案例，个人觉得提问者需要加强独立思考的能力，不然会给对方留下「伸手党」的感觉；个人觉得可以按照如下的方式考虑提问:</p>
<ol>
<li>对于技术问题或者产品问题，一般作者会提供相应的文档；首先我们应该阅读相关文档，特别注意FAQ部分；</li>
<li>善于使用搜索引擎，具备基本的搜商(SQ) ,推荐用google(对技术工作者，这个不需要解释), 百度请忽略所有「广告」字样的文章，微信，知乎等工具;</li>
<li>在以上两步都没有找到答案情况下，可以参考第二步搜索过程中出现的文章以及官方提供的文档尝试；比如是否可以升级软件版本，是否可以调整某些参数；相信在尝试过程中会加深自己对问题的理解以及提升自己解决问题的能力</li>
<li>经过以上步骤能解决95%的问题了；如果还没有解决，这时候再提问，相信这个时候提出的问题质量是非常高的；比如: 该问题是如何出现的，什么环境，硬件型号是什么，软件版本是什么，我的操作步骤是什么，我做了哪些调研，尝试了哪些方式，得到结果是什么,等.. </li>
</ol>
<p>那么提一个好问题有那么重要吗？我认为提一个好问题比解答一个问题更能体现一个人的真实水平，因为这证明提问者有独立思考的能力；比如在职场中一个常见的场景是这样的，面试最后部分面试官会问面试者有什么问题吗？这个时候如果提一个高质量的问题，相信会加深面试官的印象,在同等条件的候选者中相信胜出的概率会更高;</p>
<p>最后关于什么是好问题，这里引用某大佬的一句话 「什么是好问题，你对某个领域有一定研究，你已经翻阅和查询了足够的资料，然后你基于你的理解，对这些资料中，某几个无法理解的细节提出来，希望专业人士给与解惑，而这个细节问题确实具有足够代表性，是理解一些关键问题的钥匙，这就是好问题。」</p>
]]></content>
  </entry>
  <entry>
    <title>基于protobuf的定义在跨语言消息传递中的应用</title>
    <url>/2021/09/21/message-dsl-base-protobuff/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中<span id="more"></span>通常通过文档约定消息格式各自定义自己的消息体。在我们实际使用过程中发现不同语言之间传递信息还是会出现一些问题；比如：Java用fastjson输出复杂数据在Go项目解析失败，而且各语言在配置mq参数时候有各自的约定,人工操作容易引起误操作，所以我们希望能有一套跨语言的工具能分别生出各自语言的代码和配置。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>现有系统跨语言之间RPC的调用我们采用了gRPC,很自然的想到可以借鉴gRPC Protobuf定义消息体。具体方法就是扩展<code>google.protobuf.MethodOptions</code>定义</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>下面以RabbitMQ为例，在Protobuf文件中定义MQ相关参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">extend google.protobuf.MethodOptions &#123;</span><br><span class="line">    </span><br><span class="line">    // exchange类型: topic direct fanout ,默认: direct</span><br><span class="line">    string routeType = 7010101;</span><br><span class="line"></span><br><span class="line">	// producer 发送到exchange上有效的routekey; 仅topic模式有效</span><br><span class="line">    repeated string routeKey = 7010102;</span><br><span class="line"></span><br><span class="line">    //consumer监听的队列名称，direct模式 该参数无效</span><br><span class="line">    repeated string listener = 7010103;</span><br><span class="line"></span><br><span class="line">   // 延迟队列的延迟时间</span><br><span class="line">   int32 delay = 6010106;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 如果exchange为topic模式，监听队列绑定的routekey必须根据此处定义的routKey定义设置;比如文件定义的routeKey是a.b.c则consumer端绑定到队列的routkey只能是 a.b.c, a.b.<em>, a.</em>, * 其中之一</p>
<h5 id="生产Java代码"><a href="#生产Java代码" class="headerlink" title="生产Java代码"></a>生产Java代码</h5><p>通常在Maven工程中我们使用<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成gRPC的Java代码。现在我们可以扩展<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成MQ的代码。核心扩展点如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Mojo(</span><br><span class="line">        name = &quot;compile-mq&quot;,</span><br><span class="line">        defaultPhase = LifecyclePhase.GENERATE_SOURCES,</span><br><span class="line">        requiresDependencyResolution = ResolutionScope.COMPILE,</span><br><span class="line">        threadSafe = true</span><br><span class="line">)</span><br><span class="line">public class ProtocCompileMQMojo extends AbstractProtocCompileMojo&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</span><br><span class="line">        super.execute();  </span><br><span class="line">        // 利用 DescriptorProtos.FileDescriptorSet 读取proto文件的定义根据规范生出Java文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后配合MQ的SDK可以大大提高开发效率而且减低配置的复杂性。</p>
]]></content>
  </entry>
  <entry>
    <title>海恩法则与生产Bug</title>
    <url>/2019/03/01/product-bug/</url>
    <content><![CDATA[<p><img src="/2019/03/01/product-bug/heinrich-law.jpeg"><br>「海恩法则」是航空涡轮发动机的发明者帕布斯·海恩提出一个在航空界关于飞行安全的法则。海恩指出：每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。法则强调两点：一是事故的发生是量的积累的结果；二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。「海恩法则」虽然针对的是飞行领域，在软件开发领域遭遇生产bug<span id="more"></span>，用「海恩法则」也可以解释。</p>
<p>当生产环境出现bug的时候，通常情况下，我们会很快定位出bug产生的原因具体在哪一行代码上，然后根据实际情况决定回滚或者修复。然而事后总结发现，每一个线上bug的出现绝不仅仅是代码的问题，会涉及到开发、测试和运维多个环节；更多暴露出的是流程的问题，管理的问题，执行力的问题。特别是初创团队和架构大规模升级后最容易暴露出代码以外的问题。以我个人处理过的生产bug，事后分析原因最多的一次有14项措施要么缺失，要么执行不到位，其中与代码相关的只有2项，更多的原因是方案和流程执行不到位。</p>
<p>上线前通常会采取一些措施来保证质量；比如：开发阶段的code review，ut以及测试阶段的压测等；而且会有配套的流程确保必要的步骤都执行到位；然而即便采取多么复杂的流程也不能避免bug的出现。归根结底，代码是人写的，是人就可能出错 ；我们要做的<strong>不是不出bug，而是不出低级bug</strong> 。对于可能出现的低级bug要擅于通过工具发现；诚然，再好的工具和流程也比不上人自身的素质和责任心。</p>
<p>上线后系统会有各种维度的监控确保系统正常运行；在出现生产bug前监控系统通常会有异常表现，比如CPU，内存，IO，线程等指标可能会有同比变化；此时报警策略的精准性和人的责任心就比较重要；发现异常后第一时间根据各项指标分析出异常的根本原因，是正常波动，是受到攻击还是程序bug。特别是新功能或者bug修复后上线要特别注意这些指标。在确认系统出现问题时候后立刻采取相应措施，回滚，扩容，限流，熔断等，避免或者尽可能减少造成的损失 。</p>
<p>其实所有的问题都可以归结为人的问题。最后想到奈飞文化准则的第一条「我们只招成年人」 。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化架构升级实践</title>
    <url>/2019/01/03/servcie-deploy-summary/</url>
    <content><![CDATA[<p>目前我们大部分业务都接入了服务化，在过去将近一年的时间里，我们踩了很多坑，也出现了几次生产事故，同时，从某种意义上讲，我们也做了某些「微创新」，使得架构更适合我们团队的实际情况。从目前的结果来看，基本达成了预定目标； <span id="more"></span></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>在前期技术选型的时候，我们调研了<a href="http://dubbo.apache.org/">Dubbo</a>和<a href="https://spring.io/projects/spring-cloud">Spring Cloud</a>，主要从以下这些方面考虑各自的优缺点；最终选择以<a href="http://dubbo.apache.org/">Dubbo</a>为基础技术框架：</p>
<ol>
<li>社区支持</li>
<li>生态建设</li>
<li>服务治理</li>
<li>服务监控</li>
<li>与现有系统的集成</li>
<li>代码迁移成本</li>
<li>团队的流程</li>
<li>运维成本</li>
<li>团队的经验</li>
<li>学习成本</li>
</ol>
<h3 id="服务化SDK"><a href="#服务化SDK" class="headerlink" title="服务化SDK"></a>服务化SDK</h3><p>考虑到当时<a href="http://dubbo.apache.org/">Dubbo</a>刚开始进入Apache孵化器，也方便我们以后升级；我们提供了封装<a href="http://dubbo.apache.org/">Dubbo</a>的服务化SDK给开发团队使用。我们扩展了如下功能: </p>
<ol>
<li>启动完成标示，单个JVM中确保所有服务启动完成而且在注册中心注册</li>
<li>集成<a href="https://github.com/ctripcorp/apollo">Apollo</a> ，开发团队不用关心基础组件配置信息 </li>
<li>集成监控，保证服务化后项目必须接入监控</li>
<li>集成限流降级系统，确保所有的provider必须接入流降级功能</li>
<li>定向指定服务节点，测试环境中多项目测试的情况下，可以对运行中的服务动态指定provider工作节点 。(我们也注意到官方在2.7版本的tag feature提供了类似的功能)</li>
</ol>
<h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>系统架构服务化后，服务间调用关系错综复杂，出现问题很难定位。所以监控系统极为重要；而且我们一致认为投入生产前必须有全链路监控。为了快速上线，我们在Dubbo官方提供的监控系统<a href="https://dubbo.incubator.apache.org/">dubbo-monitor</a>和<a href="https://zipkin.io/">zipkin</a>基础上做了部分改造：</p>
<ol>
<li>dubbo-monitor官方的方案是将监控数据持久化到磁盘。我们考虑到数据保存到磁盘不方便查询，而且多个节点之间共享磁盘不是一个好的方案。所以，我们将数据持久化到MySql。</li>
<li>配置信息接入<a href="https://github.com/ctripcorp/apollo">Apollo</a> 。</li>
<li>接入我们现有的报警系统；将监控数据实时上报到我们的报警系统 。</li>
<li><a href="https://zipkin.io/">zipkin</a>的链路跟踪信息接入我们的日志系统 </li>
<li>打通全链路监控,从web系统到最后端基础服务调用关系 </li>
</ol>
<h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>我们采用阿里开源的<a href="https://github.com/alibaba/Sentinel">Sentinel</a>作为限流降级组件。<a href="https://github.com/alibaba/Sentinel">Sentinel</a>官方提供了与<a href="http://dubbo.apache.org/">Dubbo</a>集成的适配器，可以最快的速度投入生产使用。但是，由于<a href="https://github.com/alibaba/Sentinel">Sentinel</a>官方默认的限流降级规则是存储在节点内存中的，节点重启后规则会丢失。所以，团队根据官方提供<a href="https://github.com/ctripcorp/apollo">Apollo</a>的Datasource做了少许改造，使得规则可以持久化到<a href="https://github.com/ctripcorp/apollo">Apollo</a> 。</p>
<h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>服务拆分是服务化改造的重点。 通常大家都会根据领域来拆分，而领域的划分可大可小没有一个绝对的标准。拆分太细，服务众多，运维成本较高；拆分太粗发挥不了服务化的优势，因此在服务拆分的时候要根据团队当前的实际情况而定。我们团队在具体执行的过程中采用了领域+上/下层服务的方式拆分。我们各个开发团队的划分就是按照领域划分的，而每个团队都会有底层服务(会提供接口给其它团队)和上层服务(为个自业务服务)；所以，原则上每个团队两个服务，一个底层服务，另一个是上层服务；针对部分关键服务(比如，详情页，订单，支付等..) 有独立的服务 。真正做到独立开发，独立测试，独立发布，独立运维。</p>
<h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>服务化后开发人员的智能发生了变化 :</p>
<ol>
<li>开发团队的处警方式有被动告知转变为主动处理，系统的运行状态不仅仅依赖SA，更多依靠开发团队主动关注，SA更多关注系统级别的指标，开发人员必须关注系统，业务等各种指标；以最快的速度对系统的异常作出响应。</li>
<li>测试任务更多依赖开发人员完成，专职测试人员更多关注自动化和质量。</li>
<li>上线发布不再由SA直接参与，SA负责提供发布/回滚工具，在质量达标后由开发团队独立完成 。</li>
</ol>
<h4 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h4><ol>
<li>效率；之前上线涉及多个团队，依赖Jar包过多，上线过程经常遇到代码冲突，包依赖冲突等问题；排查问题涉及多个团队，耗时长，效率低。服务化后每次上线只涉及自己团队成员，不再有代码冲突和包冲突的问题，效率得到了很大的提升 。</li>
<li>CI/CD流程的建立；我们在服务化推进的过程中同时建立了初步的CI/CD流程 。</li>
<li>自动化测试；服务化后上线频率更高，为了保证质量我们开始建立了自动化测试系统。</li>
</ol>
<h4 id="编码规范增加如下内容"><a href="#编码规范增加如下内容" class="headerlink" title="编码规范增加如下内容:"></a>编码规范增加如下内容:</h4><ul>
<li>事务处理</li>
<li>SQL中多表join</li>
<li>引用的传递 </li>
<li>限流异常的处理</li>
<li>超时异常处理</li>
<li>单元测试规范 </li>
</ul>
<h5 id><a href="#" class="headerlink" title></a></h5><h4 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h4><ol>
<li>流量切换方式；服务化之前我们大部分应用都是web应用；系统发布过程中流量的切换是通过Nginx完成的。服务化后流量切换需要依赖服务发现(我们用<a href="http://zookeeper.apache.org/">Zookeeper</a>作为<a href="http://dubbo.apache.org/">Dubbo</a>服务发现的组件)组件完成；因此我们增加了流量切换组件 。</li>
<li>回滚方式：服务化后系统上线频率变高；同时意味着回滚的频率也会变高。考虑到回滚应用的时候如果需要回滚配置必须手工完成，这样效率并不高。因此，我们根据利用<a href="https://github.com/ctripcorp/apollo">Apollo</a>的OpenAPI真正做到了一键回滚。</li>
</ol>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>接下来，我们会聚焦如下方面：</p>
<ul>
<li>分库分表</li>
<li>前/中台战略</li>
<li>容器化</li>
<li>自动化测试的加强</li>
<li>监控系统的加强，缩短问题排查的时间</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>给出一个「可落地的方案」能真正体现一个架构师实力；架构师遇到的很多问题都不是技术问题，只是用技术手段解决业务问题，流程问题，质量问题。架构师给出的每一个方案，必须立足于团队的实际情况，实际情况包括但不限于：成本，时间，团队能力，等。而且时刻关注执行结果；如果没有到达预期效果或者在执行过程中偏离方向，尽快根据团队实际情况调整方案。总之，所有的方案都是冲着三个目标 <strong>效率</strong>，<strong>质量</strong>，<strong>成本</strong> 。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器自动配置shadowsocks</title>
    <url>/2019/01/20/shadowsocks-auto-config/</url>
    <content><![CDATA[<p>最近几个朋友买了vps后让我帮忙配置shadowsocks ;于是我写了一个小工具在CentOS上完成shadowsocks的自动配置 .<span id="more"></span></p>
<ol>
<li><p>购买VPS, 这个根据自己的需要选购合适的VPS厂商购买即可, 操作系统选择CentOS 。</p>
</li>
<li><p>以root身份登陆系统 。</p>
</li>
<li><p>执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://www.yzhu.name/tools/install_shadowsocks.sh -s --output install_shadowsocks.sh  &amp;&amp; chmod +x install_shadowsocks.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install_shadowsocks.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>看到如下提示，可以输入端口号或者直接回车采用默认端口号:8388</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input server port [8388]</span><br></pre></td></tr></table></figure></li>
<li><p> 看到如下提示，输入密码,默认密码是:123456 ；<strong>强烈建议此处输入密码</strong>。</p>
</li>
</ul>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input server password [123456]</span><br></pre></td></tr></table></figure>

<p>   至此如果没有出错，服务端自动配置已完成 。</p>
<ol start="4">
<li><p>客户端配置</p>
<p>从<a href="https://shadowsocks.org/en/download/clients.html">官网</a> 下载适合自己操作系统的客户端安装，按照下图所示配置:</p>
<p><img src="/2019/01/20/shadowsocks-auto-config/client_cfg.png" alt="客户端配置"></p>
</li>
<li><p>访问<a href="https://www.google.com/">google</a></p>
<p><img src="/2019/01/20/shadowsocks-auto-config/google.png" alt="google"></p>
</li>
</ol>
<p>至此整个配置结束。</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：寂静之城 -- 马伯庸</title>
    <url>/2020/09/05/The-Silence-City/</url>
    <content><![CDATA[<p>转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻<span id="more"></span></p>
<blockquote>
<p>And in the naked light I saw ten thousand people, maybe more. People tal<br>king without speaking, people hearing without listening. People writing<br>songs that voices never shared, no one dared disturb the sound of silenc<br>e. 　　　　　　　　　　　　　　　 — The sound of silence 　美利坚合众国，2015年，纽约。</p>
<p>　　当电话响起来的时候，阿瓦登正趴在电脑前面睡觉。电话铃声十分急促，尖锐<br>，每一次振动都让他的耳膜难受好久。他揉了揉干涩的眼睛，十分不情愿地爬起来<br>，觉得脑子沉滞无比。<br>　　其实他的脑子一直就很沉滞，这种感受既然是生理上的也是心理上的。他身处<br>的房间很狭窄，空气不很好，唯一的两扇窗户紧闭着——即使打开窗户也没用，外<br>面的空气更加浑浊。这是一间大约只有三十平米的小屋子，屋子墙壁上泛黄的墙纸<br>有好几处开始剥落，天花板上的水渍渗成奇怪的形状；一张老式的军绿色行军床摆<br>在墙角，床腿用白漆写着编号；紧挨着行军床的是一张三合板制成的电脑桌，桌上<br>摆着一台浅白色的电脑，机箱后面五颜六色的电线纠缠在一起，把它们自己打成一<br>个古怪的死结，杂乱无章地蔓延到地板与墙角，仿佛常春藤一样。</p>
<p>　　阿瓦登走到电话前，慢慢坐到地板上，目光呆滞地盯着电话，手却没有动。这<br>部古怪的东西是老式的按键式电话，大概是十几年前的款式，这是阿瓦登有一次去<br>费城出差时偶尔在一家杂货店里买到的；他拿回家以后稍微修理了一下，发现居然<br>还能用，这让他当时小小地兴奋了一阵子。<br>　　电话继续在响着，已经是第七声。阿瓦登意识到自己不得不去接听了。于是他<br>弓下腰，用两个指头拈起电话，慢慢把电话放到耳边。<br>　　“请说出你的网络编号？”话筒里传来的声音并不急噪，事实上它也不带其他<br>任何的感情色彩，因为这是电脑合成的人工智能语音系统。<br>“19842015”<br>　　阿瓦登熟练地报出一连串数字，同时开始觉得胸有些更闷了。说实话他并不喜<br>欢这些空洞的电子声音， 他有时候想，假如打过电话来的是一位声音圆润的女性该<br>多好。阿瓦登知道这是一种不切实际的幻想，不过这幻想会让他的身体得到几秒钟<br>的舒缓。</p>
<p>　　话筒里的声音仍旧在继续着。</p>
<p>　　“关于你在十月四日提交的网络论坛用户注册申请已经被受理，经有关部门审<br>查后确认资格无误，请在三日内持本人身份证件、网络使用许可证及相关文件前往<br>办理登记手续，并领取用户名及密码。”</p>
<p>　　“知道了，谢谢。”</p>
<p>　　阿瓦登谨慎地选择词语，同时努力挤出一副满足的微笑，好象话筒的另一侧有<br>人在看着自己一样。放下电话，阿瓦登先是茫然地盯着它看了大约两分钟，然后站<br>起来活动一下手腕，坐回到电脑前面，缓慢地推动了一下鼠标。</p>
<p>　　</p>
<p>　　电脑屏幕“啪”地一声亮了起来，显示出一个登陆的界面，还有一行英文：“<br>请输入你的网络编号和姓名。”阿瓦登将那八位数字敲进去，又输入了自己的名字<br>，点击“登陆”。随即机箱的指示灯开始频繁地闪动起来，整个机器发出细微的噪<br>音。</p>
<p>　　每一个使用互联网的人都有一个网络编号，没有这个编号，就无法连接进互联<br>网络。每一个编号都是独一无二的，每个人只有一个；这是使用者在网上的唯一代<br>号，既不能修改，也不能取消。这些编号分别对应着使用者身份证上的名字，因此<br>19842015就是阿瓦登，阿瓦登就是19842015。阿瓦登知道有些记忆力不好的人会把<br>自己的编号印在衣服的后面，那看起来颇为滑稽，也容易引发一些不正当的联想。</p>
<p>　　有关部门说使用网络实名制是为了规范网络秩序方便管理，杜绝因匿名使用网<br>络而产生的一系列重大问题和混乱。阿瓦登不太清楚那一系列重大问题会是什么，<br>他自己没试过用假名上网，他所认识的任何人里也不曾有人尝试过——事实上，从<br>技术角度来说，他根本没办法匿名登陆互联网络，没有编号就没有权限上网，而编<br>号则连接着他的详细档案，换句话说，没人能在网上隐藏自己。有关部门把这一切<br>都考虑的很周详。</p>
<p>　　“有关部门”，这是一个语意模糊、但却有着权威与震慑力的词组。它既是泛<br>指，又是确指，其所涵盖的意义相当广泛。有时候，它指的是为阿瓦登颁发网络编<br>号的美国联邦网络管理委员会；有时候它是将最新通告及法规发到阿瓦登EMAIL信箱<br>的服务器；还有时候它是监察网络的FBI特属网络调查科；总之一句话，有关部门是<br>无处不在，无职不司的，总会在适当的时候出现，给予指导、监控或者警告，无论<br>你是在网上还是网下。</p>
<p>　　简直就象是老大哥一样无微不至。</p>
<p>　　电脑仍旧在持续运转着，阿瓦登知道这得花上一阵子。这台电脑是有关部门配<br>发给他的，具体型号和配置阿瓦登并不清楚，机箱是被焊死的，无法打开。于是他<br>拿出一小瓶清凉油，用右手小拇指的指甲挑出一点抹在自己的太阳穴，然后从脚下<br>堆积如山的杂物里翻出一个塑料杯子，从桌子旁的饮水机里接了半杯蒸馏水，就着<br>一片镇痛片一饮而尽。蒸馏水穿过喉咙和狭长的食道滑进胃里，空泛的味道让他有<br>些恶心。</p>
<p>　　音响里忽然传来一阵美国国歌的旋律，阿瓦登放下杯子，重新把目光投到电脑<br>上去。这是已经连入互联网络的标志。屏幕上首先跳出来的是有关部门的通告，白<br>底黑色四号字，里面陈述了使用互联网的意义以及最新的规章制度。</p>
<p>　　“缔造健康的互联网络，美国万岁！”</p>
<p>　　音响里传来激昂的男性呼声，阿瓦登不大情愿地跟着大声念了一遍。“缔造健<br>康的互联网络，美国万岁！”</p>
<p>　　这段呼号持续了三十秒钟，然后消失，取而代之的是写着“缔造健康的互联网<br>络”标语的桌面背景。另外一个窗口慢慢浮上开，上面开列出几个选项：工作、娱<br>乐、电子信箱和BBS论坛。其中BBS选项呈现灰色，说明这项功能还没有开通。</p>
<p>　　整个操作系统简洁明了，这台电脑的浏览器没有地址输入栏，只是在收藏夹里<br>有几个无法修改的的网站地址。理由很简单，这些网站都是健康向上的，假如其他<br>站点和这些网站一样，那么只保留这些网站就够了；假如其他站点与这些网站不一<br>样，那么就是不健康的，是低级趣味，不能保留。这是有关部门精心设计的，是为<br>了公民的精神健康着想，生怕他们受到不良信息的侵染。</p>
<p>　　阿瓦登首先点开了“工作”，一连串和他工作相关的站点列表与相关软件在电<br>脑上显示出来。阿瓦登是一名程序员，他每天的工作就是根据上级的要求编写程序<br>。这份工作很无聊，不过可以保证他有稳定的收入。他不知道自己的源代码会被用<br>到哪里去，上级也从来没有跟他说过。 　　他打算继续昨天的工作，但是很快发现<br>自己很难继续下去。阿瓦登觉得今天的情绪比以前要烦躁，无法集中精神，大脑还<br>是很呆滞，胸口仍旧发闷。他试图娱乐自己，但是他发现“娱乐”选项里只有纸牌<br>与挖地雷，根据有关部门的说法，这是两个健康的游戏，没有暴力，没有色情，不<br>会让人产生犯罪冲动，也不涉及任何政治色彩。据说美国境外也是有互联网络站点<br>的，不过无法连上去，因为本国的互联网络自成格局，独立自主，普通人无法直接<br>连接到国外——IE浏览器没有地址栏，就算知道地址也没有用处。</p>
<p>　　“您有一封新邮件。”</p>
<p>　　系统忽然跳出来提示，阿瓦登终于找到了可以暂停工作的理由，他很快移动鼠<br>标到电子信箱的选项上，点开，很快一个新的界面出现了。</p>
<p>　　“To: 19842015</p>
<p>　　From：10045687</p>
<p>　　Subject: 模块、已经、完成、当前、项目、是否、开始。”</p>
<p>　　阿瓦登微微地叹了一口气，觉得有些失望。每一次他收到新的电子邮件，都希<br>望能够有一次新鲜的刺激来撞击他日益迟钝的脑神经，每一次他都失望了。其实他<br>早就知道这一点，只不过他觉得保持期待至少能够享受到几秒钟快感。就好象他期<br>待着打电话过来的是一个圆润温柔的女性声音一样。不给自己一些渺茫的希望，阿<br>瓦登觉得自己迟早会疯掉的。</p>
<p>　　这封信很简短，但是内容很充实。19842015是阿瓦登的网络编号，而10045687<br>则是他的一位同事的编号，这种工作性质的信件通常都以编号相称。信的内容是几<br>个不连续的英文单词，这是有关部门所提倡的一种电子邮件书写方式，因为这样可<br>以方便软件检查信件中是否含有敏感词汇。</p>
<p>　　阿瓦登打开回信的页面，同时另开了一个窗口，打开一份名字叫做“网络健康<br>语言词汇列表”的TXT文档。这是有关部门要求每一位网民所必须使用的词汇。当他<br>们书写电子邮件或者使用论坛服务的时候，都得从这个词汇列表中寻找适合的名词<br>、形容词、副词或者动词来表达自己想要说的话。一旦过滤软件发现网民使用了列<br>表以外的词，那么这个词就会被自动屏蔽，取而代之的是“请使用健康语言”。</p>
<p>　　“屏蔽”是个专有名词，被屏蔽的词将不允许再度被使用，无论是在书信里还<br>是口头都不允许。讽刺的是，“屏蔽”一词本身也是被屏蔽的词汇之一。</p>
<p>　　这个列表是经常更新的，每一次更新都会有几个词在列表上消失，于是阿瓦登<br>不得不费劲脑汁寻找其他词语来代替那个被屏蔽掉的词语或者单字。比如在以前，<br>“运动”这个词是可以使用的，但后来有关部门宣布这也是一个敏感词汇，阿瓦登<br>只好使用“质点位移”来表达相同的意思。</p>
<p>　　他对照着这份列表，很快就完成了一封文字风格与来信差不多的EMAIL——健康<br>词汇表迫使人们不得不用最短的话来表达最多意思，而且要尽量减少不必要的修辞<br>，所以这些信件就好象是那杯蒸馏水一样，淡而无味，阿瓦登有时候想，他早晚也<br>会和这些水和信一样腐烂，因为这些信是他写的，水是他喝的。</p>
<p>　　接下来阿瓦登启动检查软件先扫了一遍，确保自己没无意中加入什么敏感词汇<br>。等这一切都完成后，他按下了发送键，邮件被送出去了。</p>
<p>　　阿瓦登没有留下备份，因为他的机器里没有硬盘，也没有软驱、光驱或者USB接<br>口。这个时代宽带技术已经得到了很大发展，应用软件可以集中在统一的一个服务<br>器中，个人用户调用时的速度丝毫不会觉得迟滞。因此个人不需要硬盘，也不需要<br>本地存储，他们在自己电脑里写的每一份文档、每一段程序、甚至每一个动作都会<br>被自动传送到有关部门的公共服务器中，这样便于管理。换句话说，阿瓦登所使用<br>的电脑，仅仅具备输入和输出两种功能。</p>
<p>　　完成了这封信后，阿瓦登再度陷入了软绵绵的焦躁状态，这是一个连续工作了<br>三天的程序员的正常反应。这种情绪很危险，因为它让人效率低下精神低迷，而且<br>没有渠道发泄。“疲劳”、“烦躁”以及其他负面词汇都属于危险词汇，如果他写<br>信给别人抱怨的话，那么对方收到的将会是一封写满“请使用健康语言”的EMAIL。</p>
<p>　　这就是阿瓦登每天的生活，今天比昨天更糟糕，但应该比明天还稍微好一点。<br>事实上这个叙述也很模糊，因为阿瓦登自己并不清楚什么是“好一点”，什么是“<br>更糟糕”。“好”与“坏”是两个变量，而他的生活就是一个定量，只有一个常数<br>叫“压抑”。</p>
<p>　　阿瓦登推开鼠标，把脑袋向后仰去，长长地呼了一口气。（至少“呼”这个字<br>还没有被屏蔽）这是空虚的表现，他想哼些歌，但却又不记得什么，转而吹了几下<br>口哨，但那听起来与一只生了肺结核的狗差不多，只得做罢。有关部门象幽灵一样<br>充斥在整个房间里，让他无法舒展自己的烦闷。就好象一个人在泥沼里挣扎，刚一<br>张口就被灌入泥水，甚至无法大声呼救。</p>
<p>　　他的头不安分地转了几转，眼神偶尔撇到了摆在地板上的老式电话机，他忽然<br>想到还必须要去有关部门申请自己的BBS论坛浏览许可证。于是他关掉“工作”和“<br>电子邮件”窗口，退出了网络登陆。阿瓦登在做这些事的时候毫不犹豫，他很高兴<br>能够暂时摆脱互联网络，在那上面他只是一串枯燥的数字和一些“健康词汇”的综<br>合体。</p>
<p>　　阿瓦登找出一件破旧的黑色呢子大衣，那件大衣继承自他的父亲，袖口和领子<br>已经磨损的很严重，个别地方有灰色的棉花露出来，但还是很耐寒。他把大衣套到<br>身上，戴上一副墨绿色的护镜，用过滤口罩捂住嘴。他犹豫了一下，拿起“旁听者<br>”别在耳朵上，然后走出家门去。</p>
<p>　　纽约的街上人很少，在这个时代，互联网的普及率相当地高，大部分事务在网<br>上就可以解决，有关部门并不提倡太多的户外活动。太多的户外活动会导致和其他<br>人发生物理接触，而两个人发生物理接触后会发生什么事则很难控制。</p>
<p>　　“旁听者”就是为了防止这种事而发生的，这是一种便携式的语言过滤器，当<br>携带者说出敏感词汇的时候，它就会自动发出警报。每一位公民外出前都必须要携<br>带这个装置，以便随时检讨自己的言语。当人们意识到旁听者存在的时候，他们往<br>往会选择沉默，至少阿瓦登是如此。有关部门正逐步试图让网络和现实生活统一起<br>来，一起“健康”。</p>
<p>　　这时候正是11月份，寒风凛冽，天空漂浮着令人压抑的铅灰阴云，街道两旁的<br>电线杆仿佛落光了叶子的枯树，行人们都把自己包裹在黑色或灰色的大衣里面，浓<br>缩成空旷街道上的一个个黑点飞快移动着。一层若有若无的烟雾将整个纽约笼罩起<br>来，不用过滤口罩在这样的空气里呼吸将会是一件很有挑战的事情。</p>
<p>　　距离上一次离开家门已经有两个月了吧，阿瓦登站在公共汽车站的站牌下，不<br>无感慨地想，周围的一切看起来很陌生，泛黄，而且干燥。那是上一次沙尘暴的痕<br>迹。不过沙尘暴这个词也已经被屏蔽了，因此阿瓦登的脑海里只是闪过那么一下，<br>思想很快就转移到别的事情上去了。</p>
<p>　　站在阿瓦登旁边的是一个穿着蓝色制服的高个男人。他先是狐疑地看了阿瓦登<br>一眼，看到后者沉默地沉在黑色大衣里，他的两只脚交替移动，缓慢地凑了过去，<br>装做漫不经心对阿瓦登说：</p>
<p>　　“烟，有吗？”</p>
<p>　　男人说，每一个字都说的很清晰，而且词与词之间间隔也足够长。这“旁听者<br>”还没有精密到能够完全捕捉到每一个人语速和语调的程度，因此有关部门要求每<br>一位公民都要保持这种说话风格，以方面检测发言人是否使用了规定以外的词汇。</p>
<p>　　阿瓦登转过头去，看了他一眼，舔舔自己干裂的嘴唇，回答说：</p>
<p>　　“没有。”</p>
<p>　　男人很失望，又一次不甘心地张开嘴。</p>
<p>　　“酒，有吗？”</p>
<p>　　“没有。”</p>
<p>　　阿瓦登又重复了一次这个词，他也已经很久没有收到烟和酒了，也许是缺货的<br>关系吧，这是常有的事。不过有一点很奇怪，“旁观者”这一次却没有发出警报。<br>以阿瓦登的经验，以往一旦烟、酒或者其他生活必需品发生短缺现象，这个词就会<br>暂时成为被屏蔽掉的敏感词汇，直到恢复供给为止。</p>
<p>　　这个男人看起来很疲惫，红肿的眼睛是这个时代的人们普遍的特征，这是长时<br>间挂在网上的关系。他的头发蓬乱，嘴边还留着青色的胡子碴，制服下的衬衣领口<br>散发着刺鼻的霉味。能看的出，他也很久不曾到街上来了。</p>
<p>　　阿瓦登这时候才注意到，他的耳朵上空荡荡的，没有挂着那个银灰色的小玩意<br>“旁听者”，这实在是一件严重的事情。不携带“旁听者”外出，就意味着语言不<br>会再被过滤，一些不健康的思想和言论就有可能孳生，因此有关部门相当严厉地规<br>定公民上街必须携带旁听者。而这个男人的耳朵旁却什么也没有。阿瓦登暗暗吃惊<br>，一时间不知道是该去提醒还是装做没看到。他暗自想，也许向有关部门举报会更<br>好。</p>
<p>　　这时候那个男人又朝他靠近了一点，眼神变的饥渴起来。阿瓦登心里一阵紧张<br>，下意识地向后退去。这难道是一次抢劫？还是说他是个压抑太久的同性恋者？那<br>个男人忽然扯住他的袖子，阿瓦登狼狈地挣扎却没有挣开。出乎他的意料，那个男<br>人并没有进一步的动作，而是大吼一声，用一种阿瓦登已经不太习惯了的飞快语速<br>向他倾泻起话语来。阿瓦登被这突如其来的爆发弄的莫名其妙，不知所措。</p>
<p>　　“我只是想和你多几句话，就几句，我很久没有说过话了。我叫斯多葛，今年<br>三十二岁，记得，是三十二岁。我一直梦想有一套在湖边的房子，有一副钓鱼竿和<br>一条小艇；我讨厌网络，打倒网管；我妻子是个可恶的网络中毒者，她只会用枯燥<br>乏味的话叫我的网络编号；这个城市就是一个大疯人院，里面大疯子管着小疯子，<br>并且把所有没疯的人变的和他们同样疯狂；敏感词汇都去他X的，老子受够了……”</p>
<p>　　男人的话仿佛一瓶摇晃了很久然后突然打开的罐装碳酸饮料，迅猛，爆裂，而<br>且全无条理。阿瓦登惊愕地望着这个突然狂躁起来的家伙，却不知道如何应对；更<br>可怕的是，他发现自己居然对他产生了一点同情，那种“同病相怜”式的同情。男<br>人的话这时候已经从唠叨变成了纯粹谩骂，全部都是最直抒胸臆的那种。阿瓦登已<br>经有五、六年不曾说过这些脏话，最后一次听到这些也是四年前。有关部门认为这<br>都有碍精神文明，于是全部都屏蔽掉了。</p>
<p>　　而现在这个男人就在公众场合对着他大吵大嚷，似乎要将被屏蔽掉的敏感词汇<br>一口气全倒出来。他的目光和手势并不针对任何人，甚至也不针对阿瓦登，更象是<br>在一个人在自说自话。阿瓦登的耳膜似乎不习惯这种分贝，开始有些隐隐做痛，他<br>捂着耳朵，拿不定主意是干脆逃掉还是……这时候，远处街道出现两辆警车，一路<br>闪着警灯直直冲着这座公共汽车站而来。</p>
<p>　　警车开到站台旁时，男人仍旧在痛骂着。警车门开了，涌出了五、六名全副武<br>装的联邦警察。他们扑过去将那个男子按在地上，用橡皮棍痛打。男人两条腿挣扎<br>着，嘴里的语速更快了，骂出来的话也越来越难听。其中一名警察掏出一卷胶带，<br>“嚓”地一声扯下一条向男人的嘴贴去。男人在嘴被胶带封住之前，突然提高嗓门<br>，冲着警察痛快无比地喊了一句：“FUXKYOU, YOUSONOFBITCH！”阿瓦登看到他的<br>表情由疯狂变成享受，面带着微笑，似乎完全陶醉在那一句话所带来的无上快感和<br>解脱感中。</p>
<p>　　联邦警察们七手八脚地将男人送进了警车，这时才有一名警察走到了阿瓦登的<br>跟前。</p>
<p>　　“他，是，你朋友？”</p>
<p>　　“我，不，认识。”</p>
<p>　　警察盯了他一阵，取下他耳朵上的“旁观者”查看记录，发现他并没有提及任<br>何敏感词汇，于是重新给他戴回去，警告他说那名男子说的全部都是极度反动的词<br>汇，要求他立刻忘掉，然后转身押着那男子离开了。</p>
<p>　　阿瓦登松了一口气，其实刚才他有一瞬间涌现出一种冲动，也想在这空旷的街<br>道上大喊一声“FUXKYOU, YOUSONOFBITCH”那一定很爽快，他心里想，因为那男子<br>说出这句话的时候表情很享受。不过他也知道，这也是妄想的一种，“旁观者”紧<br>帖在耳朵上的冰凉感觉时刻提醒着他。 　　街上很快就恢复了冷清，十分钟后，一<br>辆公共汽车慢吞吞地开进站里，锈迹斑斑的车门哗啦一声打开，一个电子女声响彻<br>整个空荡荡的车厢：“请乘客注意文明用语，严格按照健康词汇发言。”</p>
<p>　　阿瓦登把自己缩进大衣，压抑住自己异样的兴奋，决定继续保持沉默下去。</p>
<p>　　大约过了一个小时，公共汽车到了目的地。从破碎的车窗玻璃里吹进来的寒风<br>让阿瓦登脸上挂起一层暗灰色的霜气，面部被风中的沙砾和煤渣刮的生疼。他听到<br>电子女声报出了站名，就站起身来，象一条狗一样抖抖身上的土，走下车去。</p>
<p>　　车站对面就是阿瓦登要去的地方，那是有关部门负责受理BBS论坛申请的网络部<br>。这是一间五层的大楼，正方形，全水泥混凝土结构，外表泛灰。如果没有那几个<br>窗户的话，那么它的外貌将与水泥块没有任何区别：生硬、死气沉沉，让蚊子和蝙<br>蝠都退避三舍。</p>
<p>　　BBS论坛是一种奇特的东西，从理论上来讲它完全多余，BBS的功能完全可以由<br>EMAIL新闻组来取代，后者更容易管理和审查。而且申请使用BBS论坛资格不是件容<br>易的事，申请人必须要通过十几道手续和漫长的审查才能有浏览资格，浏览资格三<br>个月才会被允许在指定论坛发布帖子，至于自己开设BBS则几乎是不可能。</p>
<p>　　因此真正对BBS有兴趣的人少之有少。阿瓦登当初之所以决定申请BBS论坛资格<br>，纯粹是因为他那种模糊但却顽强的怀旧心态，就好象他从杂货店里买的那部老式<br>电话一样。他也不知道自己为什么会自找麻烦，也许是为了给生活带来些刺激，还<br>是说为了强调自己和曾经旧时代的那么一点点联系，也许两者兼有之。</p>
<p>　　阿瓦登恍惚记得在他小的时候，互联网与现在并不太一样。并不是指技术上的<br>不同，而是一种人文的感觉。他希望能通过使用BBS论坛回想起一些当年的事情。</p>
<p>　　阿瓦登走进网络部的大楼，大楼里和外面一样寒冷，而且阴森。走廊里没有路<br>灯，蓝白色调的两侧墙壁贴满了千篇一律的网络规章条文与标语，冰冷的空气呼吸<br>到肺里，让阿瓦登一阵痉挛。只有走廊尽头的小门缝隙里流泻出一丝光亮，小门的<br>上面挂着一块牌子，上面写的是“网络部BBS论坛科。”</p>
<p>　　一走进这间屋子，阿瓦登立刻感觉到一阵温洋洋的热气。屋子里的暖气（或者<br>是空调）开的很大，让阿瓦登冻麻了的手脚和脸麻酥酥的，有些发痒，他不禁想伸<br>出手去挠挠。</p>
<p>　　“公民，请您站在原地不要动。”</p>
<p>　　一个电子女声忽然从天花板上的喇叭里传来，阿瓦登触电似地把手放下，恭敬<br>地站在原地不同。他借这个机会观察了一下这间屋子。这屋子准确来说应该是一个<br>狭长形的大厅，一道拔地而起的大理石柜台象长城一样将房间割裂成两部分，柜台<br>上还装着一排银白色的圆柱形栅栏，直接连到天花板。屋子里没有任何装饰，没有<br>观赏植物，没有塑料鲜花，甚至没有长椅和饮水机。</p>
<p>　　“缔造健康的互联网络，美国万岁。”</p>
<p>　　阿瓦登跟着声音重复了一遍。</p>
<p>　　“请前往八号窗口。”</p>
<p>　　电子女声的语调很流畅，因为这是电脑制作出来的，因此没有敏感词汇的限制<br>。</p>
<p>　　阿瓦登转头看到在自己右手边的不远处，大理石柜台上的液晶屏幕显示着八号<br>的字样。他走过去，拼命抬起头，因为柜台实在太高了，他只能勉强看到边缘，而<br>无法看到柜台另一侧的情形。不过他能听到，一个人走到柜台对面，坐下去，并有<br>翻动纸张与敲击键盘的声音。</p>
<p>　　“请把文件放入盒子里。”</p>
<p>　　柜台上的喇叭传来命令。出乎意料，这一次在喇叭里的声音却变了。虽然同样<br>冷漠枯燥，但阿瓦登还是能分辨出它与电子女声的不同——这是一个真正的女性的<br>声音。他惊讶地抬头望去，却什么都看不到，柜台太高了。</p>
<p>　　“请把文件放入盒子里。”</p>
<p>　　声音又重复了一次，语气里带着一丝烦躁，似乎对阿瓦登的迟钝很不满。</p>
<p>　　“是的，这是真正的女声……”阿瓦登想，电子女声永远是彬彬有礼不带任何<br>感情色彩的。他把相关的电子身份证、网络许可证、网络编号和敏感词汇犯罪记录<br>等一系列个人资料卡片一起放进柜台外的一个小金属盒子里，然后把盒子插进柜台<br>上一个同样大小的凹槽中，关好门。 很快他听到“唰”的一声，他猜测这也许是对<br>面的人——也许是个女人——将盒子抽出去的声音。</p>
<p>　　“你申请BBS服务的目的是什么？”</p>
<p>　　</p>
<p>　　喇叭后的女声浸满了纯粹事务性的腔调。</p>
<p>　　“为了、提高、互联网络、工作效率、为了、缔造、一个、健康、的网络、环<br>境，更好地、为、祖国、做出、贡献。”</p>
<p>　　阿瓦登一字一句地回答，心里知道这只是一道官方程序，只需要按标准回答就<br>可以。</p>
<p>　　对面很快就陷入沉默，大约过了十五分钟，喇叭再度响起。</p>
<p>　　“最后手续确认，你已经获得BBS论坛浏览权。”</p>
<p>　　“谢谢。”</p>
<p>　　“砰”的一声，金属盒子从柜子里弹了出来，里面除了阿瓦登的证件以外还多<br>了五张小尺寸光盘。</p>
<p>　　“这是有关部门核发给你的BBS论坛统一用户名与密码，BBS论坛列表、互联网<br>BBS论坛使用指南及相应法规、以及最新健康网络词汇列表。”</p>
<p>　　阿瓦登向前踏了一步，从盒子里将这些东西一股脑全拿出来，揣进大衣的大兜<br>里。那些东西其实是可以全部放在同一张光盘里的，不过有关部门认为每一张光盘<br>装一份文件有助于用户理解这些文件的严肃性和重要性，并产生敬畏。</p>
<p>　　他心里盼望着那个喇叭能再说两句。让他失望的是，对面传来的是一个人起身<br>并且离开的声音，从脚步声的韵律判断，阿瓦登愈发相信这是一名女性。</p>
<p>　　“手续办理完毕，请离开网络部回到自己的工作岗位上。”</p>
<p>　　甜美空洞的电子女声从天花板上传来，阿瓦登厌恶地抽动鼻翼，拿手揉了揉，<br>转身离开这间温暖的大厅，重新进入到寒冷的走廊。</p>
<p>　　在回家的路上，阿瓦登蜷缩在公共汽车上一动不动，顺利申请到BBS的使用权让<br>他有些虚无缥缈的兴奋。他闭着眼睛，找了一个合适的角度躲开破窗而入的寒风，<br>右手在兜里不断摩挲那一系列光盘，还在怀念着那一个神秘的女声。</p>
<p>　　如果能再一次听到该多好，他不能抑制自己这样的想法，同时用拇指的指肚在<br>光盘上轻轻地摩擦，幻想这几张光盘也曾经被她的手触摸过。他兴奋的几乎也想破<br>口大骂一句“FUXKYOU, YOUSONOFBITCH”，真奇怪，那名男子的骂声在他的记忆里<br>根深蒂固，并时不时不自觉地滑到唇边。</p>
<p>　　忽然，他的手指在光盘上发觉到一丝异常的感觉。阿瓦登下意识地朝四周望去<br>，确认周围一个乘客也没有后，他小心翼翼地把光盘全拿出来，就着窗外的光亮仔<br>细端详。</p>
<p>　　阿瓦登很快注意到，在装有BBS论坛列表的光盘背面，被人用指甲轻轻地划了一<br>道刮痕。这条刮痕很轻，如果不是阿瓦登仔细地抚摩光盘的话，是很难发觉到的。<br>这条刮痕很奇特，是一条直线，而在这条直线末端的不远处，则是另外一条极短的<br>刮痕，似乎刻意想弯成一个圆点。整体看上去就好象是一个叹号，或者倒过来说，<br>象是字母i。</p>
<p>　　很快他在其他四张光盘上也发现了类似的刮痕，它们造型都不同，但都似乎代<br>表着某种符号。阿瓦登回想起喇叭里那个女声最后一句提到过的文件顺序，于是把<br>这五张光盘按照BBS论坛统一用户名与密码、BBS论坛列表、互联网BBS论坛使用指南<br>、相应法规、以及最新健康网络词汇列表的顺序排列好，接着依次把那五道刮痕用<br>手指临摹到汽车窗户上。很快那些刮痕构成了一个英文单词：</p>
<p>　　title</p>
<p>　　题目？这是什么意思？</p>
<p>　　阿瓦登看着这个单词莫名其妙，这究竟是纯属无意的痕迹，还是有人刻意为之<br>？如果是有人刻意为之，他这么做的用意是什么？</p>
<p>　　这时候汽车停住了，又有几名乘客走上车来。阿瓦登挪动一下身体，不让他们<br>看到自己在车窗上写出来的字迹，然后装做打呵欠的样子抬起袖子，轻轻把那五个<br>字母擦掉。</p>
<p>　　阿瓦登暗自庆幸，如果他没有在现在发现这些光盘上的痕迹，那么以后就永远<br>没有机会发觉了。按照规定，个人电脑是不允许使用任何存储存设备的，因此阿瓦<br>登的电脑并没有光驱。他下一步所要做的是将这些光盘送交到管区网络安全部，由<br>他们将光盘内资料登陆到服务器中，再转发给阿瓦登。这是为了防止个人私自在家<br>里制造、阅读或者传播黄色或者反动信息，网络安全部发出的通告是这么解释的。<br>联邦的网络警察经常会突入到个人家中进行临时检查，看用户是否非法拥有信息贮<br>存设备，阿瓦登曾经亲眼见过一个邻居被警察带走，原因仅仅是因为他私自藏了一<br>张光盘在家里——其实他只是打算拿那个当茶杯垫用。那个邻居再没回来过。</p>
<p>　　无论这些符号代表的是什么意思，它都是一种全新的体验，这让阿瓦登感觉到<br>兴奋。怀旧与渴望新奇是阿瓦登生活在这个时代的两根精神支柱，否则他会与这座<br>城市一样变的僵硬，然后窒息而死。</p>
<p>　　他先来到网络安全分部，将光盘交给那里的负责人，负责人反复地检查光盘和<br>阿瓦登的表情，好象所有使用BBS论坛的人都不可信赖一样。末了负责人终于找不到<br>什么破绽，只得将光盘收下，然后举起右手，阿瓦登和他一起高呼“缔造健康的互<br>联网络”。这句话是唯一被允许可以连贯着被说出来的句子。</p>
<p>　　回到家里，阿瓦登脱掉大衣，摘了过滤口罩，将旁观者扔到了行军床上，然后<br>整个人也倒进枕头里。每次出去外面都会让他疲劳，这一半是因为他孱弱的肉体已<br>经不大适合室外活动；另外一半原因是因为他必须花费大量的精力来应付旁观者。</p>
<p>　　过了四十分钟，他才悠悠地醒过来，头还是和平常一样地疼，胸口还是一如既<br>往地闷。胡乱吃了一点东西以后，阿瓦登爬到电脑桌前，打开电脑，按程序登陆上<br>网络，习惯性地先检查了一遍信箱。</p>
<p>　　信箱里有七、八封新的信件，其中两封是同事发来的事务信。另外五封则是网<br>络安全部发给他的，内容就是他送交的那几张光盘。</p>
<p>　　阿瓦登打开了包含有BBS论坛的用户名、密码和BBS论坛列表的两封信。他看到<br>自己的论坛通用用户名叫做19842015，和自己的网络编号完全一样，不由得有些失<br>望。他依稀记得在小的时候，BBS论坛的用户名是可以自己决定的，而且每一个论坛<br>都可以不同，一个人在网上并不单只是一串枯燥数字。</p>
<p>　　小时候的记忆往往是跟童话和幻想混杂在一起，未必与实际相符。现实中你只<br>能使用有关部门指定的用户名和密码，理由很简单，用户名和密码内也可能含有敏<br>感词汇。</p>
<p>　　阿瓦登又打开了那份BBS列表，全部都是有关部门开设的官方论坛，没有私人的<br>——事实上个人能够合法持有的电脑设备从技术上来说也无法架设新BBS——这些论<br>坛的主题各有侧重点不同，但基本上是围绕着如何更好响应国家号召，缔造健康互<br>联网络来说的。比如其中一个电脑技术论坛，主题就是如何更好地屏蔽掉敏感词汇<br>。</p>
<p>　　居然在这些论坛中还有一个是关于游戏的。里面正在讨论的是一个如何帮助别<br>人使用健康词汇的网络游戏，玩家可以操纵一名小男孩在街上侦察，看是否有人使<br>用了敏感词汇，小男孩可以选择上前指责或者通知警察，抓到的人越多，小男孩得<br>到的褒奖就越高。</p>
<p>　　阿瓦登随便打开了几个论坛，里面的人都彬彬有礼，说话很“健康”，就好象<br>街上的那些行人一样。不，准确地说，比街上的气氛还要压抑。在街上的人也许还<br>有机会保留一下自己的小动作，比如阿瓦登刚才在公共汽车上就偷偷地写了TITLE五<br>个字母；而在网上论坛，人的最后的一点隐私也全被暴露出来，有关部门随时可以<br>调看你的一切行动，无从遁形，这就是科学技术发展所带来的进步。</p>
<p>　　一阵失落和失望袭上阿瓦登的心头，他合上眼睛，把鼠标甩开，重重地向后靠<br>去。原来他天真地以为BBS论坛也许会少许宽松一些，现在看来甚至比现实中更叫人<br>窒息，他感觉到自己好象陷入沉滞的电子淤泥之中，艰于呼吸。“FUXKYOU, YOUSO<br>NOFBITCH”再一次涌现到他的唇边，强烈无比，要化好大的力气才控制住。</p>
<p>　　忽然，他又想到了那个神秘的title，那究竟是什么意思？那五张光盘里或许隐<br>藏着什么？也许这跟title有关系？</p>
<p>　　阿瓦登想到这里，把目光重新转向电脑屏幕，仔细去看网络安全部发来的五封<br>信的title部分。五张光盘各隐藏着一个字母，凑到一起就是title，那么按照这个<br>方式，那五封EMAIL的title凑到一起，就变成了一句话：去用户学习论坛。”</p>
<p>　　阿瓦登记得刚才他确实看到其中一个论坛的名字叫做“用户学习”，于是他抱<br>着姑且一试的心态连接到这个论坛去。他希望这并不是一个巧合。</p>
<p>　　用户论坛是一个事务性论坛，里面是一些关于BBS用户资料的投诉帖和管理帖，<br>斑竹的是一个叫19387465的人；发帖的人和回帖的人数量都很少，里面冷冷清清的<br>。阿瓦登打开帖子列表，按照刚才的规律去搜寻每一个帖子的标题，并把它们综合<br>到一起，很快他就得到了另外一句话： 　　“每周日辛普森大楼5层B户。”</p>
<p>　　又是一个谜团，阿瓦登想。但这却坚定了他的信心，这其中必定隐藏着玄机。<br>光盘、EMAIL和BBS论坛，连续三次都可以通过首词组组合的方式得到暗示，绝非巧<br>合。</p>
<p>　　究竟是什么人会在有关部门的官方文件中隐藏着这样的信息呢？每周日在效率<br>大楼5层B户又会发生什么事情呢？</p>
<p>　　阿瓦登终于找到了久违的兴奋感，未知事物的新奇刺激着他麻木很久的神经。<br>更重要的是，这种在有关部门正式文件中玩弄的文字技巧，叫他有一种喘息的快感<br>，仿佛一个密不透风的铁面罩上几个透进空气的小孔。</p>
<p>　　营造健康的互联网络。</p>
<p>　　FUXKYOU, YOUSONOFBITCH。</p>
<p>　　阿瓦登盯着屏幕上的桌面背景，用嘴唇比出了那句粗话的口型，并且比出了中<br>指。</p>
<p>　　在接下来的日子里，阿瓦登一直处于一种潜藏的兴奋状态，就象是一个摆出无<br>辜表情嘴里却藏着糖果的小孩子，在大人转身过去之后露出狡黠的笑容，尽情享受<br>心中藏有秘密的乐趣。</p>
<p>　　日子一天一天地过去，健康词汇在列表里又少了几个，窗外的空气又浑浊了几<br>分，这已经是生活的常态。阿瓦登自己已经开始拿网络健康词汇表当日历来用，划<br>掉三个词就证明过了三天，划掉七个就证明过了一周，于是周日终于到来了。</p>
<p>　　阿瓦登抵达辛普森大楼的时间是中午，暗示的句子里并没有指明时间，阿瓦登<br>认为在中午前往应该是比较可以接受的。当穿着深绿军大衣，耳朵上别着旁观者的<br>阿瓦登来到辛普森大楼的入口时，他的心开始忐忑不安地跳跃起来。他在上一星期<br>设想了无数种可能发生的情景，而现在这个谜底就要揭晓了。无论在周日效率大楼<br>会发生什么，也不会比现在的生活更加糟糕，阿瓦登心里想，所以他并不怎么害怕<br>。</p>
<p>　　他走进大楼内部，发现这里的人也很少，空旷的走廊里只听到他哒哒的脚步声<br>与回音。一部老电梯里贴着“缔造美好网络家园”的广告，以及一个充满了正义感<br>的男性头像海报，背景是星条旗，他在纸里用右手食指指向观看者，头上写着一行<br>字是“公民，请使用健康词汇。”阿瓦登厌恶地转过身去，发现另外一侧也贴着同<br>样的海报，避无可避。</p>
<p>　　值得庆幸的是五楼很快就到了，电梯的门一开，对面的门上就赫然挂着B户的牌<br>子。门是掉了漆的绿色，门框上还点了几滴墨水，一部简易的电子门铃挂在右上角<br>。</p>
<p>　　阿瓦登深深吸了一口气，伸手去按电纽。</p>
<p>　　电铃响起，很快屋子里传来脚步声。阿瓦登觉得这脚步的韵律很熟悉，似乎是<br>在哪里见到过。门“咔拉”一声被打开一半，一名年轻女子一手握着把手，把身体<br>前倾望着阿瓦登，警惕地说：</p>
<p>　　“你，找谁？”</p>
<p>　　女子疑惑地问道。阿瓦登一下子就认出了她的声音，就是那个在网络部BBS论坛<br>科柜台后面的女性。她很漂亮，穿着墨绿色绒线衫，头上梳着这时代流行的短发，<br>皮肤特别的白，只有嘴唇能看到一些血色。</p>
<p>　　看着女子的眼神，一瞬间阿瓦登不知道该说什么好，犹豫了一下，他举起右手<br>，轻声回答说：“title。”</p>
<p>　　阿瓦登不知道这句话能否奏效，也不知道自己是否真的找对了地方，但这是他<br>唯一能想到的回答了。他紧张地望着那女子，假如那女子忽然报警，那么自己就会<br>被抓起来仔细审问为什么无缘无故跑到陌生人家里。“肆意游走罪”只比“使用敏<br>感词汇罪”轻那么一点。</p>
<p>　　女子听到他这么说，脸上还是毫无表情，只是把头幅度很轻微地点了一下，右<br>手谨慎地做了一个“进来”的手势。阿瓦登刚要张口，那女子严厉地瞪了他一眼，<br>吓的他把话又吞回去了，乖乖地跟着她进了屋子。</p>
<p>　　一进屋子，女子首先做的就是把门关好，然后拉起来一层铅灰色的门帘挡在门<br>口。阿瓦登不安地眨着眼睛，趁她拉门帘的时候环顾四周。这屋子是标准的两室一<br>厅，在厅里摆放的是一套双人沙发与一个茶几，茶几上居然还有几束红紫色的塑料<br>花。靠墙是电脑桌和电脑，墙上挂着普通的白色日历， 但被主人用粉红色的纸套了<br>边，看起来颇为温馨。一盏粗笨的日光灯从天花板上垂下来，上面象是恶作剧一样<br>挂了几缕绿色的电线，象是垂下藤蔓的葡萄架。阿瓦登注意到厅口的鞋架上有四双<br>鞋，尺码不同，说明今天的客人并不只他一个。</p>
<p>　　阿瓦登正踌躇不安，忽然女子从背后拍了拍他的肩膀，示意他朝里面走。于是<br>两个人穿过客厅另一侧的短小回廊来到其中一间卧室。卧室上挂着同样质地的铅灰<br>色帘子，女子伸手举起帘布，推开了门。阿瓦登迈了进去，首先映入眼帘的是三名<br>面带微笑的人类，以及一间用真正的鲜花装点的房间。屋子里有很多旧日记忆里的<br>古老物品，比如一幅印象派的油画、一尊乌干达木雕，甚至还有一个银烛台，唯独<br>没有电脑。</p>
<p>　　他正在迟疑，女子也进了屋子。她谨慎地拉好门帘关上门，将耳边的旁观者取<br>下，回过身来对阿瓦登用曼妙的声音说道：</p>
<p>　　“欢迎加入说话会！”</p>
<p>　　“说话会？”</p>
<p>　　出于习惯，阿瓦登并没有把这三个字说出口，因为他不确定是否“健康”，只<br>是用眼神表示自己的疑惑。</p>
<p>　　“在这里你可以随便说话，这个该死的东西不会起作用的。”女子把自己的旁<br>观者晃了晃，那个小东西象死掉了一样，对女子句子里两个敏感词汇“随便”和“<br>该死”充耳不闻。</p>
<p>　　阿瓦登一下子想到上星期在公共汽车站前碰到的男子，如果他摘下旁观者，会<br>不会也会落到同一境地呢？那女子见他犹豫不决，指了指门口的铅灰色门帘说：“<br>放心好了，这里是可以屏蔽掉旁观者信号的，不会有人觉察到。”</p>
<p>　　“你们，是什么，人，这，是，哪里？”</p>
<p>　　阿瓦登一边摘下耳朵上的旁观者，一边小声说道，语调还是改不了那种有关部<br>门规定的说话方式。</p>
<p>　　“这里是说话会，是一个完全自由场所，在这里你可以畅所欲言，请不要拘束<br>。”</p>
<p>　　另外一个人起身对他说道，这是一名瘦高的中年男子，鼻梁上的眼镜非常地厚<br>。</p>
<p>　　阿瓦登嗫嚅着，却找不到发音的焦点，在四个人的注视下显得窘迫不堪，脸都<br>要红起来。女子同情地看了他一眼：“可怜的家伙，不用太紧张，每一个刚到这里<br>的人都是这样。慢慢就习惯了。”</p>
<p>　　她把手搭到阿瓦登的肩上：“我们其实见过的，当然，我见过你，而你没见过<br>我。”她一边说，一边将自己的头发解下来，原来她留的是一头齐肩的乌黑长发，<br>头发披下来的一瞬间阿瓦登觉得她真的很美。</p>
<p>　　“我……我记得你，记得你的声音。”阿瓦登终于说出了一句完整的话，虽然<br>不够流畅。</p>
<p>　　“是吗，那可太好了。”女子笑起来，拉着他的手，让他坐到沙发上，递给他<br>一杯水。阿瓦登注意到这是一个款式古老的茶杯，上面还刻着花纹，杯子里的水带<br>着浓郁的香气，阿瓦登尝了一点，那种甜丝丝的味道对喝惯纯净水的舌头来说刺激<br>格外地大。让他觉得浑身一下子被注进了许多活力。</p>
<p>　　“弄到这个可不容易，我们也不是每周都能喝到。”女子坐到他身边，两只乌<br>黑的眼睛注视着他，“你是怎么知道这个集会的？”</p>
<p>　　阿瓦登把发现光盘暗示的过程说了一遍，其他四个人都赞许地点了点头。“果<br>然是个聪明人，脑筋还没被陈腐的空气腐蚀掉。”一个三十多岁的胖子称赞道，他<br>的嗓门大的要命。那个戴眼镜的中年人把两只手交叉在一起，表示赞同。</p>
<p>　　“这正是天生的说话会成员，聪明、敏锐，而且不甘屈从于沉默。”</p>
<p>　　“那么。”胖子提议，“先让我们鼓掌欢迎说话会的新成员吧。”</p>
<p>　　于是四个人鼓起掌来，小小的屋子里响起一片掌声。阿瓦登羞涩地举起杯子做<br>回应，他还不太习惯这样的场面。等到掌声稍息，他抬起头怯生生地问道：</p>
<p>　　“可以问个问题吗？说话会到底是什么？”</p>
<p>　　带他进屋的女子伸出食指，在他鼻子前两公分的地方比了一比，解释道：</p>
<p>　　“说话会，就是可以畅所欲言的集会。在这里你不必顾忌什么，说出任何你想<br>说的东西。这里没有敏感词汇，也没有健康互联网络。这里是绝对自由的空间，你<br>可以尽情释放你的灵魂，舒展你的身体，没有任何禁锢与束缚。”说着说着，她的<br>声音变的高亢、奔放，里面饱含了许多早已经被屏蔽掉的词汇，阿瓦登不曾听到这<br>样流畅连贯的话语很久了。</p>
<p>　　“我们的宗旨就是，说话，就这么简单。”中年人扶扶眼镜，补充道。</p>
<p>　　“可是，要说些什么呢？”阿瓦登又问道。</p>
<p>　　“任何事情，你心里想的任何事情都可以说出来。”中年人露出宽和的笑容，<br>“尤其是那些被美国政府限制的思想。”</p>
<p>　　这可真是一个大胆的集会啊，这分明就是犯罪，阿瓦登心想，但他发觉自己却<br>被这种犯罪慢慢地吸引住了。</p>
<p>　　</p>
<p>　　“当然，有件事我们会事先说明。说话会是危险的，每一个成员都冒着被有关<br>部门拘捕的风险。联邦执法人员也随时可能破门而入，以非法集会以及非法使用不<br>合法词语的名义把我们抓起来。你现在有权拒绝加入，并且离开。”</p>
<p>　　阿瓦登听到女子的警告，心里一度犹豫起来。但一想到此刻离去的话，那么又<br>要开始持续那种窒息的泥沼生活，他就难以压抑自己的烦闷。阿瓦登第一次发现，<br>原来“说话”对他来说是一个致命的诱惑，他先前并不知道自己原来是如此地渴望<br>着说话。</p>
<p>　　“我不会离开的，我要加入你们，说话。”</p>
<p>　　“那太好了。唔，那么不妨就从自我介绍开始吧。”女子高兴地说，同时站起<br>身来，把右手搭到胸前，“从我开始。我的名字叫阿尔特弥斯，至于网络编号和身<br>份证号码，让他们见鬼去吧！谁会去管那个！我有我自己的名字，我不是数字。”</p>
<p>　　她的话让所有人包括阿瓦登都笑了起来。接着她继续说道：“不过，这其实只<br>是一个假名，这是希腊神话里的女神。”</p>
<p>　　“假名？”</p>
<p>　　“是的，和我户籍本上的名字是不同的。”</p>
<p>　　“可是，为什么？”</p>
<p>　　“你不会对自己在档案里的名字厌倦吗？我想起一个自己喜欢的名字，哪怕只<br>有一次机会也好，自己想叫什么就叫什么。在这个说话会里的每一个人都有一个自<br>己喜欢的名字，我们彼此拿这个称呼。”</p>
<p>　　阿瓦登若有所思地点点头，他很理解阿尔特弥斯的想法。事实上当他在使用网<br>络论坛的时候，也希望能够自己取一个称心如意的名字，而不是被分配一个用户名<br>。</p>
<p>　　通过介绍，阿瓦登了解到阿尔特弥斯是网络部BBS论坛管理科的职员，今年23岁<br>，未婚，最讨厌蟑螂和蜘蛛，喜欢缝纫与园艺，屋子里的花就是她偷偷从城市边缘<br>摘回来的。</p>
<p>　　接下来是那名中年人，他自我介绍说名字叫兰斯洛特，41岁，是城市电厂的一<br>名工程师；兰斯洛特这名字出自英国的亚瑟王传说，是一名忠贞的骑士。他有自己<br>的老婆和两个孩子，一男一女；男孩三岁，女孩四岁，他们最喜欢吃的就是柠檬味<br>道的水果糖。说到这里，兰斯洛特说希望下次聚会能把他们也带了，孩子们正是学<br>说话的时候，他想教给他们真正的说话。</p>
<p>　　那个三十多岁的胖子是网络部的一名网管，叫瓦格纳。这个身份让阿瓦登吃惊<br>不已，他的印象里网管都是些绷着脸全无表情的冷漠生物，但眼前的瓦格纳脸圆滚<br>滚的，油光锃亮，嘴边两条翘起的小胡子神气十足。他喜欢的是雪茄和歌剧，利用<br>网管的特权这两样东西都不难弄到。</p>
<p>　　“这个能屏蔽掉信号的门帘就是他弄的。”阿尔特弥斯补充说，瓦格纳冲她做<br>了个“乐意为您效劳”的手势，然后点燃了雪茄，把它放到嘴里，很快屋子里就笼<br>罩起一片稀薄的烟雾。</p>
<p>　　说话会的第四名成员是一位穿着黑色制服的女性，今年刚满三十。她的名字是<br>杜拉丝，城市日报（那个时代的报纸已经全部都数字化了）的编辑，她比阿尔特弥<br>斯还瘦，颧骨高高耸起，眼窝身陷，两片薄薄的嘴唇即使在最说话的时候也很少分<br>开，看不到牙齿。爱好是饲养狗和猫，尽管她并没有养。</p>
<p>　　“那么，到你了。”阿尔特弥斯对阿瓦登说。阿瓦登想了想，结结巴巴地把自<br>己的情况说了一遍，当谈到自己的爱好时候，他一时间居然想不到自己喜好什么，<br>似乎什么都没有，在那之前他甚至从来没想过。</p>
<p>　　“那，你最想做的是什么事呢？”阿尔特弥斯把手再一次放在他肩上，诱导着<br>问道。</p>
<p>　　“真的什么都可以？”</p>
<p>　　“什么都可以，在这里没有任何限制。”</p>
<p>　　阿瓦登觉得自己终于找到机会了，他咳了一声，抓抓头，脱口而出一句响亮的<br>叫喊：“FUXKYOU, YOUSONOFBITCH！”</p>
<p>　　在一瞬间，在座的四个人都被他这句话震惊了。瓦格纳率先反应了过来，他先<br>叼住雪茄，用力鼓掌，然后用右手把雪茄取下来，张嘴大声地赞叹道：“真棒，痛<br>快，这简直是最完美的入会誓词。”</p>
<p>　　“我宁可听十遍这样的脏话，也不想再去碰那个乏味的电子女声。”兰斯洛特<br>也是一脸陶醉，毫不掩饰自己对电子女声的厌恶。而阿尔特弥斯和杜拉丝全都咯咯<br>地笑起来，杜拉丝发现自己的笑容幅度大了一点，不好意思地把嘴掩住。阿瓦登觉<br>得他们与其说是觉得新奇，不如说是在享受这句脏话所带来的对体制的蔑视与挑战<br>。</p>
<p>　　“那你叫希望自己叫什么名字呢？” 阿尔特弥斯歪着头问。</p>
<p>　　“唔……王二。“ 阿瓦登沉吟了一下，回答说。这是一个中式的名字，他以前<br>有一个中国人朋友，喜欢讲故事，故事里的主角名字总是叫王二。</p>
<p>　　屋子里的气氛现在完全融洽了，大家都开始谈些比较自然的话题，每个人都摆<br>出了最舒服的姿势，阿尔特弥斯不时拿起茶壶来为大家续水。阿瓦登紧张的心情逐<br>渐放松下来，他感觉到自己的脑子前所未有地轻松。</p>
<p>　　“你知道的。”阿尔特弥斯又给他倒了一杯甜水，“我们一直想把说话会保持<br>在一定规模，平日是没有办法畅所欲言的，我们需要空间。麻烦的是，我们没办法<br>公开征集会员，又不可能直接通过物理接触去寻找，那风险太大。于是兰斯洛特就<br>设计了一套暗示系统，只有发现这些暗示的人才能知道本会的存在。”</p>
<p>　　“这套系统考虑到的还不止是安全问题。”兰斯洛特把自己的眼镜摘下来仔细<br>擦拭了一下，得意地说，“这其实也是一个会员资格验证。说话会所吸纳的成员，<br>必须有智慧，有头脑，内心渴望激情，并且对自由有着渴望。”</p>
<p>　　瓦格纳用两根指头夹着雪茄，在事先准备好的烟灰缸里弹了弹烟灰，大声说道<br>：“据我的经验，申请BBS论坛服务的人，大多数都是为了怀旧，或者说渴望一些新<br>鲜的东西，这样的人往往都怀有激情，认为BBS论坛也许能给他们一些与现实不一样<br>的东西——当然，事实上并非如此，美国政府对BBS论坛的管理甚至严厉过电子邮件<br>——这暗示着他们心里渴望解脱束缚。因此我们将暗示隐藏在申请BBS论坛的光盘之<br>中，只有申请人才有机会接触到这些暗示。而只有那些有智慧、观察敏锐的人才会<br>发觉到这些暗示的存在，并顺利解读出来，找到这里。”</p>
<p>　　“归根到底，说话会也不过是一群渴望自由说话的秘密小团体罢了。”兰斯洛<br>特笑道。</p>
<p>　　“你是第二个找到说话会的人，第一个是杜拉丝小姐。”</p>
<p>　　阿尔特弥斯告诉阿瓦登。阿瓦登敬佩地看了杜拉丝一眼，后者淡淡地回答道：<br>“这没什么，这是我的工作，我的工作就是摆弄文字。”</p>
<p>　　阿瓦登想到上一周在公共汽车站碰到的那个疯狂男子，于是把这件事讲给其他<br>成员听。听完之后，兰斯洛特摇了摇头，从嘴唇里滑出一声叹息：</p>
<p>“这样的事情我也是见过的，我的一个同事就是如此。所以说话会的存在是必要的<br>，这是缓解压力的阀门。长时间的敏感词汇限制会让人都疯掉的，因为他们既无法<br>思考又没办法表达。”</p>
<p>“这正是美国政府有关部门所希望看到的，这样只有傻瓜能够存活下来，一个全是<br>傻瓜的社会是稳定的。” 瓦格纳费力地把自己肥胖的身躯挪了一下位置，轻蔑地说<br>。</p>
<p>“你也是有关部门的一分子，瓦格纳先生。”阿尔特弥斯一边往茶杯里续了些热水<br>，一边抬头轻声说道。</p>
<p>“阿尔特弥斯小姐，我只是一个能比普通人多使用几个敏感词汇的普通人而已。”</p>
<p>　　大家都笑了起来。阿瓦登从来没有见过这么多的人说这么多的话，这是前所未<br>有的奇妙经验。他惊讶地发现自己居然很快就融进了这个小圈子里，隔阂与陌生感<br>很快就消失了；同时消失的还有胸闷与头晕等习惯性的毛病。</p>
<p>　　很快话题就从说话会本身扩展到了更加宽泛随意的话题，阿尔特弥斯唱支歌，<br>兰斯洛特说了几个笑话，杜拉丝则给大家讲了美国南部诸州的风土人情；瓦格纳甚<br>至还唱了一段歌剧，虽然阿瓦登一个字也听不懂，但他一点也不吝惜掌声。在这个<br>城市的某一个被屏蔽掉的角落里，五个不甘沉默的人正在享受着在这个时代视为奢<br>侈品的事情——说话。</p>
<p>　　“王二，你可曾看过《1984》？”</p>
<p>　　阿尔特弥斯忽然问道，她就靠着阿瓦登坐下，阿瓦登摇摇头，反问道：“这是<br>网络编号的一段么？”</p>
<p>　　“这是一本书的名字。”</p>
<p>　　“书？”阿瓦登听到这个名词，头摇的更大了。这是个古老的名词，在这个电<br>脑技术非常发达的时代，网络可以承载一切信息，任何人都可以在网上图书馆查到<br>电子版；因此有关部门认为实体书籍变成了一种没有必要存在的浪费，实体书也就<br>逐渐消亡了。瓦格纳对此的评论是：“有关部门喜欢电子书籍的心情是可以理解的<br>，电子书籍的话，只需要FIND和REPLACE两个命令就可以消灭掉全部不健康词汇，替<br>一本书消毒；而实体书籍的校对与修订却是件旷日持久的工作。”</p>
<p>　　“这是一本伟大的书，是旧世界哲人们对我们这个时代的预言。”阿尔特弥斯<br>认真地说。“它很早以前就洞察到了肉的束缚与解脱，灵的束缚与解脱，这是说话<br>会的基石。”</p>
<p>　　阿瓦登不无惊奇地发现他的网络编号开头恰好是这这本书名字：19842015。</p>
<p>　　“那么，该怎么样才能看到呢？”阿瓦登盯着阿尔特弥斯乌黑色的眼睛问。</p>
<p>　　“我们也无法找到纸质版，网络图书馆不可能存在这样的书。”兰斯洛特摇摇<br>头，然后重新露出笑容，左手向着杜拉丝摆了个请的姿势，“但我们的杜拉丝小姐<br>应该为她的记忆力而自豪，她在很早已经有幸阅读过这两本书，并且能够记得里面<br>的大部分文字。”</p>
<p>　　“太好了，然后她写下来了，对吗？”</p>
<p>　　“那太危险，这时代持有实体书是个大罪过，也容易让说话会暴露。我们只是<br>在每次聚会的时候请杜拉丝小姐为我们背诵。既然是说话会，那么把这两个故事讲<br>出来不是更名符其实吗？”</p>
<p>　　大家都安静下来，杜拉丝站起来走到屋子中央，其他四个人坐在旁边看着她。<br>阿瓦登不经意地把手搂在阿尔特弥斯肩上，后者微微朝这边靠过来，女性头发的幽<br>香“咝咝”地划过他的鼻子，让他的心里一阵荡漾。屋子里非常暖和，他分不清这<br>是花香还是阿尔特弥斯的味道。</p>
<p>　　杜拉丝的声音并不高，不过却很清晰有力；她的记忆力确实惊人，不仅记得情<br>节，包括一些细节和句子都可以复述下来。杜拉丝讲到了朱丽亚假装摔倒，然后偷<br>偷递给温斯顿一张写着“我爱你”的纸条，绘声绘色，这让听众们都听的入神了，<br>阿尔特弥斯听的尤其认真，以至于都没有注意到阿瓦登一直注视着她。</p>
<p>　　“1984的作者预见到了专制的进步，却没有预见到技术的进步。”瓦格纳在杜<br>拉丝停下来喝水的时候发表自己的评论，阿瓦登觉得他与外貌不太相称，是个很有<br>洞察力的技术官僚。</p>
<p>　　“在大洋国人们还可以靠传递纸条来偷偷表达自己的想法，但是现在不一样了<br>。美国政府有关部门把我们全赶到了网上，而在网络技术发达的今天，我们即使想<br>发一条短信都会被系统或者网管看的一清二楚，无从遁形。现实里呢，还有旁观者<br>在。”瓦格纳在腿上敲了敲雪茄根部，“一句话，技术是中性的，但技术的进步会<br>让自在的世界更自在，集权的世界更加集权。”</p>
<p>　　“这句话说的很有哲学家的味道哟。”阿尔特弥斯冲瓦格纳挤了挤眼睛，从抽<br>屉里取来一把饼干和曲奇散发给大家。</p>
<p>　　“就好象同样是0和1，有的人就能写出工具软件，有人却拿那个编出恶性病毒<br>？”</p>
<p>　　阿瓦登想到一个类似的比喻，瓦格纳听了以后满意地打了个响指。</p>
<p>　　“很不错的比喻，王二，就是如此，真不愧是程序员。”</p>
<p>　　谈话持续了不知道有多久，杜拉斯看了一眼墙壁上的挂钟，连忙提醒谈兴正浓<br>的四个人时间快到了。说话会不能持续很长时间，旁听者被屏蔽的越久，暴露的危<br>险就越大。</p>
<p>　　“那么好吧，我们就抓紧最后半个小时来完成今天的活动。”</p>
<p>　　阿尔特弥斯一边说着，一边将桌子上的空杯子收走。兰斯洛特和瓦格纳也都站<br>起身来，活动一下已经有些酸疼的肩膀和腰，只有杜拉丝坐在位子上没有动。</p>
<p>　　“活动？还有什么活动？”</p>
<p>　　阿瓦登奇怪地问道，说话会除了说话还有其他活动？</p>
<p>　　“唔，对啊，我们还有其他活动。”阿尔特弥斯撩起额前的长发，对他妩媚一<br>笑：“我们还会和对方完全交流。”</p>
<p>　　“完全交流？”</p>
<p>　　“就是intercourse”</p>
<p>　　“………………”阿瓦登一下子变的脸色苍白，呼吸急促起来，仿佛胃里被灌<br>进去零下三十度的寒风，他几乎不相信自己的耳朵。</p>
<p>　　“说话会有说话的自由，也有选择与谁上床的自由。”阿尔特弥斯毫不羞涩地<br>说，“我们互相谈话，然后选择合适的人做爱，就象我们选择我们喜欢的词汇说话<br>一样。”</p>
<p>　　兰斯洛特看阿瓦登很窘迫，走过去拍拍他的肩膀，慢慢地说：“当然，我们不<br>会强迫任何人，这完全是在自愿的基础上。今天我还要早点回去照顾小孩，你们人<br>数正好合适。”</p>
<p>　　阿瓦登的脸色涨红，热的仿佛夏季的电脑CPU，他甚至不敢多看阿尔特弥斯一眼<br>。他憧憬过女性很长时间，但如此接近还是第一次。</p>
<p>　　还要回家去照顾小孩子的兰斯洛特向大家道别后就先行离去了，阿尔特弥斯将<br>房间留给瓦格纳与杜拉丝，然后带着惶恐不安的阿瓦登来到了另外一间房间。这间<br>显然是阿尔特弥斯的卧室，屋子里很简单，但却收拾的十分干净，在床上枕头旁还<br>摆着一个手制的布娃娃，床单和窗帘都是粉红色的。</p>
<p>　　最初的是由阿尔特弥斯主动开始的，丝毫没心理准备的阿瓦登只是被动地任她<br>摆布。经过了几轮挑逗，阿瓦登才逐渐放开，任由潜藏在自己心内的原始欲望奔流<br>出来，那种期待听到圆润女声的青春憧憬本来只是苦闷生活的意淫，而在今天它加<br>倍实现了。很快这种憧憬与他在现实中被压抑的郁闷合流，转化成了猛烈的冲动，<br>让他一次又一次与阿尔特弥斯融为一体。阿瓦登不知道这种冲动和他想大声说出“<br>FUXKYOU, YOUSONOFBITCH”冲动有什么不同，不过现在不是考虑这个的时候，他现<br>在脑子里想的只有尽情地、全无束缚地让自己释放激情，完全没有任何束缚。</p>
<p>　　强烈的刺激一波波地冲击着兴奋中枢，最终一阵快感浪潮在狂暴洋面扬起头来<br>，达到了一个极高的顶端。阿瓦登在那一瞬间感觉到了前所未有的自由，那种轻盈<br>无比的自由，以及因自由而生的快乐与疲惫。浑身是汗的他喘息着倒在了阿尔特弥<br>斯身上，一阵舒畅的倦意如潮水般淹没了他的身体……</p>
<p>　　……当他醒来的时候，发现阿尔特弥斯躺在自己身边，赤裸的身体好象一尊白<br>玉雕像，睡姿恬美静谧。他侧过身子去，慵懒地打了个呵欠，然后阿尔特弥斯睁开<br>了眼睛。</p>
<p>　　“很舒服，对不对？”她问道。</p>
<p>　　“是啊……”阿瓦登不知道该说什么好，他顿了顿，犹豫地说道：“你以前和<br>兰斯洛特、瓦格纳他们也……呃，我是说，象刚才那样子过吗？”</p>
<p>　　“是的。”阿尔特弥斯温柔地回答，她半支起胳膊，长发从肩膀披到了胸口。<br>她的大方坦白反而让阿瓦登有些不知所措。屋子里出现了一段时间的沉默，然后阿<br>尔特弥斯忽然开口问道：</p>
<p>　　“还记得今天杜拉丝讲的那段故事吗？女主角偷偷递给男主角写着“我爱你”<br>的纸条。”</p>
<p>　　“唔，还记得。”阿瓦登回答，很高兴终于能从那个拙劣的话题摆脱出来了。</p>
<p>　　“在有关部门的健康互联网络词汇列表里，没有爱这个字呢。在我们这个时代<br>，我爱你也是一个敏感词汇，被屏蔽掉了。”阿尔特弥斯的眼神里似乎是感慨，又<br>象是失落。</p>
<p>　　“我爱你。”阿瓦登不禁脱口而出，他知道在这间屋子里可以说出任何自己想<br>说的话，不必顾忌。</p>
<p>　　“谢谢你。”</p>
<p>　　阿尔特弥斯听到之后只是笑了笑，起身穿上衣服，催促阿瓦登时间差不多了。<br>阿瓦登有些失望，因为她没有预期反应的热烈，仿佛他刚才说的只是有些无关紧要<br>的东西。</p>
<p>　　这时候杜拉丝和瓦格纳已经离开了，屋子里只剩他们两个人。阿尔特弥斯把他<br>送到门口，将旁观者交给他，然后叮嘱他说：“记得在外面绝对不要提及说话会的<br>任何事情或者任何人，我们在说话会以外的地方是完全不认识的。”</p>
<p>　　“我记住了。”阿瓦登回答，然后转身要走。</p>
<p>　　“王二。”</p>
<p>　　阿尔特弥斯忽然叫道，阿瓦登连忙转身，还没等他反应过来，两片柔软温暖的<br>嘴唇忽然贴到了他的双唇，然后是一个细切的声音在耳边响起：“谢谢你，我爱你<br>。”</p>
<p>　　阿瓦登觉得眼睛有些湿润，他戴上旁观者，推开门，重新步入到那一片令人窒<br>息的世界中去，但他此时已与来时的心境大不相同。</p>
<p>　　此后阿瓦登的精神面貌明显有了改善。他谨慎地享受着这种秘密集会的乐趣，<br>并且乐在其中。每一周或者两周，他们五个人都会在周日秘密地举行说话会的活动<br>，聊天，唱歌或者听杜拉丝讲1984的故事。阿瓦登同阿尔特弥斯又“完全交流”了<br>几次，偶尔他也会跟杜拉丝“交流”。他有了两个身份，一个是现实中和网上的阿<br>瓦登，编号19842015，还有一个是说话会里的王二。他很享受这个名字，觉得这就<br>是自己另外的一个人生。</p>
<p>　　有一次集会，他们谈到了敏感词汇的问题。阿瓦登记得很早的时候——他对这<br>方面的记忆有点模糊——有关部门给出的是一份敏感词汇列表，由网站的内部管理<br>人员秘密参考使用，他对如何演变成现在的局面大惑不解。那一天瓦格纳带了一瓶<br>葡萄酒，兴致很高，于是索性给他们讲了讲“屏蔽”的进化史，身为网管的他经常<br>可以接触到这些资料。</p>
<p>　　在最开始美国政府只是单纯地屏蔽掉敏感词汇，但很快他们就发现这样的措施<br>根本没有用处。很多人会采取在词组中夹杂符号或者数字的方式来绕开系统检查；<br>于是有关部门不得不将这些近似敏感词汇也一一屏蔽掉。然而众所周知，数字与符<br>号之间的组合方式是近乎无限的，只要你有想象力，就完全可以组合出一个新的词<br>组而且不失掉他的原意。比如说“politic”这个词，就有“politi/c”、“政pol<br>it/ic”、“pol/itic”等近乎无限种表达方式。</p>
<p>　　当有关部门意识到这个问题时，他们采取了新的策略。既然无法辨识词组，那<br>么就用单词屏蔽。这一举措在一开始是奏效的，违规交谈的人显著减少，但很快人<br>们就发现可以用同音字或者谐音的方式来继续表达自己的危险思想。即使有关部门<br>封掉全部敏感词汇的同音字，也无济于事，思想活跃的美国人充分发挥了自己的想<br>象力，使用隐喻，借代、类比、引申及其他修辞方法，或者将一个敏感词用数个不<br>敏感的字来代替。人类的思维方式要比电脑开阔许多。电脑屏蔽掉一条路，他们还<br>会有更多的路可以选择。</p>
<p>　　这一场水面以下的角力看起来似乎是美国大众要取得胜利。这时候，一个具有<br>逆向思维精神的人出现了。他的身份不明。有人说他是有关部门的主管；也有人说<br>他是因过度使用敏感词汇而被捕的危险人士。无论他是谁，总之整个局面被扭转过<br>来。他向有关部门建议，不再告诉大众禁止说什么，而是规定他们只能说什么，用<br>什么方式去说。有关部门很快就心领神会，制订了新的规章制度：取消了敏感词汇<br>列表，取而代之的是互联网络健康语言列表，并把这举措推广到了日常生活中的语<br>言屏蔽系统中去。</p>
<p>　　这一次，大众终于处于下风。以往他们与有关部门尽情地在网络与现实中捉着<br>迷藏，而现在他们却被有关部门扼住了咽喉。这样一来，有关部门可以有效率地掌<br>握住言论，因为整个语言的框架都被彻底控制了。在有限的空间内，大众几乎是无<br>计可施。</p>
<p>　　尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他<br>们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思<br>就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一<br>动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使<br>用。</p>
<p>　　“当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组<br>，那么就可以继续自由交流——你知道莫尔斯电码吧？”</p>
<p>　　瓦格纳说到这里，拿起茶杯一饮而尽，满意地打了一个嗝。</p>
<p>　　“可是，这场战争的代价就是语言的失落。表达能力会越来越贫乏，越来越淡<br>而无味，人们会越来越倾向于沉默，这对有关部门反而是好事。”兰斯洛特摆出一<br>副忧虑的表情，有节奏地用指关节敲击着桌面，“这样一来，岂不就等于是大众的<br>自由意识将语言推向死亡的边缘？真讽刺啊。按照这个趋势，有关部门是不会败的<br>，他们会笑到最后。”</p>
<p>　　“不，不，笑这种情感他们是不会了解的。”瓦格纳淡淡地回答。</p>
<p>　　“我倒是觉得，美国是一直处于恐惧的情感之中呢，生怕人们掌握了太多的词<br>汇，表达出太多的思想，变的难以掌握。”阿尔特弥斯说完摆出一副她在上班期间<br>冷若冰霜的呆板脸孔，学着僵硬的腔调喊了一句：“营造健康的网络环境，美国万<br>岁！”</p>
<p>　　杜拉丝、兰斯洛特与瓦格纳都哈哈大笑，唯一没笑的是王二（阿瓦登）。他对<br>于兰斯洛特刚才的那句话始终耿耿于怀：大众与有关部门的对抗，其最终结局就是<br>语言的消亡。那么他们现在这个小小的说话会，也只不过是在一列开向悬崖的列车<br>里关上窗帘，享受坠毁前最后的宁静罢了。</p>
<p>　　不过他没有说出口，因为这太煞风景了。阿瓦登不希望破坏说话会的气氛，这<br>对他很重要。</p>
<p>　　从说话会回到家里，阿瓦登躺在行军床上，双手枕着脑袋，陷入了沉思。自从<br>加入说话会以后，他变的比以前更容易陷入思考。有时候他想的是这个社会、这个<br>互联网络或者这座城市中存在的荒谬性；有时候他想的是自己的生活；还有时候他<br>想的是阿尔特弥斯。他不知道是不是在一个压抑的世界里，人的情感会变的格外强<br>烈，他现在陷入对阿尔特弥斯的迷恋无法自拔。阿瓦登一直很羡慕杜拉丝讲的《19<br>84》里面的温斯顿，他和朱利亚有一间两个人独处的小屋，一个只属于他们两个人<br>的小世界。</p>
<p>　　他在与阿尔特弥斯“完全交流”的时候曾经吐露过自己的心声，阿尔特弥斯没<br>有直接回答，而是表示两个人的关系无法再比说话会更近一步——维持现在的状态<br>就已经是个人行为的极限，有关部门可不会一直打瞌睡。“我们只能把感情生活压<br>缩在每周一次的说话会活动里，这已经很奢侈了。”她对他说，同时温柔地抚摩他<br>的胸膛。“只有在说话会里，我们才是阿尔特弥斯和王二。而在其他时间里，你是<br>19842015，而我是19387465。”</p>
<p>　　对此，阿瓦登只能发出一声轻轻的叹息，确实他不该奢求更多。</p>
<p>　　除了感情，发生变化的还有互联网络。自从加入说话会以后，阿瓦登逐渐发现<br>互联网表面下潜藏的一些东西。正如瓦格纳在一次活动的时候指出，普罗大众与有<br>关部门的战争从未结束，总会有思想和言论从严厉管制的缝隙中流泻出来。阿瓦登<br>发现，在完全公式化的EMAIL与网络论坛中其实隐藏着不少耐人寻味的细节，就好象<br>那个title一样，存在着各式各样的密码与隐藏寓意。这些东西出自不同人的手里，<br>样式和破译方式都不同，阿瓦登不知道那些密码背后隐藏的是怎样的内容。不过有<br>一点可以确知的是，说话会并不是唯一的一个地下集会，瓦格纳说的对，始终还是<br>有人在试图用“健康”词汇表达“不健康”思想。</p>
<p>　　讽刺的是，给阿瓦登感触最深的，是有关部门的管制。以往他只是模糊地感觉<br>到自己被绑缚起来，现在他能清晰地看清这种束缚与压抑的脉络，以及加诸在自己<br>身上的各种手段。在小小说话会中享受到的自在让他更加深刻地感受到在宽阔现实<br>中的不自在。</p>
<p>　　“FUXKYOU, YOUSONOFBITCH！”</p>
<p>　　每一次的聚会，三位男士都会轻蔑地一起高喊这一句粗话。他们清楚这不会给<br>有关部门带来什么不良影响，不过这确实很痛快。</p>
<p>　　这一周，阿瓦登特别地忙碌，他的同事因为不明原因而被屏蔽掉了，这样一来<br>整个项目就全压在了他一个人身上。这项目是为有关部分设计一种软件，用来控制<br>大功率主动式“旁观者”的能源分配控制。软件很复杂，他不得不每天在电脑前工<br>作十几个小时，只有在身体实在支撑不住的时候才停下来随便吃一点东西，喝一口<br>纯净水，困了就躺在旁边的行军床上睡上一觉，爬起来继续工作。屋子里满是浑浊<br>的烟味与袜子脏衣服的酸臭味，阿瓦登就在这种环境下蓬头垢面地敲着键盘，并不<br>时揉揉满布血丝的眼睛。</p>
<p>　　偏偏在这个时候屋子里的暖气坏掉了。洋灰色的暖气片从昨天开始就变的冰凉<br>，不再有热水流动。阿瓦登检查了一下，发现并不是管道问题，而且邻居们也碰到<br>同样的事，看来是供热系统出了问题。这一变故的正面影响是稍微淡化了屋子内的<br>酸臭味，负面影响是整个屋子变的有如冰窖一样。紧闭的窗户和门能挡住寒风，却<br>挡不住寒冷，低温让本来就寒酸的房间更笼罩上一层霜气。无论是那把木椅还是行<br>军床都象是冷酷的冰雕，屋子里唯一还有些热气的就只剩下电脑。阿瓦登不得不披<br>上所有的御寒衣物，蜷缩在床上，把电脑的散热口对准自己。</p>
<p>　　有关部门宣布“供热”和“暖气”暂时也被列入敏感词汇，于是阿瓦登没办法<br>写信向供热部门询问，只好静待，除了用来敲键盘的指头以外，尽量保持全身一动<br>不动，以节约热量。在停止供暖后的第四天，暖气片里终于传来“哗啦哗啦”的声<br>音，带着热气的水开始流动，屋子里恢复了温暖，“供热”和“暖气”又可以恢复<br>使用了。于是EMAIL与网络论坛上全都是“庆祝有关部门恢复供应暖气，急人民之所<br>急”的帖子，EMAIL新闻组里也全是类似主题。</p>
<p>　　不过这对阿瓦登来说太晚了，他生了病，感冒，而且是重感冒。他面色苍白，<br>全身软弱无力，头疼的象是被一枚达姆弹射入头部，只能躺在床上等医生。医生来<br>到他家里，给他做了两三次点滴，喂了一些叫不上名字的药片，叫他静养。这一场<br>病足足持续了数天，他不得不放弃参加这一星期的说话会，身体状况实在太差了，<br>阿瓦登甚至怀疑自己搞不好会因此而死掉。</p>
<p>　　阿瓦登躺在床上，心里懊悔不已，说话会是他唯一的乐趣，现在他却没办法参<br>加。他把头蒙在被子里胡思乱想，瓦格纳这一次会带什么特别的东西来呢？兰斯洛<br>特有没有把两个孩子也领过来？还有阿尔特弥斯，他没参加的话，她会和谁“完全<br>交流”呢？瓦格纳还是兰斯洛特？他还想到了杜拉丝，上一次的聚会里，杜拉丝讲<br>到了温斯顿在秘密幽会的屋子里对朱丽亚说“我们已经死了”，朱丽亚附和着说“<br>我们已经死了”，这时候第三个声音说道“你们已经死了。”</p>
<p>　　杜拉丝就讲到这里，就停住了。阿瓦登急切地想知道接下来发生了什么，第三<br>个声音是谁，是党吗？温斯顿和朱丽亚是否会被捕，他们会有什么样的下场？不光<br>是他，阿尔特弥斯也很希望知道后续情节的发展，不过她并没有去追问杜拉丝。</p>
<p>　　“让这成为一个悬疑，这样接下来的一周我们的生活都会在期待的乐趣中度过<br>。”她对阿瓦登说，然后两个人继续沉溺于intercourse的快乐。</p>
<p>　　“也许他们都会死。”阿尔特弥斯在交流结束后，看着天花板说。</p>
<p>　　“也许那只是奥布林的声音，他去探望他们。”阿瓦登安慰她道，但是他的心<br>里也不确定。</p>
<p>　　阿瓦登的病持续了十天，然后他终于痊愈了。他痊愈后的第一件事就是从床上<br>爬起来，然后去看墙上的日历：这一天恰好是星期日，说话会活动的日子。阿瓦登<br>已经缺席了一周，这已经令他如饥似渴，甚至做梦都在和他们一起喋喋不休地说着<br>话——所幸他并没有说梦话的习惯，所以24小时工作的旁观者并没发出任何警报。</p>
<p>　　阿瓦登简单地洗了一下脸，用一把有些生锈的剃刀沾着肥皂仔细地刮掉脸上粗<br>硬的胡须，然后咕噜咕噜地刷了刷牙齿，用手和毛巾沾着热水将自己蓬起的乱发压<br>下去。因为生病，有关部门发了一些补贴给他，其中包括两块羊角面包、两瓶姜汁<br>啤酒和一份精制砂糖。他将这些东西都用塑料布仔细包好，揣到宽大的军大衣里，<br>打算带到说话会上去与大家分享。</p>
<p>　　今天的天气和往常一样地冷，阿瓦登把自己裹在大衣里，登上前往效率大楼的<br>公共汽车。一路上车厢里的广播重复着“营造健康的互联网络”以及一些优秀网络<br>用户的先进事迹；车厢前面的电子屏幕不断滚动显示着最新的健康词汇列表，一个<br>旁观者自车顶垂下来睥睨着车内的每一个表情呆滞的人。阿瓦登坐在最后一排，望<br>着窗外不断向后移动的建筑物与枯黄的树木发呆。</p>
<p>　　车子很快就到达了辛普森大楼附近的车站，阿瓦登下了车，把手放到怀里摸了<br>摸塑料布包着的食物，朝着大楼走去。他在半路无意中抬起头，忽然一阵冰冷的寒<br>流刺入他的胸腔，迫使他停住了脚步。</p>
<p>　　有什么地方不对劲！</p>
<p>　　他看到了效率大楼的第五层阿尔特弥斯家的窗户发生了一些奇怪的变化。以前阿尔特弥斯家面向大街的窗户总是挂着粉红色的窗帘，而现在窗帘则被扯到了两边<br>，窗户大开，用肉眼可以勉强看到窗玻璃和屋子里雪白的墙壁。假如今天有说话会<br>的话，阿尔特弥斯绝对不会把有屏蔽效果的窗帘打开。而且打开窗户这件事也绝不<br>寻常，在这个城市里的室外空气十分浑浊，几乎不会有人会去开窗换气。</p>
<p>　　也就是说，今天并没有说话集会召开，而是发生了另外一些事情。阿瓦登望着<br>那窗户，心情开始变的有些慌乱，他把手从兜里掏出来，叼起一支香烟，把身体靠<br>在一根电线杆旁故做镇静，以免被行人怀疑。究竟说话会发生了什么，为什么这一<br>周停办了呢？要知道，只要还有复数的成员能够出席，说话会就会一直办下去，难<br>道说瓦格纳、兰斯洛特、杜拉丝和阿尔特弥斯同时无法出席？这种概率实在太小了<br>。阿瓦登一边这样想着，一边向四周不安地张望。忽然他看到了一样东西，一个念<br>头霎时占据了他的全部心灵，让他几乎眩晕过去。</p>
<p>　　“说话会本周不会有了，以后也不会有了。”阿瓦登嘴唇默默地蠕动着，面如<br>死灰。</p>
<p>　　他看到在街道内侧一处不起眼的地方隐藏着一个类似雷达天线的东西，其造型<br>很象是两个背部贴在一起的大碗。阿瓦登心里清楚这是什么东西：这正是他负责软<br>件设计的大功率主动式“旁观者”，这造型他很熟悉。这装置可以主动发射电波去<br>探测人们的声音，并检查其中是否存在敏感词汇。</p>
<p>　　这样的装置居然就安放在阿尔特弥斯家附近，那么就等于说话会完全暴露在了<br>有关部门的监控之下。主动式旁观者的强大刺探电波会轻易刺穿她家中的铅质窗帘<br>，把所有成员的话原封不动地传到有关部门耳朵里。</p>
<p>　　这是一个划时代的发明，这一技术的突破意味着有关部门可以不再被动地等待<br>警报，可以主动出击去刺探人们在任何时间任何地点说的任何话语。阿瓦登可以想<br>象接下来会发生什么，阿尔特弥斯他们的每一句话都被有关部门记录下来，会有机<br>器统计出到底有多少违禁词汇被他们使用过；然后联邦警察会冲进她的屋子，将正<br>在聚会的成员们都带走，只留下搜查过后空荡荡的房间和窗户。</p>
<p>　　阿瓦登想到这里，心如刀绞，他一点也不为自己的侥幸逃脱而感到幸运。他的<br>胃袋翻腾起来，一种恶心的感觉从胃里直接升到嘴边，让他想吐，却又不能吐——<br>因为“呕”也是个敏感词汇；大病初愈的孱弱身躯无法承受这种打击，象害了风寒<br>一样颤抖起来，几乎站立不住。</p>
<p>　　他不敢继续朝前走去，仓皇地转过身去，登上另外一辆公共汽车，把嘴闭的更<br>紧了。等阿瓦登回到自己家楼下，看到楼房附近另外一架新的主动式旁观者正在兴<br>建中，漆黑的天线在半空舒展开来，仿佛一面巨大的蜘蛛网。看来有关部门已经着<br>手在整个纽约市部署这种新兴高科技产品。</p>
<p>　　他不敢驻足观看，低着头从那巨大装置旁边走过，一路不停地走回家，然后把<br>自己的脸紧紧地压在枕头里，却不敢哭出声音来，连一句“FUXKYOU, YOUSONOFBIT<br>CH”都不能说。</p>
<p>　　从那以后，阿瓦登的生活回到了普通状态——就是说和原来一样沉滞、压抑、<br>欠缺激情，健康向上，缺乏低级趣味。兰斯洛特说过：“战争的结果就是，大众的<br>自由意识会将语言推向死亡的边缘”，现在看来，他的预言是很准确的：说话会的<br>覆灭，导致“说话”、“歌剧”、“完全”、“交流”几个词先后被剔除出了健康<br>词汇列表，成为敏感词汇。</p>
<p>　　另外，虽然阿拉伯数字还能用，但“1984”这一个数字组合也被屏蔽掉了，这<br>让包括阿瓦登在内的程序员在编写程序时不得不谨慎地检查数字是否违规，这额外<br>增加了很多工作量，让他更加疲惫。</p>
<p>　　阿瓦登不是没有担心过，也许在某一天的深夜，他就会忽然接到一封EMAIL，让<br>他留在家里不要动，不要试图在网络做任何动作；接着电话会响起，电子女声会把<br>这一要求重复再重复，直到警察打开他家的大门，把他带去未知的地方，那里有未<br>知的命运等待着他。《1984》后面的情节发展阿瓦登始终不知道，唯一知道的杜拉<br>丝已经彻底失踪了，所以温斯顿和朱丽亚的结局始终是个谜；就好象兰斯洛特、瓦<br>格纳、杜拉丝和阿尔特弥斯的结局一样，也不从得知。其实这两件事对于阿瓦登来<br>说没什么本质性的区别，所以它们也可以看做是同一个谜。</p>
<p>　　其实他最担心的，是阿尔特弥斯。每次想到这个名字，阿瓦登就难以抑制心中<br>的郁闷。她究竟会怎么样，彻底被屏蔽掉吗？如果是那样，那么她在这世界上遗留<br>下来的唯一痕迹，就是一个程序员记忆里的假名而已了。</p>
<p>　　说话会消失后三个星期，仍旧风平浪静，没有任何人来找过阿瓦登，他也没收<br>到过任何类似内容的EMAIL，阿瓦登一直在想，也许是他们没有吐露出自己的下落，<br>也可能是因为他们根本不知道——他们认识的只是一个叫王二的程序员。这个城市<br>里有数以千计的程序员，而王二是个假名。</p>
<p>　　因此，生活一如既往地平静。不，确切地说，还是有一点不同的，那就是互联<br>网络健康词汇列表：那上面的词组消失的速度比以前要快的快，每小时每分钟都有<br>词与单字飞快地在名单上消失，阿瓦登不得不花上大量时间去更新列表，以跟紧当<br>前形势。</p>
<p>　　与词汇列表更新速度相对的，EMAIL和网络论坛上的东西越来越乏味。因为人们<br>不得不用极有限的词去表达广泛的意思，大家都变得寡言少语。就连那些秘密的暗<br>语和联系方式也少了许多；整个网络就象是前些天阿瓦登家里出了问题的暖气片一<br>样：虽然名义上是给人带来温暖的东西，但却变的冰冷、僵硬，让人如坠冰窟。</p>
<p>　　这一天，阿瓦登从电脑前抬起头来，他看了看窗外迷茫的灰色天空，胸口一阵<br>抽搐，不由得痛苦地咳了一声。他拿起塑料杯，将杯子里的纯净水一饮而尽，杯子<br>丢进同样是塑料质地的垃圾桶里，发出钝钝的撞击声，他觉得自己的脑子也是一团<br>垃圾，举起手敲了敲，果然发出同样钝钝的撞击声。</p>
<p>　　然后他拿起大衣，戴上墨绿色的护目镜，走出门去。阿瓦登没带便携式的旁观<br>者，那东西已经不需要了，城市里到处都是主动式的旁观者，随时监听是否有违禁<br>词汇的存在。整个纽约现在就象是互联网络一样，被有关部门营造成十分健康。</p>
<p>　　阿瓦登这一次外出是有正当理由的，他决定去取消网络论坛服务，这服务已经<br>用不着了，因为无论EMAIL，新闻组，BBS论坛还是其他什么现在全部都变成了一样<br>的东西。</p>
<p>　　从日历来说现在应该是春季，但外面还是很冷，高大的灰色建筑矗立在平地上<br>，仿佛绝对零度下的石林。大团大团的风裹着黄沙与废气穿行其间，风沙无处不在<br>，让人置身其中而难以摆脱。阿瓦登把手揣进兜里，脖子缩进领口，畏缩着向网络<br>部的大楼走去。</p>
<p>　　忽然，他停下了脚步，惊讶地站在原地无法动弹。他看到阿尔特弥斯正站在前<br>面的路灯下，穿着黑色的制服。可是她的变化有多么大啊，面容象是老了十岁，满<br>脸都是衰老的皱纹，年轻的活力荡然无存；她听到脚步声，转过头来，两个乌黑的<br>大眼睛显得异常空洞，目光越过阿瓦登延伸到远方，没有一个明晰的焦点。</p>
<p>　　阿瓦登万万没有想到会在这个时间这个地点碰到她，这让他已经沉寂已久的心<br>灵泛起了几点火花，可惜他迟钝的神经已经无法表达出“激动”这一个简单的情感<br>了。两个人互相对视了一阵，他终于木然走到她身边，张了张嘴唇，想对她说些什<br>么。但是他掏出今天新发布的健康词汇列表，发现上面是一片空白——终于连最后<br>一个词组也被有关部门屏蔽了。<br>　于是阿瓦登只好保持着沉默，默默地与面无表情的她擦肩而过，继续向前走去<br>。他的身影逐渐融入同样安静的灰色人群之中，整个城市都显得寂静极了。</p>
</blockquote>
<p>全文完。</p>
]]></content>
  </entry>
  <entry>
    <title>消息的可靠投递</title>
    <url>/2021/04/13/reliable-message-delivery/</url>
    <content><![CDATA[<p>在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递<span id="more"></span>,即：不能丢消息。</p>
<h3 id="MQ消费术语"><a href="#MQ消费术语" class="headerlink" title="MQ消费术语"></a>MQ消费术语</h3><pre><code>为了保证保证消息的可靠投递，先了解一下MQ的消费术语
</code></pre>
<ul>
<li><p>At Lest Once(至少一次)<br> 消息在消费的过程中，至少被发送到一个consumer; 如果consumer处理失败，会再次发送到consumer； 所以消息可能会重复被消费，通常会要求consumer保证幂等性</p>
</li>
<li><p>At Most Once(至多一次)<br> 消息在消费的过程中，至多被一个consumer消费; 如果consumer处理失败，消息可能会丢失；只能用于可接受消息丢失的场景  </p>
</li>
<li><p>Exactly Once(仅有一次)<br>发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。常用MQ产品没有太多理想的实现 。</p>
</li>
</ul>
<h3 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h3><p>我们以<a href="https://www.rabbitmq.com/">RabbitMQ</a>为例从以下几个方面保证说明如何实现消息的可靠投递</p>
<h4 id="消息中间件可靠性"><a href="#消息中间件可靠性" class="headerlink" title="消息中间件可靠性"></a>消息中间件可靠性</h4><ul>
<li>使用RabbitMQ的集群模式，basic模式和镜像模式都可以保证消息不丢失；根据业务特点在吞吐量和高可用之间权衡选择合适的集群模式</li>
<li>确保exchange和queue的持久化<h4 id="生产端可靠性"><a href="#生产端可靠性" class="headerlink" title="生产端可靠性"></a>生产端可靠性</h4></li>
<li>发送消息时候设置消息持久化属性<strong>DeliverModel</strong> </li>
<li>消息持久化到数据库状态为发送中</li>
<li>消息到达exchange开启confirm模式，生产者发送完消息后等待broker的ack，超过一定时间没有收到broker的ack后启动job重试，直到收到broker的ack，数据库消息状态更新为已发送</li>
<li>消息未到达队列开启回退机制，如果消息从exchange无法投递到队列，回调通知调用者，调用者可以重试<h4 id="消费端的可靠性"><a href="#消费端的可靠性" class="headerlink" title="消费端的可靠性"></a>消费端的可靠性</h4></li>
<li>消费端确保消息处理逻辑的幂等性</li>
<li>关闭自动ack</li>
<li>消费端每处理完一次消息后手动回复ack; 如果处理消息程失败回复nack, 默认情况下broker会继续下发消息直到消费成功；注意：消息处理失败必须回复nack，否则broker认为该consumer节点down，不再下发消息到该节点</li>
</ul>
<h4 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h4><p>对中间件，存储系统，应用等增加监控，在出现问题的时候能第一时间发现</p>
<p>综上所述，为了保证消息的可靠投递我们需要从开发和运维的角度去考虑；确保每一个环节都能可靠。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
</search>
