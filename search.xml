<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Biometric-Based Payment Product</title>
    <url>/2025/04/26/Biometric-Based-Payment-Product/</url>
    <content><![CDATA[<p>前一段时间完成了一个基于生物识别技术的支付产品方案设计。该方案旨在通过生物特征识别（如掌静脉扫描）实现无需手机的便捷支付体验，为用户和商户提供更加安全、高效的支付解决方案。经过对敏感信息的脱敏处理，我将这个方案的核心设计理念、系统架构和关键流程记录下来，希望能为对类似技术感兴趣的读者提供一些参考和启发。本文将详细介绍该支付产品的目标、核心功能、系统架构以及交互流程，展示如何将生物识别技术与支付系统有机结合，打造一个既安全又便捷的支付生态系统。<span id="more"></span></p>
<p>在技术快速迭代的今天，生物识别支付代表了未来支付方式的重要发展方向之一。通过这篇文章，我希望能分享这一领域的一些思考和实践经验。</p>
<h1 id="Biometric-Based-Payment-Product"><a href="#Biometric-Based-Payment-Product" class="headerlink" title="Biometric-Based Payment Product"></a>Biometric-Based Payment Product</h1><h2 id="1-Project-Overview"><a href="#1-Project-Overview" class="headerlink" title="1. Project Overview"></a>1. Project Overview</h2><p>This project aims to provide an innovative, convenient, and secure payment solution for users, allowing them to make payments without a phone using biometric features (such as palm vein scanning). The product will integrate payment API and biometric capture technology from a partner vendor to deliver a new payment experience for users and an efficient and secure method of receiving payments for merchants. </p>
<h2 id="2-Project-Goals"><a href="#2-Project-Goals" class="headerlink" title="2. Project Goals"></a>2. Project Goals</h2><ul>
<li>To provide users with a convenient way to make payments without a phone</li>
<li>To enhance payment security and reduce the risk of fraud through multi-factor authentication</li>
<li>To simplify the payment process and improve transaction efficiency</li>
<li>To offer merchants a modern method of receiving payments with real-time settlement</li>
<li>To comply with local payment regulatory requirements and data protection standards</li>
<li>To ensure system scalability and high availability</li>
</ul>
<h2 id="3-Product-Core-Feature-List"><a href="#3-Product-Core-Feature-List" class="headerlink" title="3. Product Core Feature List"></a>3. Product Core Feature List</h2><h4 id="3-1-User-Features"><a href="#3-1-User-Features" class="headerlink" title="3.1 User Features:"></a>3.1 User Features:</h4><ul>
<li>User account registration with multi-factor authentication</li>
<li>Biometric feature (e.g., palm vein) capture and secure encryption</li>
<li>Initiating payments by scanning biometric features at participating merchants</li>
<li>Real-time payment notifications (via biometric capture device, APP, SMS, Email, WhatsApp Message)</li>
<li>Detailed transaction history with advanced filtering (via App)</li>
<li>Comprehensive user account management (card binding, password change, security settings)</li>
<li>Emergency account freeze functionality</li>
</ul>
<h4 id="3-2-Merchant-Features"><a href="#3-2-Merchant-Features" class="headerlink" title="3.2 Merchant Features:"></a>3.2 Merchant Features:</h4><ul>
<li>Real-time payment processing and confirmation</li>
<li>Automated refund processing with approval workflow</li>
<li>Flexible settlement cycles (T+0, T+1) with detailed reporting</li>
<li>Advanced transaction search and export capabilities</li>
<li>Detailed settlement reports and reconciliation tools</li>
<li>Merchant profile and branch management</li>
<li>Custom payment limit settings</li>
<li>Integration with existing POS systems</li>
</ul>
<h4 id="3-3-System-Management-Features"><a href="#3-3-System-Management-Features" class="headerlink" title="3.3 System Management Features:"></a>3.3 System Management Features:</h4><ul>
<li>Centralized user account management with audit trails</li>
<li>Real-time transaction monitoring and fraud detection</li>
<li>Device health monitoring and remote management</li>
<li>Configurable system parameters and business rules</li>
<li>Comprehensive reporting with data visualization</li>
<li>System performance monitoring and alerts</li>
<li>Audit logging for all critical operations</li>
<li>Automated backup and disaster recovery</li>
</ul>
<h2 id="4-System-Architecture"><a href="#4-System-Architecture" class="headerlink" title="4 System Architecture"></a>4 System Architecture</h2><p>To serve 500k users with room for growth, this system involves the following enhanced components:</p>
<ul>
<li><strong>Biometric Capture Device:</strong> Secure biometric capture with encryption and matching capabilities</li>
<li><strong>User App:</strong> The main entry point for user registration, account management, transaction viewing, etc.</li>
<li><strong>User Backend System:</strong> core business logic processing center, responsible for user management, biometric data management, interaction with Tap API, transaction processing, security control, etc.</li>
<li><strong>Payment API:</strong> Used to process actual payment transactions, including fund deduction and settlement.</li>
<li><strong>Merchant Backend (Web):</strong> The main entry point for merchants to receive payments, view transaction records, etc.</li>
<li><strong>Admin Backend (Web):</strong> Used by system administrators to manage system, generate reports, etc.</li>
<li><strong>Job Service:</strong> Used for scheduled tasks, such as payment reconciliation，data compensation, etc.</li>
<li><strong>Database:</strong> Used to store user information, transaction records, etc.(maybe master-slave architecture)</li>
<li><strong>Message Queue:</strong> Used for asynchronous message processing, such as payment notification, etc.</li>
<li><strong>Cache Layer:</strong> Distributed caching for performance optimization</li>
<li><strong>Monitoring System:</strong> Real-time system monitoring and alerting</li>
</ul>
<p>In order to ensure the system’s scalability and high availability, the system deployment is implemented as described below:</p>
<pre class="mermaid">flowchart TB
    subgraph payment gateway
        Payment-Gateway[third-payment-gateway] 
    end

    subgraph Storage
        MySQL[RDS-MySQL] 
        Redis[Redis]
    end
    
    subgraph MessageQueue
        MQ[RabbitMQ]
    end

    subgraph backend
        BackendService[backend-service] -->|JDBC| MySQL
        BackendService -->|Redis API| Redis
        BackendService -->|API| Payment-Gateway
        BackendService -->|send| MQ
        Payment-Gateway -.->|async| BackendService
    end

    subgraph user
        App[App] -->|REST API| BackendService
        BiometricDevice[biometric-device] --> BackendService
    end

    subgraph merchant
        WebMerchant[Merchant-UI] -->Merchant-Service
        Merchant-Service-->|JDBC| MySQL
        Merchant-Service-->|Redis API| Redis
    end

    subgraph operation admin
        WebAdmin[Admin-UI] -->Admin-Service
        Admin-Service-->|JDBC| MySQL
        Admin-Service-->|Redis API| Redis
    end
    
    subgraph job
        Job-Service -->|JDBC| MySQL
        Job-Service -->|Redis API| Redis
        Job-Service -.->|consume| MQ
    end</pre>

<h2 id="5-Core-Interactive-Process"><a href="#5-Core-Interactive-Process" class="headerlink" title="5. Core Interactive Process"></a>5. Core Interactive Process</h2><h4 id="5-1-Registration"><a href="#5-1-Registration" class="headerlink" title="5.1 Registration"></a>5.1 Registration</h4><pre class="mermaid">sequenceDiagram
    participant User
    participant App
    participant BackendService
    participant BiometricDevice

    User->>App: Initiate Registration Request
    App->>BackendService: Send Registration Request (User Information)
    BackendService->>BiometricDevice: Request Biometric Capture
    BiometricDevice->>User: Prompt User for Biometric Capture
    User->>BiometricDevice: Complete Biometric Capture
    BiometricDevice->>BackendService: Send Biometric Data
    BackendService->>Database: Store User Information and Biometric Information
    Database-->>BackendService: Return Storage Result
    BackendService-->>App: Return Registration Success Information
    App->>User: Display Registration Success</pre>

<h4 id="5-2-Link-Bank-Card"><a href="#5-2-Link-Bank-Card" class="headerlink" title="5.2 Link Bank Card"></a>5.2 Link Bank Card</h4><pre class="mermaid">sequenceDiagram
    participant User
    participant App
    participant BackendService
    participant Tap as Payment API

    User->>App: Initiate Card Linking
    App->>BackendService: Request Card Linking Initiation (User ID)
    BackendService->>App: Instruct App to Present Payment's Secure Form
    App->>User: Display Payment's Secure Card Input Form
    User->>App: Enter Bank Card Details
    App->>Tap: Send Card Details Securely (via SDK or Payment Page)
    Tap-->>App: Return Card Token
    App->>BackendService: Send Card Token and User ID
    BackendService->>Database: Associate Card Token with User Account
    Database-->>BackendService: Return Association Result
    BackendService-->>App: Return Card Linking Success Confirmation
    App->>User: Display "Card Linked Successfully"</pre>

<h4 id="5-3-Payment"><a href="#5-3-Payment" class="headerlink" title="5.3 Payment"></a>5.3 Payment</h4><pre class="mermaid">sequenceDiagram
    participant User
    participant BiometricDevice
    participant BackendService
    participant Tap as Payment API

    User->>BiometricDevice: Initiate Payment Request
    BiometricDevice->>BackendService: Send Payment Request (Device ID, May Contain Initial User Identification)
    BackendService->>BiometricDevice: Request Biometric Verification
    BiometricDevice->>User: Prompt User for Biometric Verification
    User->>BiometricDevice: Complete Biometric Verification
    BiometricDevice->>BackendService: Send Biometric Data
    BackendService->>Database: Query User Biometric Information
    Database-->>BackendService: Return User Biometric Information
    alt Verification Successful
        BackendService->>Database: Retrieve User's Card Token
        Database-->>BackendService: Return Card Token
        BackendService->>Tap: Initiate Payment Request (Amount, Card Token, Merchant ID, etc.)
        Tap-->>BackendService: Return Payment Result
        BackendService->>BiometricDevice: Return Payment Success Information
        BiometricDevice->>User: Display Payment Success
    else Verification Failed
        BackendService->>BiometricDevice: Return Payment Failure Information
        BiometricDevice->>User: Display Payment Failure
    end</pre>

<h2 id="6-Security-and-Compliance-Considerations"><a href="#6-Security-and-Compliance-Considerations" class="headerlink" title="6. Security and Compliance Considerations"></a>6. Security and Compliance Considerations</h2><h4 id="6-1-Data-Security"><a href="#6-1-Data-Security" class="headerlink" title="6.1 Data Security"></a>6.1 Data Security</h4><ul>
<li>End-to-end encryption for biometric data storage and transmission</li>
<li>Strict access control mechanisms for sensitive data</li>
<li>Separation of biometric data from user identity information</li>
<li>Regular security audits and penetration testing</li>
<li>Multi-layered security architecture with defense-in-depth approach</li>
</ul>
<h4 id="6-2-Compliance"><a href="#6-2-Compliance" class="headerlink" title="6.2 Compliance"></a>6.2 Compliance</h4><ul>
<li>Adherence to payment industry regulations and standards (PCI DSS)</li>
<li>Compliance with data protection regulations (GDPR or local equivalents)</li>
<li>Implementation of comprehensive user privacy protection mechanisms</li>
<li>Complete compliance audit trail to meet regulatory requirements</li>
<li>Regular compliance reviews and updates</li>
</ul>
<h2 id="7-Performance-and-Scalability"><a href="#7-Performance-and-Scalability" class="headerlink" title="7. Performance and Scalability"></a>7. Performance and Scalability</h2><h4 id="7-1-Performance-Metrics"><a href="#7-1-Performance-Metrics" class="headerlink" title="7.1 Performance Metrics"></a>7.1 Performance Metrics</h4><ul>
<li>Transaction response time: Average &lt;1 second, 99% of transactions &lt;3 seconds</li>
<li>System throughput: Peak capacity of 100+ transaction requests per second</li>
<li>System availability: 99.99% uptime (less than 1 hour of unplanned downtime annually)</li>
<li>Data consistency: Ensuring integrity and consistency of all transaction data</li>
<li>Biometric matching accuracy: False acceptance rate &lt;0.001%, false rejection rate &lt;1%</li>
</ul>
<h4 id="7-2-Scalability-Strategy"><a href="#7-2-Scalability-Strategy" class="headerlink" title="7.2 Scalability Strategy"></a>7.2 Scalability Strategy</h4><ul>
<li>Automated elastic scaling based on load patterns</li>
<li>Capacity planning for 300% growth over the next 2 years</li>
</ul>
<h2 id="8-Implementation-and-Operations"><a href="#8-Implementation-and-Operations" class="headerlink" title="8. Implementation and Operations"></a>8. Implementation and Operations</h2><h4 id="8-1-Implementation-Roadmap"><a href="#8-1-Implementation-Roadmap" class="headerlink" title="8.1 Implementation Roadmap"></a>8.1 Implementation Roadmap</h4><ul>
<li>Phase 1: Core payment functionality development and testing (2 months)</li>
<li>Phase 2: Merchant management system and settlement functionality (1 months)</li>
<li>Phase 3: Pilot deployment and optimization (1 months)</li>
<li>Phase 4: Full-scale rollout and continuous improvement (ongoing)</li>
</ul>
<h4 id="8-2-Operational-Strategy"><a href="#8-2-Operational-Strategy" class="headerlink" title="8.2 Operational Strategy"></a>8.2 Operational Strategy</h4><ul>
<li>24&#x2F;7 monitoring system with real-time alerts</li>
<li>Automated deployment and rollback mechanisms</li>
<li>Comprehensive logging and analytics system</li>
<li>Detailed disaster recovery plan with regular testing</li>
<li>Continuous performance optimization and capacity planning</li>
</ul>
<h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><p>以上是这个项目的完整方案，该方案通过整合生物识别技术与支付API，为用户提供了一种无需手机即可完成支付的便捷方式。系统架构设计充分考虑了安全性、可扩展性和高可用性，能够支持大规模用户群体的使用需求。</p>
<p>通过实施这一支付解决方案，我们期望能够：</p>
<ul>
<li>为用户提供更加便捷、安全的支付体验</li>
<li>为商户提供更加高效、可靠的收款方式</li>
</ul>
<p>未来，我们计划进一步优化系统性能，扩展更多场景应用，如将生物识别支付技术应用于多个领域。同时，我们也将持续关注生物识别技术的发展，探索更多创新的支付解决方案，为用户和商户创造更大的价值。</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Memcached集群迁移至Redis集群</title>
    <url>/2023/09/09/Data-Memcached-To-Redis/</url>
    <content><![CDATA[<p>随着业务规模的增长，我们的缓存系统面临扩展性和运维效率的挑战。近期我们团队将缓存系统从Memcached迁移到Redis集群。<span id="more"></span></p>
<h2 id="项目背景与迁移动机"><a href="#项目背景与迁移动机" class="headerlink" title="项目背景与迁移动机"></a>项目背景与迁移动机</h2><p>我们的缓存系统最初基于Memcached，性能表现稳定，但随着业务发展，Memcached的局限性逐渐暴露：</p>
<ul>
<li><strong>扩展性受限</strong>：Memcached集群不支持自动分片，扩容和缩容需客户端手动实现，操作繁琐且运维成本高，难以应对流量快速增长。</li>
<li><strong>监控能力薄弱</strong>：Memcached提供的指标有限（仅命中率、内存使用等），故障排查和告警不便，影响问题定位效率。</li>
<li><strong>数据类型单一</strong>：仅支持键值对，复杂业务需求需额外开发支持，效率低下。</li>
</ul>
<p>这些问题促使我们寻找替代方案，最终选择了Redis集群。迁移的目标不是提升性能，而是解决扩展性和监控问题，为未来发展预留空间。</p>
<h2 id="技术选型：为什么选择Redis集群"><a href="#技术选型：为什么选择Redis集群" class="headerlink" title="技术选型：为什么选择Redis集群"></a>技术选型：为什么选择Redis集群</h2><p>我们直接选择了Redis集群，原因如下：</p>
<ul>
<li><strong>成熟度</strong>：Redis的社区拥有丰富文档和活跃支持，而且我们团队在其他项目中的使用已非常成熟。</li>
<li><strong>功能优势</strong>：支持自动分片、丰富数据结构（如Hash、List）和内置监控，弥补Memcached的不足。</li>
<li><strong>团队熟悉</strong>：团队对Redis的开发和运维经验丰富，降低了学习成本。</li>
</ul>
<h2 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h2><p>迁移分为几个阶段，确保无侵入且风险可控：</p>
<ol>
<li><strong>代码改造</strong>：<ul>
<li>通过底层SDK适配Redis集群，封装缓存操作接口（<code>get</code>、<code>set</code>），业务代码无需改动。</li>
<li>配置动态切换缓存后端（Memcached或Redis）。</li>
</ul>
</li>
<li><strong>测试验证</strong>：<ul>
<li>模拟业务场景验证功能正确性。</li>
<li>测试Redis集群的扩容&#x2F;缩容，确保无影响。</li>
</ul>
</li>
<li><strong>灰度发布</strong>：<ul>
<li>从5%流量开始，逐步增至20%，观察一周后全量切换。</li>
<li>按用户维度区分流量，避免数据一致性问题。</li>
</ul>
</li>
<li><strong>数据过渡</strong>：<ul>
<li>新请求写入Redis，旧数据在Memcached过期，无需显式迁移。这种策略能有效降低迁移复杂性。但对于某些关键缓存数据，可能需要更谨慎的迁移方案。</li>
</ul>
</li>
<li><strong>监控支持</strong>：<ul>
<li>使用Prometheus和Grafana，从测试到全量全程监控Redis和业务指标。关键监控指标包括Redis的CPU使用率、内存使用率、连接数、命中率、Key的数量，以及业务相关的错误率、请求量等。</li>
</ul>
</li>
</ol>
<h2 id="挑战与解决方案"><a href="#挑战与解决方案" class="headerlink" title="挑战与解决方案"></a>挑战与解决方案</h2><p>迁移中暴露了三个主要挑战，我们逐一解决：</p>
<ol>
<li><strong>大Key问题</strong>：<ul>
<li><strong>挑战</strong>：Memcached节点内存大，大Key不明显；Redis集群分片内存小，大Key导致负载不均。</li>
<li><strong>解决方案</strong>：将大Key拆分为多个小Key（如<code>user:123</code>拆为<code>user:123:profile</code>），均匀分布。</li>
<li><strong>效果</strong>：内存使用率从100%降至50%。</li>
</ul>
</li>
<li><strong>热Key问题</strong>：<ul>
<li><strong>挑战</strong>：Redis分片配置低，热Key高频访问导致QPS激增。</li>
<li><strong>解决方案</strong>：引入本地缓存（TTL 1分钟），允许短暂不一致，优先从本地读取。</li>
<li><strong>效果</strong>：Redis负载减少80%。</li>
</ul>
</li>
<li><strong>JVM崩溃</strong>：<ul>
<li><strong>挑战</strong>：在流量高峰时JVM崩溃，因为系统内部使用Redisson依赖的netty与gRPC依赖的netty版本冲突。</li>
<li><strong>解决方案</strong>：升级Redisson到最新版。</li>
<li><strong>效果</strong>：崩溃问题消失。</li>
</ul>
</li>
</ol>
<h2 id="迁移成果"><a href="#迁移成果" class="headerlink" title="迁移成果"></a>迁移成果</h2><ul>
<li><strong>性能与稳定性</strong>：<ul>
<li>迁移后性能和稳定性与Memcached持平，未见提升，因目标非性能优化。</li>
<li>压测显示两者在20万QPS下表现相当。</li>
</ul>
</li>
<li><strong>用户体验</strong>：<ul>
<li>页面加载时间和服务稳定性无变化，用户无感知反馈。</li>
</ul>
</li>
<li><strong>实际价值</strong>：<ul>
<li><strong>扩展性</strong>：Redis集群支持动态扩容，解决了Memcached的瓶颈。</li>
<li><strong>监控性</strong>：丰富指标提升了运维效率。</li>
</ul>
</li>
</ul>
<h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol>
<li><strong>无侵入SDK</strong>：降低风险，业务代码稳定。</li>
<li><strong>灰度发布</strong>：分阶段切换，问题可控。</li>
<li><strong>关闭持久化</strong>：提升性能，适配需求。为了追求更高的读写性能，我们选择关闭了Redis的持久化功能。在生产环境中，需要根据具体的业务场景权衡是否开启持久化以及选择合适的持久化策略。</li>
<li><strong>全面监控</strong>：实时反馈，快速响应。</li>
<li><strong>聚焦扩展性</strong>：明确目标，预留潜力。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次迁移让我们从Memcached的局限中解脱，Redis集群为未来增长奠定了基础。虽然性能未提升，但扩展性和监控能力的改善达到了预期。关于成本方面，迁移到Redis集群可能会带来一定的服务器成本增加，但运维效率的提升有望在长期降低总体成本。</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>基于配置中心属性,Dubbo Consumer动态切换调用RPC/本地方法</title>
    <url>/2018/07/06/Dubbo-Local-RPC-Switch/</url>
    <content><![CDATA[<h2 id="需求缘由"><a href="#需求缘由" class="headerlink" title="需求缘由"></a>需求缘由</h2><p>最近部分只读服务已经切换到了Dubbo提供的服务化接口；经过一段时间的生产验证, 各种监控指标显示非常稳定，所以打算开始切换写服务接口; 但大家对写操作跑服务化没有信心，于是提了一个需求能随时将远程rpc调用切换打本地jar方法调用；<span id="more"></span></p>
<h2 id="dubbo的stub"><a href="#dubbo的stub" class="headerlink" title="dubbo的stub"></a>dubbo的stub</h2><p>听到这个需求，马上想到dubbo的stub属性；但需要在原来代码中做部分改造,具体步骤是：</p>
<ol>
<li>原来的jar包实现方法中增加带自身接口类型参数的构造函数;</li>
<li>在所有的接口实现方法中判断开关状态决定调用RPC&#x2F;本地方法;<br>但是，这样对原代码有极强入侵性；我们认为这不是最好的方案，于是有了下面的方案；</li>
</ol>
<h2 id="扩展dubbo-reference标签属性"><a href="#扩展dubbo-reference标签属性" class="headerlink" title="扩展dubbo:reference标签属性"></a>扩展dubbo:reference标签属性</h2><p>首先需要说明，我们在实际使用dubbo的过程中并没有直接使用dubbo这个命名空间，而是自定义了自己的命名空间，自定义命名空间兼容了dubbo命名空间的所有属性，而且扩展了自己的属性；于是针对该需求我们有了新的方案，具体流程如下 ：</p>
<ol>
<li>增加<strong>reference</strong>的属性<strong>localbean</strong>，这个属性值为一个本地bean的id；类似的xml配置如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localDemoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Service.impl.DemoServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mydubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.example.Service.DemoService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remoteDemoService&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">localbean</span> =<span class="string">&quot;localDemoService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>继承ReferenceBean实现自定义属性locbean；</li>
<li>继承DubboNamespaceHandler重写init方法,如下:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init();</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyBeanDefinitionParser</span>(LocalReferenceBean.class, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>自定义filter</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCLocalSwitchFilter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RPCLocalSwitchFilter.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ProxyFactory</span> <span class="variable">PROXY_FACTORY</span> <span class="operator">=</span> (ProxyFactory)ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCLocalSwitchFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span>(cfg.getBooleanProperty(<span class="string">&quot;&quot;</span>)) &#123;  <span class="comment">//判断配置中心开工状态</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="built_in">this</span>.getLocalBean(invoker);</span><br><span class="line">            <span class="keyword">return</span> bean != <span class="literal">null</span>?<span class="built_in">this</span>.executeLocalMethod(bean, invoker, invocation):invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Result <span class="title function_">executeLocalMethod</span><span class="params">(T bean, Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;execute local method instead of rpc &quot;</span> + bean.getClass().getCanonicalName() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">localInvoker</span> <span class="operator">=</span> PROXY_FACTORY.getInvoker(bean, invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        <span class="keyword">return</span> localInvoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">getLocalBean</span><span class="params">(Invoker&lt;?&gt; invoker)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">refLocal</span> <span class="operator">=</span> invoker.getUrl().getParameter(<span class="string">&quot;localBean&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(refLocal != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">e</span> <span class="operator">=</span> LocalReferenceBean.getSpringContext();</span><br><span class="line">                <span class="keyword">return</span> e.getBean(refLocal, invoker.getInterface());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">                logger.error(var4.getMessage() + <span class="string">&quot; couldn\&#x27;t find the bean[&quot;</span> + localBean + <span class="string">&quot;], please check&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>配置filter<br>在resources&#x2F;META-INF&#x2F;dubbo&#x2F;com.alibaba.dubbo.rpc.Filter文件中增加如下内容:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reflocal=com.example.filter. RPCLocalSwitchFilter</span><br></pre></td></tr></table></figure>
配置consumer的filter属性<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mydubbo:consumer</span> <span class="attr">filter</span>=<span class="string">&quot;reflocal&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
至此可以通过配置中的开关状态来控制远程RPC&#x2F;本地jar方法调用 ;</li>
</ol>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>在线工具集合网站</title>
    <url>/2024/11/15/First-Efficiency-Lab/</url>
    <content><![CDATA[<p>在日常开发项目中，我们经常需要处理格式转换、日期计算、编码解码等基础操作。这些任务要么需要在开发环境中编写代码实现，要么需要在网上搜索对应的在线工具。为了提高工作效率，我整合了一系列常用工具，并将它们集成到这个网站中：<a href="https://labs.yzhu.name/">https://labs.yzhu.name</a> <span id="more"></span></p>
<p>该网站目前提供了以下几个工具:</p>
<h3 id="日期计算器"><a href="#日期计算器" class="headerlink" title="日期计算器"></a><a href="https://labs.yzhu.name/date-calc.html">日期计算器</a></h3><p>计算日期天数差、增减天数以及查找特定日期,常用于处理与日期相关的业务需求。</p>
<h3 id="单位转换器"><a href="#单位转换器" class="headerlink" title="单位转换器"></a><a href="https://labs.yzhu.name/unit-conv.html">单位转换器</a></h3><p>帮助进行英制和公制单位之间的自由转换,如常用的长度、重量、体积、温度等维度。</p>
<h3 id="JSON格式化"><a href="#JSON格式化" class="headerlink" title="JSON格式化"></a><a href="https://labs.yzhu.name/json-format.html">JSON格式化</a></h3><p>将JSON数据格式化成有层级缩进的样式,或将格式化后的JSON转成单行,方便发现JSON语法错误。</p>
<h3 id="编-解码工具"><a href="#编-解码工具" class="headerlink" title="编&#x2F;解码工具"></a><a href="https://labs.yzhu.name/encode.html">编&#x2F;解码工具</a></h3><p>使用常见的Base64、MD5、SHA等多种编码解码算法对文本进行转换,适用于加解密、哈希处理等需求。</p>
<h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a><a href="https://labs.yzhu.name/timestamp.html">Unix时间戳转换</a></h3><p>将Unix时间戳转成可读的时间格式,或通过年月日等输入获取对应的时间戳。</p>
<h3 id="YAML-JSON转换"><a href="#YAML-JSON转换" class="headerlink" title="YAML&#x2F;JSON转换"></a><a href="https://labs.yzhu.name/yaml-json.html">YAML&#x2F;JSON转换</a></h3><p>在YAML和JSON两种格式之间双向转换,并同时支持格式化和语法验证。</p>
<h3 id="转换图片为白地图"><a href="#转换图片为白地图" class="headerlink" title="转换图片为白地图"></a><a href="https://labs.yzhu.name/image-segment.html">转换图片为白地图</a></h3><p>快速扣除商品背景，将证件照换为白地图，等场景，能够对图片进行一键抠图，快速处理。</p>
<p>这些工具的灵感大多来源于我们日常工作中的一些高频基本需求。核心目的是集中常用的小工具,提高这部分操作的效率。</p>
<p>工具地址: <a href="https://labs.yzhu.name/">https://labs.yzhu.name</a></p>
]]></content>
  </entry>
  <entry>
    <title>灰度发布过程中缓存数据一致性问题</title>
    <url>/2023/05/13/Gray-Scale-Deployment-Cache-Consistency/</url>
    <content><![CDATA[<p>灰度发布是一种常见的上线策略。如果灰度发布时间较长，且在灰度期间各分组共用缓存，那么该过程中可能会面临缓存数据一致性的挑战。本文将讨论在灰度发布过程中导致缓存数据不一致的问题和解决方案。 <span id="more"></span></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通常，我们采用了灰度发布策略来确保新功能的平稳上线。我们将用户流量分为两个组（为了描述简单，假设灰度只有两个分组）：A组和B组。在灰度发布的第一阶段，我们选择将20%的流量分配给B组，将剩余的80%分配给A组。这样可以确保新功能在一部分用户中进行测试和验证，同时保持对大多数用户的稳定性。然而，在灰度发布过程中由于代码版本的不一致，导致A组和B组的缓存数据出现了不一致的情况。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在灰度发布期间可能出现以下两个场景导致数据不一致问题：</p>
<ol>
<li><p><strong>缓存增加元素：</strong> 在B组的代码版本（v2）中，我们增加了一个缓存对象的元素，但是A组的代码版本（v1）并没有包含这个元素。这导致A组写入缓存的数据，在B组读取时无法正确反序列化，导致数据解析失败。</p>
</li>
<li><p><strong>计算逻辑变化：</strong> 缓存对象的元素（e1）是逻辑计算得出的结果，在B组的代码版本（v2）中我们修改了该元素计算逻辑，但是A组的代码版本（v1）仍是旧的计算逻辑；这导致A组写入的缓存B组读出不符合预期，而B组写入的缓存A组读出不符合预期。</p>
</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在面对这种缓存数据一致性问题时，我们采取了以下解决方案：</p>
<ol>
<li><p><strong>a&#x2F;b组缓存隔离</strong>：A&#x2F;B组分别访问不同的缓存，不同的分组可以连接不同的缓存或者不同的分组以不同的key前缀区分。然而实际情况是以上问题只会发生在极个别的缓存元素上。这种方案虽然能解决以上问题，但缓存数量会随着分组的增加而成倍增加，造成资源的严重浪费，同时缓存命中率也会下降。</p>
</li>
<li><p><strong>反序列化兼容增加的元素</strong>：基本所有的序列化&#x2F;反序列化组件都支持该功能。比如JDK自带的功能确保<code>serialVersionUID</code>保持不变即可，或者使用protobuf、json等序列化类库都可以实现。该方法虽然能解决A组写入B读取反序列化失败的问题，但B组反序列化成功仍然缺少新增加的元素。</p>
</li>
<li><p><strong>使用新key</strong>：在B组代码中使用新的key，这样A&#x2F;B组缓存可以彻底隔离。但对于某些底层数据结构，可能被上层很多缓存引用，而且是通过多级引用，开发人员容易遗漏某些key。</p>
</li>
<li><p><strong>版本控制</strong>：大致思路是每个缓存在key上携带本次变更的版本号。如果本次发布缓存元素没有变化，则版本号不变。具体实现过程如下：</p>
<ul>
<li>在Spring容器启动过程中获取所有标记<code>@Cacheable</code>注解的方法。</li>
<li>对方法返回值对象内元素按照元素类型和一定的算法计算对象code值。如果对象元素发生变化，则对象code值一定变化。如果是元素是自定义对象需要递归计算。</li>
<li>读写缓存时在缓存key增加code后缀。</li>
</ul>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后我们采用了<strong>版本控制</strong>的方案。在实施前，我们进行了充分的测试和验证，确保缓存的版本控制逻辑正确无误，并在灰度发布期间保持了缓存数据的一致性。</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
        <tag>一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探</title>
    <url>/2020/03/29/JVM-NEW/</url>
    <content><![CDATA[<p>最近经常有人跟我一起讨论JVM的相关话题，所以将以前分享过的一篇JVM的基础知识在这里分享出来，欢迎大家指正.<span id="more"></span></p>
<div class="pdfobject-container" data-target="/pdf/jvm.pdf" data-height="500px"></div>]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>基础组件升级策略与实践</title>
    <url>/2022/03/26/Infra-Component-Upgrade/</url>
    <content><![CDATA[<p>基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法； <span id="more"></span></p>
<h2 id="为什么需要基础组件"><a href="#为什么需要基础组件" class="headerlink" title="为什么需要基础组件"></a>为什么需要基础组件</h2><p>为什么我们的系统要引入基础组件，使用基础组件由什么优势,以下根据个人体会列出了几点：</p>
<ol>
<li>提高开发效率：基础组件为提供了可重用、可定制和可扩展的组件和库。通过使用这些组件，开发团队能够快速搭建系统，并在不必从头开始编写代码的情况下实现常见功能。这大大提高了开发效率，缩短了产品上线时间</li>
<li>降低开发成本：通过使用成熟的基础组件，我们能够减少自主开发和维护的工作量。这意味着可以节省开发资源，并将精力集中在增值业务和创新上。</li>
<li>统一标准和规范：基础组件有助于确保在整个系统中使用一致的标准和规范。这种一致性使得不同团队的开发人员能够更好地协同工作，并减少因为不一致性而导致的问题。例如，使用统一的redis客户端组件限制一些危险命令的使用。</li>
<li>提升系统可靠性和稳定性：基础组件经过专业的设计和测试，通常具有高度可靠性和稳定性。它们被广泛使用和验证，可以减少系统中的错误和故障。而且，这些组件通常具有自动化的监控和错误处理机制，能够及时发现和处理潜在的问题，提高系统的稳定性。</li>
<li>解偶业务系统与中间件，平台之间的代码：提高系统的稳定性，方便维护，开发人员聚焦到业务功能开发；</li>
<li>提高管理效率，通过技术手段将操作流程规范化</li>
<li>安全性：确保系统采用安全大版本</li>
</ol>
<h2 id="为什么进行基础组件升级"><a href="#为什么进行基础组件升级" class="headerlink" title="为什么进行基础组件升级"></a>为什么进行基础组件升级</h2><ol>
<li>修复组件Bug,提高系统稳定性: 随着时间的推移,基础组件中会暴露出各种Bug,这些Bug可能会导致系统崩溃或业务异常。升级组件可以修复已知的Bug,提高系统稳定性。</li>
<li>获取最新功能特性,满足业务需要：基础组件推出新版本时,通常会提供新的功能和特性。业务需求瞬息万变,升级组件可以获得最新功能来满足业务需求。</li>
<li>改善性能,提升效率：新版本的基础组件通常在性能和效率上有改进,如增加缓存、优化算法等。升级后可以减少响应时长,提升系统吞吐量。</li>
<li>优化资源利用,降低成本：基础组件的新版本可能在资源调度和分配上进行了优化,可以提高资源利用率,降低系统运营成本。</li>
<li>提高开发效率：新版本组件通常会优化API设计,提高开发效率。同时修复Bug也可以减少开发调试时间。</li>
<li>解除对旧版的依赖：旧版本组件停止维护后,存在安全风险和兼容性问题。升级可以避免对旧版组件的依赖。</li>
<li>减少技术债务：使用了较旧版本的基础组件，可能会有技术债务积累，包括安全漏洞、性能瓶颈等；升级基础组件是控制技术债务的重要措施之一，积压的技术债务会制约公司发展</li>
<li>处理兼容性问题: 随着系统的发展和业务的扩展，可能需要与其他系统进行集成和交互，升级基础组件可以提供更好的兼容性和互操作性；</li>
</ol>
<h2 id="升级前的准备工作"><a href="#升级前的准备工作" class="headerlink" title="升级前的准备工作"></a>升级前的准备工作</h2><p>在进行基础组件升级之前，进行充分的准备工作是至关重要的，这可以帮助确保升级过程的顺利进行并最小化潜在风险。以下是升级前需要做的一些准备工作：</p>
<ol>
<li>明确目标： 定义升级的具体目标，明确您希望通过升级实现的业务和技术目标。了解升级所需的功能、性能、安全性等需求。</li>
<li>收集现有信息： 收集关于当前系统和基础组件的详细信息，包括版本、依赖关系、功能和性能特征等。这将有助于为升级过程做出更准确的决策。</li>
<li>评估风险和影响： 识别潜在的风险和影响范围，包括与升级相关的功能中断、兼容性问题、性能下降等。评估这些风险的严重程度，以便制定应对策略。</li>
<li>数据策略： 在进行升级之前，确保对系统进行完整的备份。如果升级中出现问题，可以回滚到之前的状态。对于数据库等有状态的组件，可以创建快照； </li>
<li>制定升级计划： 制定详细的升级计划，包括升级的步骤、时间表、责任人等。确定升级过程中需要涉及的各方，并为他们提供清晰的指导。对于较大范围升级工作，可以拆分为多个里程碑，尽可能保证每个步骤影响范围降到最低；</li>
<li>制定回滚计划： 确定如何还原系统到升级前的状态，以便在紧急情况下进行干预。原则上对升级操作的每个步骤都有对应的回滚步骤，如果不能回滚的场景下必须给出快速解决的方法。</li>
<li>测试环境预演： 在测试环境中进行升级的测试预演，以模拟真实生产环境。测试环境应该尽可能地与生产环境相似，以便更准确地预测升级可能的影响。</li>
<li>性能和压力测试： 在压测环境中进行压力测试，以评估新版本基础组件在不同负载条件下的表现。这有助于预测在生产环境中可能出现的问题。</li>
<li>制定上线计划通知所有相关方</li>
<li>用户培训： 如果新版本引入了新的特性或变化，为团队成员提供培训，确保他们熟悉和适应新版本。</li>
</ol>
<h2 id="升级实践"><a href="#升级实践" class="headerlink" title="升级实践"></a>升级实践</h2><ol>
<li>版本选择： 仔细评估新版本的功能、性能和安全特性。选择与业务需求最匹配的版本，同时考虑其稳定性和用户反馈,重点关注开源社区对issue list。</li>
<li>兼容性检查： 检查新版本与现有系统的兼容性。确保新版本不会破坏现有的功能和集成。</li>
<li>测试环境验证： 在测试环境中进行升级测试，尽量模拟真实生产环境，确保测试到各种可能影响到的场景。</li>
<li>自动化测试： 针对关键业务场景和功能，创建自动化测试用例。这有助于快速验证新版本的稳定性和正确性。</li>
<li>性能测试： 在压测环境中进行压力测试，以评估新版本在不同负载条件下的表现。识别潜在的性能问题。</li>
<li>数据迁移计划： 如果升级涉及数据存储系统，制定数据迁移计划。确保数据的完整性和一致性。</li>
<li>备份和回滚： 在进行任何升级操作之前，确保对系统进行全面备份。制定回滚计划，以便在升级过程中遇到问题时能够迅速还原。</li>
<li>灰度发布： 如果条件许可尽可能采用渐进式发布策略，将新版本逐步引入生产环境，以减少风险。</li>
<li>监控和报警： 升级后留意监控和报警，以便实时监控系统的性能和稳定性，及时发现并快速解决潜在问题。</li>
</ol>
<h2 id="升级后的监测与迭代"><a href="#升级后的监测与迭代" class="headerlink" title="升级后的监测与迭代"></a>升级后的监测与迭代</h2><ol>
<li>性能监测： 持续监测系统的性能，包括响应时间、吞吐量、延迟等。比较升级前后的性能数据，确保新版本不会导致性能下降。</li>
<li>稳定性监测： 监测系统的稳定性，识别是否存在崩溃、死锁、内存泄漏等问题。及时处理并解决这些问题，以确保系统不会因此而崩溃或变得不稳定。</li>
<li>资源利用率监测： 监测服务器、内存、CPU、网络等资源的利用率。确保新版本不会导致资源耗尽。</li>
<li>错误日志报警： 关注错误日志报警，确保升级后不会出现更多错误，防止问题升级为严重故障。</li>
<li>快速响应和修复： 如果发现了严重问题，确保能够快速响应并进行修复。灵活地进行紧急发布，以解决可能影响业务的问题。</li>
<li>收集用户的反馈: 了解用户在使用新版本时遇到的问题，帮助用户解决问题或在在后续版本修复。</li>
</ol>
<h2 id="设计基础组件的注意事项"><a href="#设计基础组件的注意事项" class="headerlink" title="设计基础组件的注意事项"></a>设计基础组件的注意事项</h2><p>在设计基础组件时，有一些注意事项可以考虑，以确保其可靠性、可扩展性和易用性。以下是一些常见的注意事项：</p>
<ol>
<li>定义清晰的接口：确保组件的功能和接口定义清晰明确。这将帮助其他开发人员理解如何正确使用组件，并减少潜在的集成问题。</li>
<li>高可用性和容错性：基础组件通常是系统中不可或缺的一部分，因此必须具备高可用性和容错性。考虑使用冗余、自动故障转移和负载均衡等机制来提高系统的可用性。</li>
<li>可扩展性：设计组件时要考虑到系统未来的扩展需求。确保组件可以水平扩展，以应对增加的负载和数据量。</li>
<li>安全性：基础组件通常处理敏感数据和关键业务逻辑，因此安全性是至关重要的。实施适当的安全措施，如身份验证、访问控制和数据加密等，以保护组件免受潜在的威胁。</li>
<li>性能优化：确保组件在处理大量请求和数据时能够提供良好的性能表现。使用高效的算法和数据结构，并进行性能测试和优化，以确保组件能够满足系统的性能需求。</li>
<li>文档和日志记录：提供清晰、详细的文档和日志记录，以便开发人员和运维团队能够理解组件的工作原理和故障排查方法。</li>
<li>监控和警报：实施监控和警报机制，以及时检测和响应组件的问题。监控关键指标，并设置警报以便在出现异常情况时及时通知相关人员。</li>
<li>版本控制和发布管理：使用版本控制系统来管理组件的代码和配置，确保可追溯性和可靠的发布管理。考虑使用自动化工具和流程来简化部署和升级过程。</li>
<li>可测试性：设计组件时要考虑到测试的可行性。提供适当的接口和工具，以便开发人员能够方便地编写和运行单元测试、集成测试和端到端测试。</li>
<li>与其他组件的集成：如果组件需要与其他组件进行集成，要确保接口和数据格式的兼容性，并进行充分的集成测试，以验证组件的正确性和稳定性。</li>
<li>遵循规范：组件实现需要遵循行业设计规范和标准,以提升互操作性</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>一个三年前的Bug导致上线失败</title>
    <url>/2020/05/30/History-Bug-And-Code-Review/</url>
    <content><![CDATA[<p>上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。<span id="more"></span></p>
<h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol>
<li>17:10：开始发布B组 </li>
<li>17:20：开始出现内存，接口超时报警；开发和SA开始介入</li>
<li>17:25：认为是新版本有问题立刻回滚</li>
<li>回滚后持续半小时问题没有出现</li>
</ol>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>根据开发反馈，本次上线功能逻辑非常简单，只有20多行代码，而且测试过程中没发现任何问题；于是，大家开始review那段代码，review后得出一致多结论，该代码没问题。逻辑非常简单，只有一个地方调用了一个方法；这个方法已经存在了好你年了，而且被多个场景在调用；另外，这个方法逻辑复杂，团队内没有人了解。大家一致认为这个方法不会有问题，毕竟经历了「时间的考验」。</p>
<h3 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h3><p>在测试环境又做了一轮压力测试，一切正常。根据目前点情况看来这个bug跟数据有关；就是说，可能是某条数据触发了这个bug的临界条件.所以，我们决定在生产环境发布一台机器做测试; 这次发布后5分钟后出现了内存飙升现象,马上切掉该机器的流量而且dump Jvm内存 。</p>
<h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>拿到dump文件后立刻启动MAT分析；发现占用内存最多一个对象有3000多万个，分析该对象的调用盏都指向了同一行代码；「这段代码正是经历过时间考验的代码」。review这行代码相关部分马上发现有死循环的问题，只是满足这个条件的数据不容易出现。而这次的数据正好满足了这个条件。找到了原因，解决方法就很容易了；修改完代码review后没问题，测试，上线后一切正常；至此，该问题解决。这里可能有人会说死循环一般会首先导致CPU报警，怎么没看到我们提到CPU到问题；因为这台机器是16核CPU，所以一个核跑满并没有触发报警规则 。</p>
<h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol>
<li>必须严格执行code review，从流程上去控制</li>
<li>需要监控各项指标到同比变化</li>
</ol>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>我们总是强调code review到重要性，但执行的时候总有这样那样的原因导致落实不彻底；我不了解当时的情况，但这次的问题我相信只要做过code review是一定可以发现的。另外，我始终相信代码质量最终要依赖开发人员来保证，测试只能保证功能性问题。特别是一些非功能性的边界条件，只能依赖开发保证。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务框架选型之 Dubbo VS. Spring Cloud</title>
    <url>/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/</url>
    <content><![CDATA[<p>当前开源的微服务框架有Dubbo, Spring Cloud, Dubbox, Motan, Thrift, GRPC 等；以Dubbo和Spring Cloud使用最广，本文仅对这两个框架结合自己项目的情况进行比较。<span id="more"></span></p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><p><img src="/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/dubbo-architecture.png" alt="Dubbo 架构图"></p>
<p>从Dubbo的架构图中我们可以看出Dubbo重点是RPC框架,对应微服务相关的其它组件,如服务发现,配置管理等需要用户自己适配;</p>
<h2 id="Spring-Cloud架构"><a href="#Spring-Cloud架构" class="headerlink" title="Spring Cloud架构"></a>Spring Cloud架构</h2><p><img src="/2018/04/30/Microservice-Dubbo-VS-Spring-Cloud/diagram-distributed-systems.svg" alt="Spring Cloud架构图"></p>
<p>Spring Cloud架构中包括了微服务生态中的大部分组件，包括但不限于服务发现，配置管理，路由网关,限流熔断等</p>
<h2 id="详细比较"><a href="#详细比较" class="headerlink" title="详细比较"></a>详细比较</h2><p>我们结合自己项目的情况从10个方面对两个框架比较</p>
<h3 id="迁移成本"><a href="#迁移成本" class="headerlink" title="迁移成本"></a>迁移成本</h3><p>  现有的系统正在线上运行，所以迁移过程中不能影响现有的系统而且尽量不耽误新功能的开发；</p>
<ol>
<li>Dubbo迁移过程</li>
</ol>
<ul>
<li>分离服务接口到独立的jar包</li>
<li>在服务端xml文件中配置服务接口将服务暴露出去</li>
<li>在客户端引入接口jar包，在xml文件中引入服务端暴露的接口</li>
</ul>
<ol start="2">
<li>Spring Cloud迁移过程</li>
</ol>
<ul>
<li>为接口定义HTTP协议 </li>
<li>服务端在controller里面以rest API的方式暴露接口</li>
<li>客户端根据定义的http协议用FeignClient注解的形式定义访问接口</li>
<li>客户端代码引入FeignClient定义的协议接口</li>
</ul>
<p>由此可见，dubbo迁移不需要修改java 代码，spring cloud 需要为每个接口定义一套http协议，而且客户端需要定义访问接口</p>
<h3 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h3><p>社区支持我们参考github的数据</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>Star</td>
<td>18k+</td>
<td>2.1k+</td>
</tr>
<tr>
<td>Fork</td>
<td>12k+</td>
<td>1.1k+</td>
</tr>
<tr>
<td>Contribute</td>
<td>70+</td>
<td>130+</td>
</tr>
<tr>
<td>Open Issues</td>
<td>430+</td>
<td>380+</td>
</tr>
<tr>
<td>Close Issues</td>
<td>740+</td>
<td>1.9k+</td>
</tr>
<tr>
<td>Latest Updated</td>
<td>几个小时前，但是2014-10-30到2017-09-07断更</td>
<td>几个小时前</td>
</tr>
</tbody></table>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><ul>
<li>Dubbo服务治理不太完善</li>
<li>Spring Cloud有比较完善的服务治理组件,Zuul, Ribbon, Hystrix等</li>
</ul>
<h3 id="生态建设"><a href="#生态建设" class="headerlink" title="生态建设"></a>生态建设</h3><ul>
<li>Dubbo生态包括:   RPC框架，服务治理, 服务降级，其它相关组件可以集成第三方成熟的开源组件；</li>
<li>Spring Cloud生态包括: RPC框架，服务发现，配置服务，服务治理，服务降级，日志收集，任务管理，几乎包括了服务化相关的所有组件；</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>  Dubbo和Spring Cloud 都没有实现分布式事务 </p>
<h3 id="运维成本"><a href="#运维成本" class="headerlink" title="运维成本"></a>运维成本</h3><p>  运维需要关注以下组件</p>
<ol>
<li>服务发现</li>
</ol>
<ul>
<li>Dubbo采用Zookeeper公司有Zookeeper的使用经验</li>
<li>Spring Cloud采用Eureka,需要搭建新的eureka服务</li>
</ul>
<ol start="2">
<li>配置管理</li>
</ol>
<ul>
<li>Dubbo采用Apollo，公司已经投入生产环境</li>
<li>Spring Cloud 需要重新部署spring cloud config</li>
</ul>
<ol start="3">
<li>服务治理</li>
</ol>
<ul>
<li>Dubbo 需要独立部署Dubbo-OPS, Zipkin&#x2F;hydp&#x2F;cat</li>
<li>Spring Cloud 需要独立部署 Zuul, Zipkin<br>综上，Dubbo新部署2个组件，Sping Cloud新部署4个组件</li>
</ul>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul>
<li>Dubbo开发流程<ol>
<li>确保服务发现组件已启动</li>
<li>定义接口，生成接口jar包发布到maven仓库</li>
<li>服务端实现接口逻辑；同时客户端引入接口jar包,实现客户端逻辑, 完成自测</li>
<li>客户端服务端联调</li>
</ol>
</li>
<li>Spring Cloud开发流程<ol>
<li>确保服务发现组件已启动</li>
<li>定义http接口，形成文档</li>
<li>服务端实现接口逻辑而且以rest API的形式发布出去；同时客户端根据http接口约定实现客户端逻辑，完成自测</li>
<li>客户端服务端联调<br>所以，Dubbo的接口具有强依赖性，Spring Cloud主要依赖约定</li>
</ol>
</li>
</ul>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>Dubbo和Spring Cloud集成测试的时候都需要服务的和客户端配合完成</p>
<h3 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h3><ul>
<li>Dubbo主要提供Spring Xml配置的方式，同时社区也提供SpringBoot的注解方式Dubbo Spring Boot Project ，而且Dubbo官方提供了最佳实践；目前我们的项目中两种方式都存在，所以学习成本基本可以忽略；</li>
<li>Spring Clould是建立在SpringBoot基础上的，采用大量的注解方式，目前我们也大量使用SpringBoot, 所以学习成本基本可以忽略；</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>Dubbo默认采用Dubbo协议，Dubbo协议工作在TCP层,同等条件下性能优于HTTP协议</li>
<li>Spring Clould采用HTTP协议, 性能略逊与Dubbo</li>
</ul>
<p>最后将以上比较项目给出数值的形式 </p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>权重</th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>迁移成本</td>
<td>10</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>社区支持</td>
<td>9</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>服务治理</td>
<td>8</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>生态建设</td>
<td>7</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>分布式事务</td>
<td>6</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>运维成本</td>
<td>5</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>开发流程</td>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>集成测试</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>学习成本</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>性能</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>37</td>
<td>33</td>
</tr>
</tbody></table>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>  Dubbo优势在于从迁移成本低，能在尽可能不改动现有代码的基础上完成服务化的迁移，而且我们团队成员使用Dubbo的经验比使用Spring Cloud的经验丰富；Spring Cloud的优势在于生态比较完善，社区支持良好；最终根据我们项目当前实际情况,我们认为Dubbo是最好的选择，可以在业务开发的同时平滑地完成服务化;</p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化多项目测试环境隔离</title>
    <url>/2019/02/13/Multi-Project-Test-Env/</url>
    <content><![CDATA[<p>单体应用依赖比较少，大部分情况我们只需要启动一个应用就可以开始测试工作。架构升级到服务化后，每个应用依赖比较多，任何一个依赖有问题都会影响测试结果；如果服务化环境中多项目并行测试，测试效率会更差 。 <span id="more"></span> 为此，我们给出服务化多项目并行测试方案。</p>
<h3 id="版本号隔离"><a href="#版本号隔离" class="headerlink" title="版本号隔离"></a>版本号隔离</h3><p>首先能想到的方法就是利用版本号的特征「类dubb的RPC框架都有版本号属性」，对不同的项目给出不同的版本号; 比如有如下调用关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client -&gt; SA  </span><br></pre></td></tr></table></figure>
<p>在启动SA的时候对不同的项目指定不同的版本号,Client在调用SA的时候根据不同的项目指定与SA相匹配的版本号.</p>
<ul>
<li>优点: 简单，无需额外开发，类dubbo的RPC框架都支持</li>
</ul>
<h3 id="多项目开发测试现状"><a href="#多项目开发测试现状" class="headerlink" title="多项目开发测试现状"></a>多项目开发测试现状</h3><p>实际项目中的调用关系： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client -&gt; SA -&gt; SB -&gt; SC -&gt; SD</span><br></pre></td></tr></table></figure>
<p>有两个项目在并行开发：</p>
<ul>
<li>project1「以下简称P1」代码变更部分是SA, SC</li>
<li>project2「以下简称P2」代码变更部分是SB, SD</li>
</ul>
<p>如果我们采用「版本号隔离」方案; 对于P1, 不但需要部署SA和SC，还需要部署Client和SB，因为Client调用SA，SB调用SC的<strong>版本号分别指向新部署的SA和SC</strong> 。P2也需要类似的部署方法；这样我们发现，几乎所有的服务在每个项目中都需要部署一套；造成资源大量浪费，显然不现实。 因此，我们有了下面的方案「动态路由」 。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由的思路是环境分<strong>一套稳定环境和每个项目对应一套项目测试环境,其中稳定环境包括所有的服务，项目测试环境仅包括该项目代码变更部分的服务</strong>,各个环境的所有服务采用同一注册中心；方案如下图所示 </p>
<p><img src="/2019/02/13/Multi-Project-Test-Env/multi-test-env.png" alt="服务化多项目测试环境"></p>
<ul>
<li>稳定环境: 部署所有的服务，保证稳定环境作为完整的系统；可以利用CI&#x2F;CD每日从Master拉稳定版本的代码完成自动部署</li>
<li>P1: project1测试环境，仅部署有代码变更的SA1和SC1 </li>
<li>P2: project2测试环境，仅部署有代码变更的SB2和SD2</li>
<li>路由策略： Client发起调用的时候携带该调用链路所有测试环境的路由规则，如果没有指定路由规则请求默认环境的服务</li>
</ul>
<h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h5><ul>
<li>每个服务启动时候在注册中心注册服务所在节点测试环境类型(P1，P2或者默认环境)，默认情况注册为默认环境 </li>
<li>自定义loadbalance，根据路由规则将RPC请求路由到指定节点上</li>
<li>每次RPC调用将该调用链路的路由规则隐士传递到下层服务</li>
<li>每个测试环境需要一个独立的入口，以WEB项目为例可以将nginx作为入口，路由规则可以配置在nginx的配置文件中</li>
<li>对接发布系统，有变更的服务发布到测试环境时候，该测试环境的路由规则自动写入测试环境的入口配置文件</li>
</ul>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统核心组件对比：Nacos、Consul、ZooKeeper与etcd</title>
    <url>/2025/07/08/Nacos-Consul-Zk-Etcd/</url>
    <content><![CDATA[<p>在分布式系统架构中，服务发现、配置管理和分布式协调是三大核心挑战。目前业界主流的解决方案包括 Nacos、Consul、ZooKeeper 和 etcd，它们各自基于不同的设计理念，适用于不同的业务场景。本文将从核心功能、特性细节、适用场景等多个维度进行深入对比，帮助技术团队在实际项目中做出合适的选择。<span id="more"></span></p>
<h2 id="核心功能对比概览"><a href="#核心功能对比概览" class="headerlink" title="核心功能对比概览"></a>核心功能对比概览</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ZooKeeper</strong></th>
<th><strong>etcd</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Nacos</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>诞生时间</strong></td>
<td>最早 (2006)</td>
<td>较新 (2013)</td>
<td>较新 (2014)</td>
<td>最新 (2018)</td>
</tr>
<tr>
<td><strong>主要定位</strong></td>
<td>分布式协调服务</td>
<td>分布式键值存储，K8s 核心组件</td>
<td>服务网格与服务发现平台</td>
<td>微服务一站式服务治理平台</td>
</tr>
<tr>
<td><strong>一致性协议</strong></td>
<td>ZAB (ZooKeeper Atomic Broadcast)</td>
<td>Raft</td>
<td>Raft（单数据中心强一致，跨中心最终一致）</td>
<td>CP (Raft) &amp; AP (Distro) 双模</td>
</tr>
<tr>
<td><strong>数据模型</strong></td>
<td>层次化的 ZNode 节点 (类似文件系统)</td>
<td>扁平的键值对 (支持范围查询)</td>
<td>扁平的键值对 (支持目录和前缀查询)</td>
<td>扁平的键值对 (支持分组和命名空间)</td>
</tr>
<tr>
<td><strong>API&#x2F;协议</strong></td>
<td>自定义 TCP 协议，Java&#x2F;C 客户端</td>
<td>HTTP&#x2F;JSON, gRPC</td>
<td>HTTP&#x2F;JSON, DNS 接口</td>
<td>HTTP&#x2F;JSON, gRPC 接口</td>
</tr>
<tr>
<td><strong>性能特点</strong></td>
<td>读多写少场景性能优异</td>
<td>读写性能均高，写入线性一致</td>
<td>读写性能高，支持健康检查优化</td>
<td>支持大规模实例注册，读写性能优越</td>
</tr>
<tr>
<td><strong>开发语言</strong></td>
<td>Java</td>
<td>Go</td>
<td>Go</td>
<td>Java</td>
</tr>
<tr>
<td><strong>高可用与扩展性</strong></td>
<td>需奇数节点，扩容复杂，强一致性</td>
<td>动态扩容，强一致性</td>
<td>多数据中心支持，动态扩缩容</td>
<td>AP&#x2F;CP 复合模型，服务注册高可用，配置需关注 Raft</td>
</tr>
<tr>
<td><strong>运维与监控</strong></td>
<td>无原生 UI，依赖第三方工具</td>
<td>提供 CLI 和 API，支持 Prometheus</td>
<td>自带 Web UI，监控集成友好</td>
<td>自带 Web 控制台，Prometheus 集成</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>支持 SASL、ACL、TLS，配置复杂</td>
<td>支持 TLS、RBAC、认证机制完善</td>
<td>支持 TLS、ACL，企业版更强</td>
<td>支持 TLS、认证，需关注 JVM 相关安全配置</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注：Nacos 2.x 采用复合一致性模型。Raft 协议用于所有持久化数据（包括配置管理和服务的持久化实例），保证 CP 强一致性；而服务注册中的临时实例则采用自研的 Distro 协议，实现高可用但弱一致性。</strong></p>
</blockquote>
<hr>
<h2 id="组件详细分析"><a href="#组件详细分析" class="headerlink" title="组件详细分析"></a>组件详细分析</h2><h3 id="1-ZooKeeper：分布式协调的元老"><a href="#1-ZooKeeper：分布式协调的元老" class="headerlink" title="1. ZooKeeper：分布式协调的元老"></a>1. ZooKeeper：分布式协调的元老</h3><p><strong>核心特点</strong>：</p>
<ul>
<li>Apache 顶级项目，诞生于 2006 年，是分布式协调领域的标杆，被 Kafka、Hadoop、HBase 等广泛采用。</li>
<li>提供分布式锁、领导者选举、集群成员管理等分布式原语，是许多底层系统的“神经中枢”。</li>
<li>使用树状结构（ZNode），支持 Watch 机制，实现事件驱动的数据订阅。</li>
<li>生态成熟，配合 Curator 框架可简化开发复杂度。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>分布式协调为核心诉求的系统</li>
<li>与 Hadoop&#x2F;Kafka 等大数据生态深度集成</li>
<li>需要分布式锁、选举、元数据管理的场景</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>原生 API 设计底层，开发复杂</li>
<li>服务发现能力弱，无内置健康检查</li>
<li>集群扩容需重启，维护复杂，对网络抖动敏感</li>
</ul>
<hr>
<h3 id="2-etcd：云原生时代的强一致存储基石"><a href="#2-etcd：云原生时代的强一致存储基石" class="headerlink" title="2. etcd：云原生时代的强一致存储基石"></a>2. etcd：云原生时代的强一致存储基石</h3><p><strong>核心特点</strong>：</p>
<ul>
<li>Kubernetes 默认数据存储，专为云原生架构设计</li>
<li>使用 Raft 算法，保证写入线性一致性</li>
<li>支持 gRPC 和 REST API，跨语言友好</li>
<li>Watch 机制支持事件监听，便于配置推送</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>Kubernetes 环境中的配置与元数据存储</li>
<li>高可用、强一致性键值存储需求</li>
<li>轻量级服务注册中心</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>默认单键值大小不超过 1.5MB（可通过参数调整）</li>
<li>不提供服务网格、健康检查等治理功能</li>
<li>更偏向平台组件，缺乏一站式管理体验</li>
</ul>
<hr>
<h3 id="3-Consul：服务治理的全能选手"><a href="#3-Consul：服务治理的全能选手" class="headerlink" title="3. Consul：服务治理的全能选手"></a>3. Consul：服务治理的全能选手</h3><p><strong>核心特点</strong>：</p>
<ul>
<li>集服务发现、KV 存储、健康检查、服务网格于一体</li>
<li>支持 DNS 和 HTTP 两种服务发现方式</li>
<li>内建多数据中心支持，跨地域部署方便</li>
<li>Consul Connect 支持 mTLS、服务代理、ACL 等网格能力</li>
<li>自带 Web UI，状态管理直观</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>微服务架构中的服务注册与健康检查</li>
<li>构建跨区域服务网络</li>
<li>对服务网格、安全加密通信有要求的系统</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>多中心间仅提供最终一致性</li>
<li>服务网格功能需额外部署 Envoy 等代理组件</li>
<li>企业版功能更丰富，开源版略显不足</li>
</ul>
<hr>
<h3 id="4-Nacos：为微服务而生的一站式平台"><a href="#4-Nacos：为微服务而生的一站式平台" class="headerlink" title="4. Nacos：为微服务而生的一站式平台"></a>4. Nacos：为微服务而生的一站式平台</h3><p><strong>核心特点</strong>：</p>
<ul>
<li>集服务注册、配置管理、服务治理为一体，降低集成成本</li>
<li>支持双模一致性模型（Raft + Distro）：<ul>
<li><strong>Raft（CP 模式）</strong>：持久化数据，如配置与持久实例</li>
<li><strong>Distro（AP 模式）</strong>：临时实例注册，保障高可用</li>
</ul>
</li>
<li>与 Spring Cloud、Dubbo 等主流框架深度集成</li>
<li>提供服务分组、命名空间、灰度发布、流量调度等高级能力</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>Java 技术栈微服务项目</li>
<li>同时需要配置中心与注册中心的系统</li>
<li>需要灵活服务治理能力的中大型项目</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>国际社区活跃度不如 Consul、etcd</li>
<li>JVM 运维调优要求高，大规模场景下需关注数据库与线程资源配置</li>
</ul>
<hr>
<h2 id="高可用性与扩展性对比"><a href="#高可用性与扩展性对比" class="headerlink" title="高可用性与扩展性对比"></a>高可用性与扩展性对比</h2><ul>
<li><strong>ZooKeeper</strong>：需奇数节点，扩容需重启，稳定性依赖网络状况</li>
<li><strong>etcd</strong>：支持动态扩容，Raft 保障强一致，适合云原生部署</li>
<li><strong>Consul</strong>：支持多数据中心同步，本地强一致，远端最终一致</li>
<li><strong>Nacos</strong>：服务注册基于 AP 模型具备扩展弹性，配置管理依赖 CP 模式的 Raft 集群</li>
</ul>
<hr>
<h2 id="运维与监控对比"><a href="#运维与监控对比" class="headerlink" title="运维与监控对比"></a>运维与监控对比</h2><ul>
<li><strong>ZooKeeper</strong>：需第三方工具如 zkui、Exhibitor，监控配置复杂</li>
<li><strong>etcd</strong>：CLI&#x2F;API 直观，支持 Prometheus 集成，自动化程度高</li>
<li><strong>Consul</strong>：自带 UI，支持 Prometheus、Grafana，易于观测与故障排查</li>
<li><strong>Nacos</strong>：内建控制台，支持 Prometheus，界面友好，易于入门</li>
</ul>
<hr>
<h2 id="安全性对比"><a href="#安全性对比" class="headerlink" title="安全性对比"></a>安全性对比</h2><ul>
<li><strong>ZooKeeper</strong>：支持 SASL、ACL、TLS，但配置繁琐</li>
<li><strong>etcd</strong>：支持 TLS 加密、客户端认证、RBAC 权限控制，安全性强</li>
<li><strong>Consul</strong>：支持 TLS 和 ACL，企业版安全能力更强</li>
<li><strong>Nacos</strong>：支持 TLS 和认证机制，需关注 JVM 及配置安全</li>
</ul>
<hr>
<h2 id="生态与集成对比"><a href="#生态与集成对比" class="headerlink" title="生态与集成对比"></a>生态与集成对比</h2><table>
<thead>
<tr>
<th>组件</th>
<th>集成生态</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ZooKeeper</strong></td>
<td>Kafka、Hadoop、HBase、Java 系统</td>
</tr>
<tr>
<td><strong>etcd</strong></td>
<td>Kubernetes、CoreOS、Go 微服务框架</td>
</tr>
<tr>
<td><strong>Consul</strong></td>
<td>HashiCorp 工具链（Terraform、Nomad）、云原生生态</td>
</tr>
<tr>
<td><strong>Nacos</strong></td>
<td>Spring Cloud、Dubbo、阿里云微服务生态，中国社区活跃</td>
</tr>
</tbody></table>
<hr>
<h2 id="组件选择指南"><a href="#组件选择指南" class="headerlink" title="组件选择指南"></a>组件选择指南</h2><h3 id="按核心需求选型"><a href="#按核心需求选型" class="headerlink" title="按核心需求选型"></a>按核心需求选型</h3><ul>
<li><strong>分布式协调需求高</strong>：ZooKeeper（配 Curator）或 etcd</li>
<li><strong>注册中心 + 健康检查</strong>：Consul 或 Nacos 更适合</li>
<li><strong>配置中心为主</strong>：Nacos（功能齐全）、etcd（一致性强）、Consul（KV存储稳健）</li>
<li><strong>服务网格需求强</strong>：首选 Consul Connect（或考虑 Istio）</li>
<li><strong>Java 技术栈</strong>：Nacos 与 Spring Cloud 集成最顺畅</li>
</ul>
<h3 id="按团队技术栈选型"><a href="#按团队技术栈选型" class="headerlink" title="按团队技术栈选型"></a>按团队技术栈选型</h3><ul>
<li><strong>偏向 Java</strong>：ZooKeeper 或 Nacos</li>
<li><strong>Go&#x2F;K8s 环境</strong>：etcd 或 Consul</li>
<li><strong>大数据系统</strong>：ZooKeeper 为首选</li>
</ul>
<h3 id="按规模与运维能力选型"><a href="#按规模与运维能力选型" class="headerlink" title="按规模与运维能力选型"></a>按规模与运维能力选型</h3><ul>
<li><strong>小团队初创项目</strong>：Nacos 上手快，维护简单</li>
<li><strong>大规模微服务体系</strong>：Consul&#x2F;Nacos 可应对大并发</li>
<li><strong>极简架构偏好者</strong>：etcd 功能聚焦，部署简便</li>
</ul>
<hr>
<h2 id="典型场景推荐方案"><a href="#典型场景推荐方案" class="headerlink" title="典型场景推荐方案"></a>典型场景推荐方案</h2><ol>
<li><p><strong>传统 Java 微服务（非 K8s）</strong>：</p>
<ul>
<li>服务治理：Nacos（Spring Cloud 深度集成）</li>
<li>分布式协调：etcd 或 ZooKeeper + Curator</li>
<li>一体化方案：Nacos 支持服务注册 + 配置管理</li>
</ul>
</li>
<li><p><strong>Kubernetes 容器平台</strong>：</p>
<ul>
<li>核心数据存储：etcd（K8s 标配）</li>
<li>服务注册：K8s Service + CoreDNS</li>
<li>高级配置中心：etcd 或 Nacos</li>
</ul>
</li>
<li><p><strong>跨地域部署系统</strong>：</p>
<ul>
<li>服务网络管理：Consul（内建多数据中心）</li>
<li>配置中心：Consul KV 或 Nacos（命名空间隔离）</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式基础设施组件没有一劳永逸的选择，只有契合业务场景的最优解。ZooKeeper 是协调领域的经典基石，etcd 成为云原生中的强一致核心，Consul 在服务网格和网络治理中独具优势，而 Nacos 提供了微服务体系下的一体化解决方案。</p>
<p>实际项目中建议根据业务需求、技术生态、团队能力三方面综合评估，灵活选型。通常微服务体系下，<strong>Nacos 和 Consul</strong> 是兼顾功能与复杂度的优选；而在 K8s 环境中，<strong>etcd</strong> 是不可替代的基础设施核心。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://nacos.io/">Nacos</a></li>
<li><a href="https://www.consul.io/">Consul</a></li>
<li><a href="https://zookeeper.apache.org/">ZooKeeper</a></li>
<li><a href="https://etcd.io/">etcd</a></li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Open Tracing(Jaeger) 遭遇多线程</title>
    <url>/2019/12/27/Jaeger-Thread/</url>
    <content><![CDATA[<p>我们知道在Java技术体系中，链路跟踪严重依赖ThreadLocal；因此在多线程的场景下会导致链路跟踪失效.<span id="more"></span></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>前几天一位开发同学反馈了一个问题，在链路跟踪UI上看到某个链路Rpc的span数量比实际调用少了很多；我听完第一反映是我们最近升级的SDK出问题了? 根据该同学反馈该接口是一个新接口，上线后一直没关注过链路；我们随即在链路跟踪UI上将多个系统的常用接口都检查了一遍发现一切正常，基本排除了SDK可能引起的问题。接着开始检查开发同学的代码,顺着该请求发现代码里面用到了<strong>线程池</strong> ,该同学解释该接口内部需要多次调用多个Rpc接口，为了提升效率所以采用了多线程。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析opentracing的源码发现tracing相关的的信息保存在<code>io.opentracing.util.ThreadLocalScopeManager</code>的ThreadLocal变量里:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalScopeManager</span> <span class="keyword">implements</span> <span class="title class_">ScopeManager</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalScope&gt; tlsScope = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;ThreadLocalScope&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Scope <span class="title function_">activate</span><span class="params">(Span span, <span class="type">boolean</span> finishOnClose)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalScope</span>(<span class="built_in">this</span>, span, finishOnClose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Scope <span class="title function_">active</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tlsScope.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就可以解释为什么多线程中的Rpc请求没有将相关Tracing信息传递下去;</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>多线程中ThreadLocal变量的传递:<br>关于多线程中ThreadLocal变量的传递我们可以用阿里巴巴的<a href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a> ,所以整个思路就是自己实现一遍<code>ThreadLocalScopeManager</code>用<code>TransmittableThreadLocal</code>替换<code>ThreadLocal</code>，以及跟它关联的类<code>ThreadLocalScope</code>(它里面申明了<code>ThreadLocalScopeManager</code>变量)； </p>
</li>
<li><p>修改Opentrcing里面默认的<code>ThreadLocalScopeManager</code>为用户自定义<code>ThreadLocalScopeManager</code><br>检查Jaeger的Springboot自动配置文件<code>io.opentracing.contrib.java.spring.jaeger.starter.JaegerAutoConfiguration</code>源码, 在构造Bean <code>io.opentracing.Tracer</code>时有用户自定义方法: <code>tracerCustomizers.forEach(c -&gt; c.customize(builder))</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JaegerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;TracerBuilderCustomizer&gt; tracerCustomizers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> io.opentracing.Tracer <span class="title function_">tracer</span><span class="params">(Sampler sampler,</span></span><br><span class="line"><span class="params">                                      Reporter reporter,</span></span><br><span class="line"><span class="params">                                      Metrics metrics,</span></span><br><span class="line"><span class="params">                                      JaegerConfigurationProperties properties)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> JaegerTracer.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">JaegerTracer</span>.Builder(properties.getServiceName())</span><br><span class="line">            .withReporter(reporter)</span><br><span class="line">            .withSampler(sampler)</span><br><span class="line">            .withTags(properties.determineTags())</span><br><span class="line">            .withMetrics(metrics);</span><br><span class="line"></span><br><span class="line">    tracerCustomizers.forEach(c -&gt; c.customize(builder));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>
<p>于是，我们只需要自定义<code>TracerBuilderCustomizer</code>调用<code>builder.withScopeManager</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlTracerBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title class_">TracerBuilderCustomizer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(JaegerTracer.Builder builder)</span> &#123;</span><br><span class="line">        builder.withScopeManager(<span class="keyword">new</span> <span class="title class_">TracingScopeManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SpringBoot自动配置文件中构造Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TracerBuilderCustomizer&gt; <span class="title function_">tracerCustomizers</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">TtlTracerBuilderCustomizer</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，问题解决； 代码参考<a href="https://github.com/yinghuzhu/request-tracing">request-tracing</a></p>
<h3 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h3><p>我不建议在互联网高并发请求接口内部采用多线程；以Java技术体系为例，请求到达系统后一般会有容器(Tomcat之类)或者Rpc框架先接收，然而这些框架本来就是多线程在运行,如果系统本来已经到瓶颈了，即使增加线程也不会提升效率；如果系统需要增加线程，首先我们应该增加容器或者Rpc框架的线程数量；另外如果接口性能差，我们首先应该考虑是Sql的问题还是代码逻辑的问题；或者系统达到了瓶颈是否可以通过增加机器提升性能；如果接口逻辑本身太复杂，可能是我们的方案或者设计有问题，或许可以考虑按照离线请求的模式设计接口。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个问题虽然没有对业务造成影响，但收集到链路肯定是有问题的；这也暴露出了我们开发过程中的一些问题，对非功能性验证做的不到位，这方面还需要加强。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>链路跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title>OIDC &quot;Need Admin Approval&quot; 故障排除与分析</title>
    <url>/2025/11/12/OIDC-OAuth2-Need-Admin-Approval/</url>
    <content><![CDATA[<p>本文详细记录了一次OIDC认证系统中遇到的”Need admin approval”问题。用户在登录时持续收到错误提示，但使用相同令牌的独立工具却能正常工作。经过深入分析，发现问题根源在于OIDC配置中的<code>Authorization Prompt</code>参数设置不当<span id="more"></span>。本文不仅提供了完整的故障排除过程，还包含了OIDC&#x2F;OAuth2.0的基础知识，以帮助不同技术水平的同事理解和解决类似问题。虽然案例基于EspoCRM，但此问题在任何使用OIDC&#x2F;OAuth2.0的系统中都可能遇到。</p>
<h2 id="1-OIDC-OAuth2-0-基础知识"><a href="#1-OIDC-OAuth2-0-基础知识" class="headerlink" title="1. OIDC&#x2F;OAuth2.0 基础知识"></a>1. OIDC&#x2F;OAuth2.0 基础知识</h2><h3 id="1-1-什么是OIDC？"><a href="#1-1-什么是OIDC？" class="headerlink" title="1.1 什么是OIDC？"></a>1.1 什么是OIDC？</h3><p>OpenID Connect (OIDC) 是建立在OAuth 2.0协议之上的身份验证层，它允许客户端应用程序验证终端用户的身份，并获取基本的用户配置信息。OIDC的主要目标是提供一种简单的方式让应用程序能够验证用户身份。</p>
<h3 id="1-2-OAuth-2-0-与-OIDC-的关系"><a href="#1-2-OAuth-2-0-与-OIDC-的关系" class="headerlink" title="1.2 OAuth 2.0 与 OIDC 的关系"></a>1.2 OAuth 2.0 与 OIDC 的关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐    1.请求访问      ┌──────────────┐</span><br><span class="line">│   客户端应用  │ ────────────────→ │  资源所有者(用户) │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br><span class="line">       │                               │</span><br><span class="line">       │ 2.授权请求                    │</span><br><span class="line">       ▼                               ▼</span><br><span class="line">┌─────────────┐                  ┌──────────────┐</span><br><span class="line">│ 授权服务器  │ ←───────────────→ │  资源服务器   │</span><br><span class="line">│ (如Azure AD) │                  │ (如Graph API) │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br><span class="line">       │                               │</span><br><span class="line">       │ 3.返回访问令牌                │</span><br><span class="line">       ▼                               ▼</span><br><span class="line">┌─────────────┐    4.访问资源      ┌──────────────┐</span><br><span class="line">│   客户端应用  │ ────────────────→ │  资源服务器   │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="1-3-OIDC-认证流程时序图"><a href="#1-3-OIDC-认证流程时序图" class="headerlink" title="1.3 OIDC 认证流程时序图"></a>1.3 OIDC 认证流程时序图</h3><pre class="mermaid">sequenceDiagram
    participant U as 用户
    participant C as 客户端应用
    participant AS as 授权服务器
    participant RS as 资源服务器

    U->>C: 1. 访问应用
    C->>U: 2. 重定向到授权服务器
    U->>AS: 3. 用户认证
    AS->>U: 4. 用户授权同意
    U->>C: 5. 重定向回客户端(授权码)
    C->>AS: 6. 交换访问令牌
    AS->>C: 7. 返回访问令牌
    C->>RS: 8. 访问受保护资源
    RS->>C: 9. 返回资源数据</pre>

<p>OIDC认证流程的详细步骤：</p>
<ol>
<li>用户访问客户端应用</li>
<li>客户端应用重定向到授权服务器</li>
<li>用户在授权服务器进行身份验证</li>
<li>授权服务器向用户请求授权同意</li>
<li>用户授权后，重定向回客户端应用（携带授权码）</li>
<li>客户端应用使用授权码向授权服务器请求访问令牌</li>
<li>授权服务器返回访问令牌给客户端应用</li>
<li>客户端应用使用访问令牌访问资源服务器</li>
<li>资源服务器返回请求的资源数据</li>
</ol>
<h3 id="1-4-关键概念"><a href="#1-4-关键概念" class="headerlink" title="1.4 关键概念"></a>1.4 关键概念</h3><h4 id="1-4-1-Scope（权限范围）"><a href="#1-4-1-Scope（权限范围）" class="headerlink" title="1.4.1 Scope（权限范围）"></a>1.4.1 Scope（权限范围）</h4><p>Scope定义了客户端应用请求访问的权限范围：</p>
<ul>
<li><code>openid</code>：必需，表示使用OIDC</li>
<li><code>profile</code>：访问用户基本信息</li>
<li><code>email</code>：访问用户邮箱</li>
<li><code>User.Read</code>：读取用户信息（Microsoft Graph）</li>
<li><code>Group.Read.All</code>：读取所有组信息（需要管理员同意）</li>
</ul>
<h4 id="1-4-2-Prompt-参数"><a href="#1-4-2-Prompt-参数" class="headerlink" title="1.4.2 Prompt 参数"></a>1.4.2 Prompt 参数</h4><p>Prompt参数控制授权服务器如何与用户交互：</p>
<ul>
<li><code>none</code>：不显示任何UI界面</li>
<li><code>login</code>：强制用户重新认证</li>
<li><code>consent</code>：强制显示同意界面</li>
<li><code>select_account</code>：显示账户选择界面</li>
</ul>
<h2 id="2-问题现象"><a href="#2-问题现象" class="headerlink" title="2. 问题现象"></a>2. 问题现象</h2><h3 id="2-1-故障描述"><a href="#2-1-故障描述" class="headerlink" title="2.1 故障描述"></a>2.1 故障描述</h3><p>在任何使用OIDC与身份提供商（如Azure AD、Google、Okta等）集成的系统中，用户通过OIDC登录时遇到以下问题：</p>
<ul>
<li>用户尝试登录时，身份提供商显示”Need admin approval”错误</li>
<li>登录流程中断，用户无法访问系统</li>
</ul>
<h3 id="2-2-矛盾现象"><a href="#2-2-矛盾现象" class="headerlink" title="2.2 矛盾现象"></a>2.2 矛盾现象</h3><p>然而，使用相同的访问令牌在独立工具中：</p>
<ul>
<li>所有API功能正常工作</li>
<li>可以成功访问需要高级权限的资源</li>
<li>权限验证完全通过</li>
</ul>
<h2 id="3-故障排查过程"><a href="#3-故障排查过程" class="headerlink" title="3. 故障排查过程"></a>3. 故障排查过程</h2><h3 id="3-1-初步分析（错误方向）"><a href="#3-1-初步分析（错误方向）" class="headerlink" title="3.1 初步分析（错误方向）"></a>3.1 初步分析（错误方向）</h3><p>基于表面现象，我们最初的假设是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OIDC流程失败 → 权限不足 → 需要管理员同意</span><br></pre></td></tr></table></figure>

<p>尝试的解决方案：</p>
<ol>
<li>检查身份提供商中的API权限配置</li>
<li>移除需要管理员同意的权限范围（如<code>Group.Read.All</code>）</li>
<li>验证令牌内容和权限范围</li>
</ol>
<h3 id="3-2-关键信息澄清"><a href="#3-2-关键信息澄清" class="headerlink" title="3.2 关键信息澄清"></a>3.2 关键信息澄清</h3><p>经过深入沟通，发现了关键事实：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OIDC认证流程中移除需要管理员同意的scope → 认证成功</span><br><span class="line">使用成功获取的令牌 → 能访问高级权限资源（本不应有此权限）</span><br></pre></td></tr></table></figure>

<p>这让我们意识到问题不在权限范围本身，而在于认证流程的控制机制。</p>
<h3 id="3-3-突破性发现"><a href="#3-3-突破性发现" class="headerlink" title="3.3 突破性发现"></a>3.3 突破性发现</h3><p>最终发现问题根源在于客户端应用的OIDC配置中的<code>Authorization Prompt</code>参数。</p>
<h2 id="4-根本原因分析"><a href="#4-根本原因分析" class="headerlink" title="4. 根本原因分析"></a>4. 根本原因分析</h2><h3 id="4-1-问题本质"><a href="#4-1-问题本质" class="headerlink" title="4.1 问题本质"></a>4.1 问题本质</h3><p>问题并非权限缺失，而是OIDC流程控制参数配置不当导致的流程冲突。</p>
<h3 id="4-2-技术细节"><a href="#4-2-技术细节" class="headerlink" title="4.2 技术细节"></a>4.2 技术细节</h3><h4 id="4-2-1-错误配置：prompt-consent"><a href="#4-2-1-错误配置：prompt-consent" class="headerlink" title="4.2.1 错误配置：prompt=consent"></a>4.2.1 错误配置：<code>prompt=consent</code></h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?</span><br><span class="line">  client_id=&#123;client_id&#125;&amp;</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  redirect_uri=&#123;redirect_uri&#125;&amp;</span><br><span class="line">  scope=openid profile email User.Read Group.Read.All&amp;</span><br><span class="line">  prompt=consent  // 问题根源</span><br></pre></td></tr></table></figure>

<p><strong>行为</strong>：强制显示权限同意界面<br><strong>冲突</strong>：租户策略禁止普通用户执行同意操作</p>
<h4 id="4-2-2-正确配置：prompt-select-account"><a href="#4-2-2-正确配置：prompt-select-account" class="headerlink" title="4.2.2 正确配置：prompt=select_account"></a>4.2.2 正确配置：<code>prompt=select_account</code></h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?</span><br><span class="line">  client_id=&#123;client_id&#125;&amp;</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  redirect_uri=&#123;redirect_uri&#125;&amp;</span><br><span class="line">  scope=openid profile email User.Read Group.Read.All&amp;</span><br><span class="line">  prompt=select_account  // 正确配置</span><br></pre></td></tr></table></figure>

<p><strong>行为</strong>：智能检查权限状态，已满足则跳过同意界面</p>
<h3 id="4-3-流程对比"><a href="#4-3-流程对比" class="headerlink" title="4.3 流程对比"></a>4.3 流程对比</h3><h4 id="4-3-1-错误流程"><a href="#4-3-1-错误流程" class="headerlink" title="4.3.1 错误流程"></a>4.3.1 错误流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户 → 客户端应用 → 身份提供商 (prompt=consent) → 显示同意界面 → 用户无法操作 → 失败</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-正确流程"><a href="#4-3-2-正确流程" class="headerlink" title="4.3.2 正确流程"></a>4.3.2 正确流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户 → 客户端应用 → 身份提供商 (prompt=select_account) → 检查权限 → 已满足 → 颁发令牌 → 成功</span><br></pre></td></tr></table></figure>

<h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. 解决方案</h2><h3 id="5-1-通用解决步骤"><a href="#5-1-通用解决步骤" class="headerlink" title="5.1 通用解决步骤"></a>5.1 通用解决步骤</h3><h4 id="步骤1：检查应用配置"><a href="#步骤1：检查应用配置" class="headerlink" title="步骤1：检查应用配置"></a>步骤1：检查应用配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登录客户端应用管理后台</span><br></pre></td></tr></table></figure>

<h4 id="步骤2：找到OIDC配置"><a href="#步骤2：找到OIDC配置" class="headerlink" title="步骤2：找到OIDC配置"></a>步骤2：找到OIDC配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导航到身份验证或认证设置</span><br><span class="line">找到OIDC相关配置</span><br></pre></td></tr></table></figure>

<h4 id="步骤3：修改Authorization-Prompt参数"><a href="#步骤3：修改Authorization-Prompt参数" class="headerlink" title="步骤3：修改Authorization Prompt参数"></a>步骤3：修改Authorization Prompt参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到&quot;Authorization Prompt&quot;字段</span><br><span class="line">将值从&quot;consent&quot;修改为&quot;select_account&quot;</span><br></pre></td></tr></table></figure>

<h4 id="步骤4：保存配置"><a href="#步骤4：保存配置" class="headerlink" title="步骤4：保存配置"></a>步骤4：保存配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击保存按钮</span><br><span class="line">配置立即生效</span><br></pre></td></tr></table></figure>

<h3 id="5-2-验证结果"><a href="#5-2-验证结果" class="headerlink" title="5.2 验证结果"></a>5.2 验证结果</h3><p>修改后，OIDC登录流程恢复正常：</p>
<ul>
<li>用户可以正常登录系统</li>
<li>不再显示”Need admin approval”错误</li>
<li>系统可以正常访问受保护的API资源</li>
</ul>
<h2 id="6-技术深度解析"><a href="#6-技术深度解析" class="headerlink" title="6. 技术深度解析"></a>6. 技术深度解析</h2><h3 id="6-1-Prompt参数详解"><a href="#6-1-Prompt参数详解" class="headerlink" title="6.1 Prompt参数详解"></a>6.1 Prompt参数详解</h3><h4 id="6-1-1-prompt-none"><a href="#6-1-1-prompt-none" class="headerlink" title="6.1.1 prompt=none"></a>6.1.1 <code>prompt=none</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于后台静默认证</span></span><br><span class="line"><span class="comment">// 如果需要用户交互，立即返回错误</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-prompt-login"><a href="#6-1-2-prompt-login" class="headerlink" title="6.1.2 prompt=login"></a>6.1.2 <code>prompt=login</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强制用户重新输入凭据</span></span><br><span class="line"><span class="comment">// 适用于高安全要求场景</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;login&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-prompt-consent"><a href="#6-1-3-prompt-consent" class="headerlink" title="6.1.3 prompt=consent"></a>6.1.3 <code>prompt=consent</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强制显示同意界面</span></span><br><span class="line"><span class="comment">// 适用于需要用户明确授权的场景</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;consent&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-1-4-prompt-select-account"><a href="#6-1-4-prompt-select-account" class="headerlink" title="6.1.4 prompt=select_account"></a>6.1.4 <code>prompt=select_account</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示账户选择界面，智能处理权限</span></span><br><span class="line"><span class="comment">// 最佳实践配置</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;select_account&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-2-权限同意机制"><a href="#6-2-权限同意机制" class="headerlink" title="6.2 权限同意机制"></a>6.2 权限同意机制</h3><h4 id="6-2-1-管理员同意"><a href="#6-2-1-管理员同意" class="headerlink" title="6.2.1 管理员同意"></a>6.2.1 管理员同意</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管理员在身份提供商管理门户中为应用授予权限</span></span><br><span class="line"><span class="comment">// 适用于需要高权限的scope</span></span><br><span class="line"><span class="comment">// 一次设置，全局生效</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-用户同意"><a href="#6-2-2-用户同意" class="headerlink" title="6.2.2 用户同意"></a>6.2.2 用户同意</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通用户在认证时同意权限请求</span></span><br><span class="line"><span class="comment">// 适用于基本权限</span></span><br><span class="line"><span class="comment">// 受租户策略限制</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-不同平台的配置示例"><a href="#6-3-不同平台的配置示例" class="headerlink" title="6.3 不同平台的配置示例"></a>6.3 不同平台的配置示例</h3><h4 id="6-3-1-EspoCRM"><a href="#6-3-1-EspoCRM" class="headerlink" title="6.3.1 EspoCRM"></a>6.3.1 EspoCRM</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Administration &gt; Authentication &gt; OIDC</span></span><br><span class="line"><span class="comment">// Authorization Prompt: select_account</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-Django应用"><a href="#6-3-2-Django应用" class="headerlink" title="6.3.2 Django应用"></a>6.3.2 Django应用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_REDIRECT_URL = <span class="string">&#x27;/dashboard/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_ERROR_URL = <span class="string">&#x27;/login/error/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_URL = <span class="string">&#x27;/login/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_OAUTH2_SCOPE = [<span class="string">&#x27;openid&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;email&#x27;</span>]</span><br><span class="line">SOCIAL_AUTH_OAUTH2_PROMPT = <span class="string">&#x27;select_account&#x27;</span>  <span class="comment"># 关键配置</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-3-Node-js应用-Passport-js"><a href="#6-3-3-Node-js应用-Passport-js" class="headerlink" title="6.3.3 Node.js应用 (Passport.js)"></a>6.3.3 Node.js应用 (Passport.js)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">&#x27;passport&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OIDCStrategy</span> = <span class="built_in">require</span>(<span class="string">&#x27;passport-azure-ad&#x27;</span>).<span class="property">OIDCStrategy</span>;</span><br><span class="line"></span><br><span class="line">passport.<span class="title function_">use</span>(<span class="keyword">new</span> <span class="title class_">OIDCStrategy</span>(&#123;</span><br><span class="line">  <span class="attr">identityMetadata</span>: config.<span class="property">creds</span>.<span class="property">identityMetadata</span>,</span><br><span class="line">  <span class="attr">clientID</span>: config.<span class="property">creds</span>.<span class="property">clientID</span>,</span><br><span class="line">  <span class="attr">redirectUrl</span>: config.<span class="property">creds</span>.<span class="property">redirectUrl</span>,</span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">responseMode</span>: <span class="string">&#x27;form_post&#x27;</span>,</span><br><span class="line">  <span class="attr">scope</span>: [<span class="string">&#x27;openid&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;email&#x27;</span>],</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;select_account&#x27;</span>,  <span class="comment">// 关键配置</span></span><br><span class="line">  <span class="attr">loggingLevel</span>: <span class="string">&#x27;info&#x27;</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">iss, sub, profile, accessToken, refreshToken, done</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理认证成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">done</span>(<span class="literal">null</span>, profile);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4-Spring-Boot应用"><a href="#6-3-4-Spring-Boot应用" class="headerlink" title="6.3.4 Spring Boot应用"></a>6.3.4 Spring Boot应用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// application.yml</span></span><br><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      client:</span><br><span class="line">        registration:</span><br><span class="line">          azure:</span><br><span class="line">            client-id: $&#123;AZURE_CLIENT_ID&#125;</span><br><span class="line">            client-secret: $&#123;AZURE_CLIENT_SECRET&#125;</span><br><span class="line">            provider: azure</span><br><span class="line">            scope: openid,profile,email</span><br><span class="line">            authorization-uri: https:<span class="comment">//login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?prompt=select_account  // 关键配置</span></span><br><span class="line">        provider:</span><br><span class="line">          azure:</span><br><span class="line">            issuer-uri: https:<span class="comment">//login.microsoftonline.com/&#123;tenant&#125;/v2.0</span></span><br></pre></td></tr></table></figure>

<h2 id="7-经验教训"><a href="#7-经验教训" class="headerlink" title="7. 经验教训"></a>7. 经验教训</h2><h3 id="7-1-技术层面"><a href="#7-1-技术层面" class="headerlink" title="7.1 技术层面"></a>7.1 技术层面</h3><ol>
<li><strong>Prompt参数的重要性</strong>：在OIDC&#x2F;OAuth2.0问题排查中，prompt参数应作为首要检查点</li>
<li><strong>权限的多层次性</strong>：理解管理员同意、用户同意和应用注册之间的区别</li>
<li><strong>流程控制vs权限范围</strong>：区分流程控制参数和权限范围参数的作用</li>
</ol>
<h3 id="7-2-诊断方法"><a href="#7-2-诊断方法" class="headerlink" title="7.2 诊断方法"></a>7.2 诊断方法</h3><ol>
<li><strong>准确描述问题</strong>：问题的准确描述对诊断至关重要</li>
<li><strong>逐步排除假设</strong>：从表象到本质，逐步排除错误假设</li>
<li><strong>关注IdP策略</strong>：同时考虑应用端配置和IdP端策略</li>
</ol>
<h3 id="7-3-最佳实践"><a href="#7-3-最佳实践" class="headerlink" title="7.3 最佳实践"></a>7.3 最佳实践</h3><ol>
<li><strong>默认使用<code>select_account</code></strong>：除非有特殊需求，否则推荐使用<code>select_account</code></li>
<li><strong>权限最小化原则</strong>：只请求必需的权限范围</li>
<li><strong>定期审查配置</strong>：定期检查OIDC配置参数的合理性</li>
</ol>
<h2 id="8-预防措施"><a href="#8-预防措施" class="headerlink" title="8. 预防措施"></a>8. 预防措施</h2><h3 id="8-1-配置检查清单"><a href="#8-1-配置检查清单" class="headerlink" title="8.1 配置检查清单"></a>8.1 配置检查清单</h3><ul>
<li><input disabled type="checkbox"> Authorization Prompt参数设置为<code>select_account</code></li>
<li><input disabled type="checkbox"> Scope只包含必需的权限范围</li>
<li><input disabled type="checkbox"> 管理员同意已正确授予</li>
<li><input disabled type="checkbox"> 重定向URI配置正确</li>
<li><input disabled type="checkbox"> 客户端密钥安全存储</li>
</ul>
<h3 id="8-2-监控建议"><a href="#8-2-监控建议" class="headerlink" title="8.2 监控建议"></a>8.2 监控建议</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控OIDC登录失败日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/application/oidc.log | grep <span class="string">&quot;admin approval&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查身份提供商审计日志</span></span><br><span class="line"><span class="comment"># 具体命令根据不同的IdP而异</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-故障恢复预案"><a href="#8-3-故障恢复预案" class="headerlink" title="8.3 故障恢复预案"></a>8.3 故障恢复预案</h3><ol>
<li><strong>快速回滚</strong>：准备配置回滚方案</li>
<li><strong>备用登录</strong>：确保有备用登录方式</li>
<li><strong>用户通知</strong>：及时通知用户故障状态</li>
</ol>
<h2 id="9-不同身份提供商的特殊考虑"><a href="#9-不同身份提供商的特殊考虑" class="headerlink" title="9. 不同身份提供商的特殊考虑"></a>9. 不同身份提供商的特殊考虑</h2><h3 id="9-1-Azure-AD"><a href="#9-1-Azure-AD" class="headerlink" title="9.1 Azure AD"></a>9.1 Azure AD</h3><ul>
<li>管理员同意通过Azure门户配置</li>
<li>支持<code>prompt</code>参数</li>
<li>需要正确配置API权限</li>
</ul>
<h3 id="9-2-Google-Identity"><a href="#9-2-Google-Identity" class="headerlink" title="9.2 Google Identity"></a>9.2 Google Identity</h3><ul>
<li>通过Google Cloud Console管理</li>
<li>同样涉及管理员同意流程</li>
<li>配置方式略有不同</li>
</ul>
<h3 id="9-3-Okta"><a href="#9-3-Okta" class="headerlink" title="9.3 Okta"></a>9.3 Okta</h3><ul>
<li>通过Admin Console配置</li>
<li>支持类似的prompt机制</li>
<li>需要配置应用权限</li>
</ul>
<h3 id="9-4-Keycloak"><a href="#9-4-Keycloak" class="headerlink" title="9.4 Keycloak"></a>9.4 Keycloak</h3><ul>
<li>通过管理控制台配置</li>
<li>支持自定义认证流程</li>
<li>需要配置客户端范围</li>
</ul>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>这次故障排除过程展示了复杂认证问题的典型特征：</p>
<ol>
<li><strong>表象与本质的差异</strong>：表面看似权限问题，实际是流程控制问题</li>
<li><strong>多层因素影响</strong>：涉及应用配置、IdP策略、用户权限等多个层面</li>
<li><strong>诊断的重要性</strong>：准确的问题描述和逐步排查是解决问题的关键</li>
</ol>
<p>这个问题在任何使用OIDC&#x2F;OAuth2.0的系统中都可能遇到，特别是在以下场景：</p>
<ul>
<li>企业环境中，租户策略较为严格</li>
<li>应用需要访问需要管理员同意的高级权限</li>
<li>配置参数设置不当</li>
</ul>
<p>通过这次经验，我们不仅解决了具体问题，还加深了对OIDC&#x2F;OAuth2.0协议的理解，为未来处理类似问题积累了宝贵经验。</p>
<h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11. 参考资料"></a>11. 参考资料</h2><ol>
<li><a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Specification</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 Authorization Framework</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/">Microsoft Identity Platform Documentation</a></li>
<li><a href="https://developers.google.com/identity/">Google Identity Platform Documentation</a></li>
</ol>
<hr>
]]></content>
  </entry>
  <entry>
    <title>一次OOM引发服务雪崩的思考</title>
    <url>/2018/12/01/OOM-Casue-Snowslide/</url>
    <content><![CDATA[<p>前几天核心基础服务(简称S,两节点)发生了一次线上故障，导致整个基础服务雪崩，最终，该基础服务故障导致整站多项功能失效；</p>
<span id="more"></span>
<h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol>
<li>4:15 开始S的多个上游服务开始出现大量超时,而且出现告警</li>
<li>4:30 S的节点S1出现OOM停止服务 ,同时告警系统发出了告警信息</li>
<li>4:50 S的节点S2由于操作系统内存不足被系统kill ,同时告警系统发出了告警信息<br> ….</li>
<li>8:00 运营同学反馈问题,技术同学开始排查</li>
<li>8:05 技术同学发现S故障,重启S服务，服务正常</li>
</ol>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>S的上游应用某定时任务在凌晨4:10请求了大量(一次超过200w)的数据将S1先拖死，导致流量全部到S2，S2逐渐不堪重负,导致被系统kill </li>
<li>S对上游数据请求量没有限制，没有启用限流分组功能</li>
<li>告警信息没有引起足够重视,告警被忽略</li>
<li>告警信息仅仅报告给monitor，没有到系统的owner</li>
</ol>
<h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol>
<li>启用限流，分组功能</li>
<li>必须严格执行code review</li>
<li>告警信息必须分级，而且必须同时报告给monitor和系统owner;接警人接到报警后根据不同的级别进行处理</li>
</ol>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>在互联网领域我们为了追求n个9，会采取一系列的流程措施来保障系统的可用性;但，真正落实到位的有多少? 其实，线上故障不可怕，可怕的是没有相应的应对措施；更可怕的是有相应的应对措施，但没有落实到位; 比如: 在服务化推进的过程中架构团队已经提供了限流，分组等功能，而且也进行了宣讲；但，最终这些措施还是没有落实到位；也许这就是大厂和创业公司的区别，大厂里面的架构师大部分也是螺丝钉，只要自己有产出符合预期完成KPI就是一个合格的架构师；但是，创业公司的架构师要考虑更多的因素，从最初的技术方案到设计，实现，最终的落地执行都需要全程参与确保每一个功能真正落实到位</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化准备工作</title>
    <url>/2018/06/18/Parepare-Service/</url>
    <content><![CDATA[<p>在决定进行服务化时，我们做了一些必要的准备工作；从服务治理，链路跟踪，监控以及报警方面到代码层面，运维，流程等多个方面做了相应的调整</p>
<span id="more"></span>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>我们的服务化是在dubbo的基础上进行的，首先适配了服务化需要的相关组件，包括配置中心，链路跟踪，监控，服务治理等，整体架构如图所示 </p>
<p><img src="/2018/06/18/Parepare-Service/arch.jpg" alt="架构图"></p>
<ul>
<li>配置中心: Apollo </li>
<li>链路跟踪: Zipkin, Kafka, ES</li>
<li>服务治理: dubbo官方的dubbo-admin</li>
<li>服务监控: dubbo官方的dubbo-monitor</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="服务化SDK"><a href="#服务化SDK" class="headerlink" title="服务化SDK"></a>服务化SDK</h3><p>我们提供了服务化SDK给业务团队使用；SDK自定义了xsd文件继承了dubbo的xml标签，在此基础上集成了apollo配置；这样业务团队在使用的过程中对一些系统配置不需要关注，比如注册中心，启用监控，启用链路跟踪等 .</p>
<h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><ol>
<li><p>分离Service的API接口到独立的Jar包</p>
</li>
<li><p>检查接口的输入输出参数是否实现了Serializable接口</p>
</li>
<li><p>是否使用了接口参数在方法内部修改后的值，代码如下:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*服务端*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">call</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户端*/</span> </span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">service.call(list);</span><br><span class="line">list.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p> 这个代码在同一个JVM是没有问题，但RPC调用并不能返还预期的结果；</p>
</li>
<li><p>本地事务改造为分布式事务</p>
</li>
<li><p>确保所有的单元测试通过</p>
</li>
</ol>
<h3 id="日志输出增加链路跟踪信息"><a href="#日志输出增加链路跟踪信息" class="headerlink" title="日志输出增加链路跟踪信息"></a>日志输出增加链路跟踪信息</h3><p>每条输出日志包括了zipkin的span id,这样每条日志都能清楚的跟踪到从整个调用链；</p>
<h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>dubbo-monitor对接现有的报警系统，将采集到监控数据上报到现有报警系统,做到实时报警 </p>
<h3 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h3><p>dubbo的服务在正常停止的过程中不再接受新的请求,但是启动后在注册中心完成注册马上开始接受新的请求；我们希望启动后由发布系统控制什么时候开始接受新请求；</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>服务化后对所有的依赖必须基于强版本，所以对每一个发布的服务都提供了强版本策略，而且正常情况下保证每个新版本必须兼容旧版本；版本路线如图所示:<br><img src="/2018/06/18/Parepare-Service/version.jpg" alt="版本"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>  改造现有的流程控制系统，做到每个团队可以独立开发，独立测试，独立部署，独立上线以及独立回滚; 而且保证CI, CD能正常工作,所有流程能自动完成; </p>
<h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>首先拆分出基础服务,包括地址服务，推送服务，图片服务，等与业务无关的服务；其次按照业务领域进行拆分，包括订单，用户中心，支付等</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ul>
<li>服务安全</li>
<li>物理分组 </li>
<li>多维度监控</li>
<li>等…</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>RestTemplate使用Apache HttpClinet连接池默认大小引发耗时瞬间升高</title>
    <url>/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/</url>
    <content><![CDATA[<p>在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由<code>HttpURLConnection</code>,<code>Apache HttpComponents</code>和<code>OkHttp</code>三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高<span id="more"></span></p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>今天天收到报警说我们有一个服务A的接口TP95瞬间升高，打开监控检查发现流量瞬间升高时，耗时会瞬间升高，如图所示；<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/monitor.jpg" alt="图一"><br>打开链路跟踪查看调用链关系，发现该时接口耗时几乎全部耗费在调用下游服务B，如图所示；正常情况下服务B接口TP95耗时在500毫秒以内<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/opentracing.jpg" alt="图二"><br>而且该服务接口连接超时设置2秒，读取超时设置2秒；所以预期内该接口在4秒内应该结束。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="监控检查"><a href="#监控检查" class="headerlink" title="监控检查"></a>监控检查</h4><ol>
<li>查看服务B的监控发现服务B的耗时一直很稳定，几乎没有波动</li>
<li>查看服务C对服务B相同接口的调用在该时刻也很稳定</li>
<li>查看服务A的GC监控，gc最长耗时60ms，也不会引起该问题 </li>
<li>查看网络监控，一切正常</li>
</ol>
<p>通过监控数据基本确定问题不在服务B，另外Ops工程师反馈近期也没做过任何infrastrucre调整；基本确定问题仍然在服务A，接下来review服务A请求服务B的相关代码</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>服务A代码中用<code>RestTemplate</code>调用服务B的接口, <code>RestTemplate</code>的Bean采用默认注入的Builder来生成，而且设置了连接超时和读取超时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">    return builder.setReadTimeout(Duration.ofMillis(readTimeoutConfig)).setConnectTimeout(Duration.ofMillis(connectTimeoutConfig)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码形式<code>RestTemplate</code>底层实现采用了<code>Apache HttpComponents</code>作为HTTP客户端，<code>Apache HttpComponents</code>在初始化过程中会用默认参数初始化连接池，最终代码会执行到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PoolingHttpClientConnectionManager(</span><br><span class="line">    final HttpClientConnectionOperator httpClientConnectionOperator,</span><br><span class="line">    final HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span><br><span class="line">    final long timeToLive, final TimeUnit tunit) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.configData = new ConfigData();</span><br><span class="line">    this.pool = new CPool(new InternalConnectionFactory(</span><br><span class="line">            this.configData, connFactory), 2, 20, timeToLive, tunit);</span><br><span class="line">    this.pool.setValidateAfterInactivity(2000);</span><br><span class="line">    this.connectionOperator = Args.notNull(httpClientConnectionOperator, &quot;HttpClientConnectionOperator&quot;);</span><br><span class="line">    this.isShutDown = new AtomicBoolean(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码第7行构造<code>CPool</code>时传递的常量<code>2</code>表示连接池请求相同域名最大连接数，<code>20</code>表示连接池访问所有域名的最大连接数 。</p>
<p>至此，问题已然清楚，当zeus-order请求量瞬间升高时zeus-order访问zeus的并发量也瞬间增大，如果超过2个并发的HTTP请求只能等待，由于没有设置从连接池获取连接的超时时间，会无限等待，直到连接池内有空闲的HTTP连接然后获取连接继续发出HTTP请求，这样整个请求耗时将可能超过设置的HTTP超时时间</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>基于以上分析，我们使用自定义的HttpClient传递相关参数即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        PoolingHttpClientConnectionManager connectMgr = new PoolingHttpClientConnectionManager() ;</span><br><span class="line">        connectMgr.setDefaultMaxPerRoute(defaultMaxPerRoute);</span><br><span class="line">        connectMgr.setMaxTotal(maxTotal);</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connectMgr)</span><br><span class="line">                .build();</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">                new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        requestFactory.setConnectTimeout(connectTimeoutConfig);</span><br><span class="line">        requestFactory.setReadTimeout(readTimeoutConfig);</span><br><span class="line">        requestFactory.setConnectionRequestTimeout(connectRequestTimeoutConfig);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(requestFactory);</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>自定义三个超时时间：<br><strong>connectTimeout</strong>:            建立连接的超时时间<br><strong>readTimeout</strong>:               读取数据的超时时间<br><strong>connectionRequestTimeout</strong>:  从连接池获取连接的超时时间</p>
<p>修改以后上线观察一天即时出现上述问题的高峰瞬间，耗时始终保持平稳。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式调度系统选型</title>
    <url>/2019/03/30/Schedule-Job/</url>
    <content><![CDATA[<h4 id="为什么需要调度系统"><a href="#为什么需要调度系统" class="headerlink" title="为什么需要调度系统"></a>为什么需要调度系统</h4><p>我们可能有这样的需求:</p>
<ol>
<li>在某个指定的时间点执行一个任务, 比如凌晨对前一天的数据进行汇总;</li>
<li>在某个操作后的指定时刻执行某一操作，比如：电商下单后一小时没有支付的订单需要被取消; </li>
<li>微服务失败后补偿操作;<span id="more"></span></li>
</ol>
<p>类似的需求我们都可以通过定时任务去完成。当然对于需求2，我们也可以利用MQ的延时投递功能去实现；但是，与外部系统交互只能用定时任务。</p>
<h4 id="Java领域主要分布式调度系统"><a href="#Java领域主要分布式调度系统" class="headerlink" title="Java领域主要分布式调度系统"></a>Java领域主要分布式调度系统</h4><ol>
<li>xxl-job：是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 。</li>
<li>Elastic-Job： 当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成；Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务；Elastic-Job-Cloud采用自研Mesos Framework的解决方案，额外提供资源治理、应用分发以及进程隔离等功能；</li>
<li>Saturn：是唯品会开源的一个分布式任务调度平台，在当当开源的Elastic Job基础上，取代传统的Linux Cron&#x2F;Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理；</li>
<li>light-task-scheduler：阿里员工开源的个人项目,主要用于解决分布式任务调度问题，支持实时任务，定时任务和Cron任务。有较好的伸缩性，扩展性，健壮稳定性</li>
<li>Quartz: Java定时任务的标配。利用数据库的锁机制实现集群调度，业务代码需要考虑调度的逻辑，对业务代码有入侵。</li>
</ol>
<p>可能还有一些其它的系统个人不太了解，或者长期不在维护，它不在我们讨论的范畴。在这些系统中以xxl-job和Elastic-Job影响力最大，所以在调研的过程中以这两个系统为主.</p>
<h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><ol>
<li><p>xxl-job架构 </p>
<p><img src="/2019/03/30/Schedule-Job/xxl-job.png" alt="xxl-job架构"></p>
</li>
<li><p>Elastic-Job-Lite架构</p>
<p><img src="/2019/03/30/Schedule-Job/Elastic-Job-Lite.png" alt="Elastic-Job-Lite架构"></p>
</li>
</ol>
<p>从两个系统的架构上可以看出最大的区别是xxl-job有中心化的调度中心，所有的job由调度中心统一调度。而Elastic-Job-Lite没有统一调度中心，由每个Job各自任务节点通过选举算法选出调度节点，确切的说各个job之间没有统一的调度中心 ；Elastic-Job-Cloud依赖Mesos完成调度，资源隔离等工作。</p>
<h4 id="主要功能特性"><a href="#主要功能特性" class="headerlink" title="主要功能特性"></a>主要功能特性</h4><table>
<thead>
<tr>
<th></th>
<th>xxl-job</th>
<th>Elastic-Job</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度中心HA</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>执行器HA</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>弹性扩容缩容</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>失效转移</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>任务失败重试</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>作业分片一致性</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>资源隔离</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>多语言</strong></td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><strong>权限管理</strong></td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<p>从主要功能看上去两者都能提供很好的支持；在多语言支持方面，xxl-job提供通用HTTP任务Handler,业务方只需要提供HTTP链接即可，不限制语言。Elastic-Job目前只能支持Java，其它语言支持需要自行扩展。</p>
<h4 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h4><p>对于开源项目的选择，社区支持是非常重要的因素；强大的社区意味着，在遇到问题的时候可以得到社区资源的支持，否则只能自己解决了；社区支持我们以github的数据为准:</p>
<table>
<thead>
<tr>
<th></th>
<th>xxl-job</th>
<th>Elastic-Job</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Star</strong></td>
<td>7408</td>
<td>4707</td>
</tr>
<tr>
<td><strong>Fork</strong></td>
<td>3121</td>
<td>2216</td>
</tr>
<tr>
<td><strong>Contributers</strong></td>
<td>17</td>
<td>17</td>
</tr>
<tr>
<td><strong>Open Issues</strong></td>
<td>82</td>
<td>115</td>
</tr>
<tr>
<td><strong>Close Issues</strong></td>
<td>602</td>
<td>384</td>
</tr>
<tr>
<td><strong>Latest Updated</strong></td>
<td>24天前</td>
<td>一年前</td>
</tr>
<tr>
<td><strong>已登记使用的公司</strong></td>
<td>163</td>
<td>63</td>
</tr>
</tbody></table>
<p>从以上数据可以看出来，xxl-job在社区支持方面有更大优势 。</p>
<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h4><ul>
<li>xxl-job可以做到开箱即用，配置信息在管理控制台有UI统一配置，更容易上手 ; 包括监控，报警都可以在管理控制台完成。</li>
<li>Elastic-Job配置信息在执行器的spring xml文件完成，监控，报警需要自己定制 。</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>从两者的架构可以发现，在大任务量的情况下，Elastic-Job性能要高于xxl-job 。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>  如果对于技术实力比较强大的团队，而且对性能要求比较搞的情况下，建议选择Elastic-Job，在该基础上进行定制开发，可以取得更好效果；对于技术实力不足，性能能要求不是很高，而且希望快速开发，快速上线建议选择了xxl-job 。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.xuxueli.com/xxl-job">http://www.xuxueli.com/xxl-job</a><br><a href="http://elasticjob.io/">http://elasticjob.io</a><br><a href="https://vipshop.github.io/Saturn">https://vipshop.github.io/Saturn</a><br><a href="https://github.com/ltsopensource/light-task-scheduler">https://github.com/ltsopensource/light-task-scheduler</a></p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>服务化-服务拆分</title>
    <url>/2018/09/24/Service-Split/</url>
    <content><![CDATA[<p>服务化的过程中必然会面对服务拆分的问题；拆分粒度太粗不能体现服务化的优势，拆分过细会导致各项成本过高；所以架构师在服务拆分时要权衡各方面的利弊根据当前情况做出最优解;以下内容是我们团队在使用dubbo的过程，根据实际情况考虑的服务拆分方式；<span id="more"></span></p>
<h3 id="拆分考虑的因素"><a href="#拆分考虑的因素" class="headerlink" title="拆分考虑的因素"></a>拆分考虑的因素</h3><ul>
<li>业务领域</li>
<li>上下层级调用关系</li>
<li>技术因素</li>
<li>成本</li>
</ul>
<p>我们在拆分过程中充分考虑以上4个因素；特别是在业务领域方面有较多的争议；业务领域下可以继续分子领域，所以在实际方案设计过程中部分团队服务拆分太细；经过多次沟通后我们将部分模块合并为一个provider，因为拆分过细对我们会有如下问题：</p>
<ul>
<li>目前我们数据库没有拆分(下阶段会根据个业务线拆库)，服务过细会增加数据库的连接数量</li>
<li>增加了运维成本</li>
<li>增加硬件成本</li>
</ul>
<h3 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h3><ul>
<li>模块按照子业务领域和上下层级拆分</li>
<li>服务调用只能上层服务调用下层服务</li>
<li>禁止provider之间循环调用</li>
<li>相同层级的模块可以作为同一个服务对外发布</li>
<li>模块可以低成本的拆分为一个独立的provider</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                        ___Api</span><br><span class="line">                       |</span><br><span class="line">          ___Model_A--&gt;|</span><br><span class="line">          |            |___Impl</span><br><span class="line">          |            </span><br><span class="line">          |</span><br><span class="line">          |              ___Api</span><br><span class="line">          |             |</span><br><span class="line">Proider--&gt;|___Model_B--&gt;|</span><br><span class="line">          |             |</span><br><span class="line">          |             |___Impl</span><br><span class="line">          |              </span><br><span class="line">          |             </span><br><span class="line">          |____dubbo_provider.xml   </span><br></pre></td></tr></table></figure>

<h4 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h4><ul>
<li>Model_A和Model_B必须是同一层级的模块，比如: 同为数据访问层或者同为业务服务层</li>
<li>对外仅提供各个model的Api</li>
<li>同一个服务可以发布多个模块,节省成本</li>
<li>服务调用只能是上层服务调用下层服务，从而避免服务循环调用</li>
<li>各Model可以低成本的拆分为独立的provider</li>
</ul>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Sharding-JDBC(ShardingSphere)SQL监控实践</title>
    <url>/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/</url>
    <content><![CDATA[<p>最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起<span id="more"></span>。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们的需求是监控应用程序对数据库的SQL执行情况，并将其与现有的指标集成。我们希望监控以下指标（但不限于）：</p>
<ul>
<li>SQL语句的执行时间</li>
<li>SQL语句的执行次数</li>
<li>SQL语句的执行结果</li>
<li>SQL语句的主库和备库路由</li>
</ul>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>我们现有数据库相关技术栈包括MySql, Sharding-JDBC,HikariDataSource和MyBaties；在方案设计阶段，我们考虑了以下三种方案：</p>
<h4 id="ShardingSphere的metrics"><a href="#ShardingSphere的metrics" class="headerlink" title="ShardingSphere的metrics"></a>ShardingSphere的metrics</h4><p> ShardingSphere的agent供了SQL监控的功能，具体可参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/observability/">ShardingSphere的可观测性</a>然而，该代理会暴露一个独立的监控指标页面，无法直接集成到我们现有的监控指标页面中。我们需要单独采集ShardingSphere代理的监控指标，并将其与现有指标进行整合，这增加了一定的复杂性，因此我们放弃了该方案。</p>
<h4 id="Mybaties的拦截器"><a href="#Mybaties的拦截器" class="headerlink" title="Mybaties的拦截器"></a>Mybaties的拦截器</h4><p> 使用MyBatis的拦截器实现SQL监控非常简单，只需实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可。以下是一个示例代码：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line">public class SqlMetricsInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];</span><br><span class="line">        SqlCommandType sqlCommandType = mappedStatement.getSqlCommandType();</span><br><span class="line">        /** 上报sql metrics**/</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        if (target instanceof Executor) &#123;</span><br><span class="line">            return Plugin.wrap(target, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  在容器启动后，我们将该拦截器注入到MyBatis的org.apache.ibatis.session.SqlSessionFactory中：<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line">private ObjectProvider&lt;Interceptor&gt; interceptorsProvider;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ObjectProvider&lt;SqlSessionFactory&gt; sqlSessionFactories;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    for (SqlSessionFactory factory : sqlSessionFactories) &#123;</span><br><span class="line">        for (Interceptor interceptor : interceptorsProvider) &#123;</span><br><span class="line">            factory.getConfiguration().addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过以上步骤，我们可以在现有的监控指标页面中看到采集到的与SQL相关的监控指标。但是，该方案无法区分主库和备库的SQL。</p>
<h4 id="JDBC-Statement"><a href="#JDBC-Statement" class="headerlink" title="JDBC Statement"></a>JDBC Statement</h4><p>  我们知道，最终的SQL执行是通过JDBC的Statement完成的，因此我们可以直接在JDBC的Statement执行SQL的地方上报监控指标。我们可以自定义Statement来执行SQL，并同时上报SQL的监控指标。以下是类关系图示例：<br>   <img src="/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/ShardingSphere-JDBC-SQL-Metrics-class.png"></p>
<p>   在<code>DalStatement</code>和<code>PreparedStatement</code> 重载<code>executeQuery</code>和<code>executeUpdate</code> 方法增加相关监控指标，具体代码可参考<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">ydal-spring-boot-starter</a></p>
<p>   这样可以输出类似如下的metrics上报到prometheus<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql_execute_time_seconds_count&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 82.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 12.373654891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 14.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 167.934782891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 1.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 0.493257718</span><br></pre></td></tr></table></figure><br>   通过这种方式，我们可以在现有的监控指标页面中查看采集到的SQL监控指标，并区分主库和备库的SQL。 详细代码：<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a> </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次SQL监控的实践，我们成功地集成了SQL监控功能到我们的应用程序中，并将其与现有的指标集成在一起。这使得我们能够更好地了解应用程序对数据库的访问情况，并及时发现潜在的性能问题和瓶颈。我们选择了自定义的JDBC Statement来实现SQL监控，并通过上报监控指标的方式将其集成到现有的监控系统中。这种方案简单且有效，使我们能够对SQL执行进行精确监控，并根据需要进行进一步的优化和调整。尽管我们在本次实践中取得了成功，但我们也意识到SQL监控仅仅是性能优化和数据库访问管理的一部分。在未来的项目中，我们将继续探索更多的数据库访问优化技术，并进一步提高应用程序的性能和可伸缩性。</p>
]]></content>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Session Memcached集群迁移至Redis集群</title>
    <url>/2022/10/22/Session-Memcached-To-Redis/</url>
    <content><![CDATA[<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>随着业务的快速发展，我们原有的 <code>session</code> 存储方案  <code>Memcached</code>  逐渐显露出一些瓶颈，主要体现在以下几个方面。：</p>
<ul>
<li><strong>扩展性受限</strong>：<code>Memcached</code> 集群不支持分片，要分片需要在客户端实现分片逻辑，<strong>扩容和缩容操作繁琐</strong>，运维成本较高，难以满足业务快速增长的需求<span id="more"></span>。</li>
<li><strong>监控能力薄弱</strong>：<code>Memcached</code>  提供的<strong>监控指标有限</strong>，难以全面掌握集群运行状态，<strong>故障排查和告警</strong>不够便捷。</li>
<li><strong>缺少持久化</strong>：<code>Memcached</code>  作为纯内存缓存，<strong>数据无法持久化</strong>，存在数据丢失风险，虽然 <code>session</code> 数据对持久化要求不高，但在某些极端情况下，数据丢失仍可能影响用户体验。</li>
</ul>
<p>为了解决  <code>Memcached</code>  的上述问题，并提升  <code>session</code>  存储的<strong>扩展性、可维护性和监控能力</strong>，我们决定将  <code>session</code>  存储方案迁移至  <strong>Redis 集群</strong>。<code>Redis</code>  集群在<strong>集群化、监控告警、数据持久化</strong>等方面都具备显著优势，能够更好地满足我们业务发展的需求。</p>
<h3 id="迁移方案与实施阶段"><a href="#迁移方案与实施阶段" class="headerlink" title="迁移方案与实施阶段"></a>迁移方案与实施阶段</h3><p>本次  <code>session</code>  迁移项目，我们采取了<strong>分阶段、平滑迁移</strong>的策略，最大程度降低迁移风险，保障业务的连续性和稳定性。整个迁移过程分为三个阶段：</p>
<pre class="mermaid">graph TD
    subgraph "第一阶段"
        A1[应用服务] --> |写| B1[Memcached]
        A1 --> |写| C1[Redis]
        B1 --> |读| A1
    end
    
    subgraph "第二阶段"
        A2[应用服务] --> |写| B2[Memcached]
        A2 --> |写| C2[Redis]
        C2 --> |读| A2
    end
    
    subgraph "第三阶段"
        A3[应用服务] --> |写| C3[Redis]
        C3 --> |读| A3
        B3[Memcached] -.-> |停止写入| A3
    end</pre>


<ul>
<li><p><strong>第一阶段：双写 Memcached 和 Redis，读 Memcached</strong></p>
<ul>
<li><strong>目标</strong>：验证  <code>Redis</code>  集群的稳定性和性能，为后续切换读取流量做好数据准备。</li>
<li><strong>策略</strong>：应用系统同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>只从  <code>Memcached</code>  读取  <code>session</code>  数据</strong>。</li>
<li><strong>数据一致性保障</strong>：<strong>双写成功才算成功</strong>，确保  <code>Memcached</code>  和  <code>Redis</code>  数据一致性。任何写入失败都会记录详细日志并触发告警，方便后续数据补偿。</li>
<li><strong>持续时间</strong>：为了保证  <code>Redis</code>  集群中  <code>session</code>  数据的完整性，双写阶段持续 <strong>30 天</strong>，覆盖  <code>session</code>  的最长过期时间，确保  <code>Redis</code>  集群拥有全量  <code>session</code>  数据。</li>
</ul>
</li>
<li><p><strong>第二阶段：双写 Memcached 和 Redis，读 Redis</strong></p>
<ul>
<li><strong>目标</strong>：将读取流量平滑切换到  <code>Redis</code>  集群，验证  <code>Redis</code>  集群在高并发读取场景下的性能表现。</li>
<li><strong>策略</strong>：应用系统仍然同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>读取操作切换至  <code>Redis</code>  集群</strong>。</li>
<li><strong>平滑切换</strong>：采用<strong>灰度发布</strong>策略，逐步将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，降低切换风险。</li>
<li><strong>回滚准备</strong>：<strong>保留  <code>Memcached</code>  的写入</strong>，为后续可能的回滚操作预留数据基础。</li>
</ul>
</li>
<li><p><strong>第三阶段：停止 Memcached 写入，读 Redis</strong></p>
<ul>
<li><strong>目标</strong>：完全切换到  <code>Redis</code>  集群，停用  <code>Memcached</code>。</li>
<li><strong>策略</strong>：<strong>停止向  <code>Memcached</code>  写入  <code>session</code>  数据</strong>，所有读写操作均转向  <code>Redis</code>  集群。</li>
<li><strong>风险评估</strong>：在进入第三阶段前，进行全面的<strong>风险评估</strong>，确认系统运行稳定，各项监控指标正常。由于第二阶段已经验证了  <code>Redis</code>  集群的读取能力，且  <code>Memcached</code>  写入持续运行，因此第三阶段的风险较低。</li>
</ul>
</li>
</ul>
<h3 id="关键技术挑战与解决方案"><a href="#关键技术挑战与解决方案" class="headerlink" title="关键技术挑战与解决方案"></a>关键技术挑战与解决方案</h3><p>在  <code>session</code>  迁移过程中，我们主要面临以下技术挑战：</p>
<ul>
<li><strong>数据一致性</strong>：在双写阶段，如何保证  <code>Memcached</code>  和  <code>Redis</code>  的数据一致性至关重要。我们通过<strong>双写强一致性策略</strong>和完善的<strong>异常监控告警机制</strong>来解决这个问题。</li>
<li><strong>平滑切换</strong>：如何平滑地将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，避免对用户体验造成影响。我们采用<strong>灰度发布</strong>策略，逐步切换流量，并密切监控系统运行状态。</li>
<li><strong>性能保障</strong>：<code>Redis</code>  集群在高并发场景下的性能是否能够满足需求，需要进行充分的验证。我们在第二阶段通过<strong>全量流量读取  <code>Redis</code>  集群</strong>，验证了  <code>Redis</code>  集群的性能表现。</li>
<li><strong>监控与回滚</strong>：如何全面监控迁移过程，及时发现和处理异常，并制定完善的回滚方案，保障迁移过程的安全可控。利用我们<strong>完善的监控体系</strong>，针对每个阶段制定了详细的<strong>回滚计划</strong>。</li>
</ul>
<h3 id="性能监控与回滚方案"><a href="#性能监控与回滚方案" class="headerlink" title="性能监控与回滚方案"></a>性能监控与回滚方案</h3><p>为了保障  <code>session</code>  迁移项目的平稳落地，我们建立了完善的性能监控和回滚方案：</p>
<h4 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h4><p>在整个迁移过程中，我们重点监控以下关键指标：</p>
<ul>
<li><strong>Redis 集群性能指标</strong>：<ul>
<li><strong>CPU 使用率、内存使用率</strong>：监控  <code>Redis</code>  集群资源使用情况，判断集群是否过载。</li>
<li><strong>请求延迟</strong>：监控  <code>Redis</code>  请求响应时间，评估  <code>Redis</code>  集群性能是否满足需求。</li>
<li><strong>错误率</strong>：监控  <code>Redis</code>  请求错误率，及时发现  <code>Redis</code>  集群异常。</li>
<li><strong>大key和热key</strong>：关注  <code>Redis</code>  的流量和CPU变化是否出现<strong>大key和热key</strong>。</li>
</ul>
</li>
<li><strong>Session 读写成功率</strong>：<ul>
<li><strong>Redis  <code>session</code>  读取成功率</strong>：监控从  <code>Redis</code>  集群读取  <code>session</code>  的成功率，确保读取操作正常。</li>
<li><strong>Redis  <code>session</code>  写入成功率</strong>：监控向  <code>Redis</code>  集群写入  <code>session</code>  的成功率，确保写入操作正常。</li>
<li><strong>Memcached  <code>session</code>  写入成功率</strong>：在双写阶段，监控向  <code>Memcached</code>  写入  <code>session</code>  的成功率，确保双写操作正常。</li>
</ul>
</li>
<li><strong>应用系统业务指标</strong>：<ul>
<li><strong>接口响应时间</strong>：监控应用系统接口响应时间，评估迁移对应用系统性能的影响。</li>
<li><strong>错误率</strong>：监控应用系统错误率，评估迁移是否引入新的错误。</li>
<li><strong>登录用户指标</strong>：监控登录用户数量变化，判断迁移是否影响用户登录。</li>
<li><strong>各阶段转化率</strong> (加购，生单，支付)：监控用户在各个关键业务流程的转化率，评估迁移是否对业务指标造成负面影响。</li>
</ul>
</li>
</ul>
<h4 id="2-回滚方案"><a href="#2-回滚方案" class="headerlink" title="2. 回滚方案"></a>2. 回滚方案</h4><ul>
<li><strong>回滚触发</strong>：当监控指标出现异常，例如：应用系统接口响应时间显著增加、业务指标出现明显波动等情况时，立即触发回滚。</li>
<li><strong>回滚步骤</strong>：<ol>
<li><strong>流量切换</strong>：立即将  <code>session</code>  读取流量<strong>回退到  <code>Memcached</code></strong>。由于第二阶段持续保持  <code>Memcached</code>  写入，<code>Memcached</code>  中仍然保有全量  <code>session</code>  数据，可以快速切换回读。</li>
<li><strong>问题排查</strong>：回滚后，立即排查  <code>Redis</code>  集群异常原因，修复问题。</li>
<li><strong>重新迁移</strong>：待问题解决后，重新评估并选择合适的时机再次进行迁移。</li>
</ol>
</li>
</ul>
<p>由于我们在第二阶段已经进行了充分的  <code>Redis</code>  集群读取验证，并且在第三阶段前进行了全面的风险评估，因此实际上<strong>并未触发回滚</strong>。  <strong>第二阶段保留  <code>Memcached</code>  写入的主要目的就是为了应对可能的回滚场景</strong>，为系统提供一层额外的安全保障。</p>
<h3 id="项目总结与收益"><a href="#项目总结与收益" class="headerlink" title="项目总结与收益"></a>项目总结与收益</h3><p><code>session</code> 从 <code>Memcached</code> 平滑迁移至 <code>Redis</code> 集群项目，历时数月，整个迁移过程较为顺利，最终<strong>平稳落地，达到预期目标</strong>。通过本次迁移，我们成功解决了 <code>Memcached</code> 在<strong>扩展性、监控能力</strong>等方面的瓶颈，为业务发展提供了更可靠、更高效的 <code>session</code> 存储方案。</p>
<p><strong>项目收益总结</strong>：</p>
<ul>
<li><strong>提升扩展性</strong>：<code>Redis</code> 集群具备良好的<strong>水平扩展能力</strong>，可以轻松应对未来 <code>session</code> 数据量的增长。相比原来需要在客户端实现分片的 <code>Memcached</code> 方案，<code>Redis</code> 集群的扩容和缩容操作更加简单直观，极大降低了运维成本。</li>
<li><strong>增强监控能力</strong>：<code>Redis</code> 集群提供<strong>更丰富的监控指标</strong>，并能与 <code>Prometheus</code> 等监控系统方便集成，提升运维效率。</li>
<li><strong>性能稳定</strong>：迁移后系统性能与原 <code>Memcached</code> 方案基本持平，但在运维性和可扩展性方面获得了显著提升，为未来业务增长预留了充足的扩展空间。</li>
<li><strong>为未来优化奠定基础</strong>：迁移至 <code>Redis</code> 集群，为后续 <code>session</code> 存储的<strong>性能优化、功能增强</strong>（例如，利用 <code>Redis</code> 更丰富的数据结构实现更复杂的 <code>session</code> 管理功能）奠定了基础。</li>
</ul>
<p>本次  <code>session</code>  迁移项目，  <strong>分阶段平滑迁移策略、完善的监控回滚方案、以及对数据一致性的高度重视</strong>，是项目成功的关键因素。  这些经验也为我们后续进行类似的大型系统迁移项目提供了宝贵的参考.</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>跨境电商支付系统重构实战：从单体到微服务的演进</title>
    <url>/2021/01/09/Payement-Rebuild/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们的支付系统最初作为单体应用的子模块存在，随着业务规模扩大，高并发下的<strong>掉单</strong>和<strong>重复支付</strong>问题频发，日均人工对账成本高达数小时。为解决这些痛点并支持未来业务扩展，我们决定将支付系统重构为独立的微服务架构，核心目标包括：<span id="more"></span><br><strong>稳定性</strong>：消除中间状态不一致导致的掉单<br><strong>可扩展性</strong>：快速接入新的支付渠道<br><strong>可维护性</strong>：降低模块耦合，提升迭代效率</p>
<h2 id="系统架构概览"><a href="#系统架构概览" class="headerlink" title="系统架构概览"></a>系统架构概览</h2><p>新的支付系统采用微服务架构并使用Docker部署，主要分为以下四个子服务：</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>职责描述</th>
<th>特性要求</th>
</tr>
</thead>
<tbody><tr>
<td><code>pay-front</code></td>
<td>处理用户端支付请求，高并发优化</td>
<td>秒级弹性扩展</td>
</tr>
<tr>
<td><code>pay-backend</code></td>
<td>对接后端系统（如 OMS），保障交易稳定性</td>
<td>99.99% 可用性</td>
</tr>
<tr>
<td><code>pay-admin</code></td>
<td>管理后台配置（支付路由、规则）</td>
<td>配置变更秒级生效</td>
</tr>
<tr>
<td><code>pay-job</code></td>
<td>执行定时任务（对账、退款补偿）</td>
<td>分布式任务调度</td>
</tr>
</tbody></table>
<h4 id="服务间交互"><a href="#服务间交互" class="headerlink" title="服务间交互"></a>服务间交互</h4><ul>
<li><strong>pay-front:</strong> 接收到用户支付请求后，调用第三方支付渠道的接口进行支付处理。支付成功后通过 RabbitMQ 推送支付成功消息。</li>
<li><strong>pay-backend:</strong> 通过RPC接口接收来自后端系统（如 OMS）的查询和人工退款请求。</li>
<li><strong>pay-admin:</strong> 通过操作数据库（主库）来管理支付规则、支付路由等配置，并会主动使Redis缓存中的相关配置失效，使得下次用户请求时能够从数据库加载最新的配置。</li>
<li><strong>pay-job:</strong> 主要与数据库进行交互，执行定时任务，例如检查长时间处于中间状态的订单（支付中、退款中），并同步第三方支付渠道的状态来更新订单的最终状态。</li>
</ul>
<h4 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h4><p><strong>主从分离 + 读写隔离</strong>：</p>
<pre class="mermaid" style="text-align: center;">
            
            graph TD
    A[主库（写）] --> B[从库1（pay-front读）]
    A --> C[从库2（其他服务读）]
          </pre>


<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>为了降低学习成本和提高开发效率，我们选择了团队目前最熟悉的技术栈：</p>
<ul>
<li><strong>开发语言:</strong> Java</li>
<li><strong>微服务框架:</strong> SpringCloud</li>
<li><strong>配置中心和注册中心:</strong> Consul</li>
<li><strong>缓存:</strong> Redis集群</li>
<li><strong>数据库:</strong> MySQL 主从分离</li>
<li><strong>消息队列:</strong> RabbitMQ</li>
<li><strong>链路跟踪</strong> Jaeger</li>
<li><strong>监控报警</strong>：Prometheus+Grafana+AlertManager</li>
<li><strong>日志</strong>：ELK</li>
<li><strong>容器化:</strong> Docker</li>
</ul>
<h2 id="核心功能实现"><a href="#核心功能实现" class="headerlink" title="核心功能实现"></a>核心功能实现</h2><p>新的支付系统涵盖了跨境电商支付的核心功能，包括：</p>
<ul>
<li>下单支付</li>
<li>退款</li>
<li>支付查询</li>
<li>对账</li>
<li>与全球10+三方支付渠道的集成</li>
</ul>
<h4 id="幂等性保障"><a href="#幂等性保障" class="headerlink" title="幂等性保障"></a>幂等性保障</h4><p><strong>问题</strong>：第三方支付回调重复导致订单状态混乱</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>幂等 Key 生成</strong>：<code>订单号+支付渠道+时间戳</code>哈希值</li>
<li><strong>存储层校验</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO payment (id, order\_id, status, version)&amp;#x20;</span><br><span class="line"></span><br><span class="line">VALUES (?, ?, &#x27;PROCESSING&#x27;, 1)&amp;#x20;</span><br><span class="line"></span><br><span class="line">ON DUPLICATE KEY UPDATE version=version+1;</span><br></pre></td></tr></table></figure>
<p><strong>第三方透传</strong>：在请求参数中携带幂等 Key，确保唯一请求标识</p>
<h4 id="最终一致性保障"><a href="#最终一致性保障" class="headerlink" title="最终一致性保障"></a>最终一致性保障</h4><p><strong>中间状态处理流程</strong>：</p>
<pre class="mermaid" style="text-align: center;">
            
            sequenceDiagram
    participant User
    participant pay-front
    participant 第三方支付
    participant pay-job
    
    User->>pay-front: 用户在电商平台发起支付
    pay-front->>第三方支付: 携带幂等Key请求
    第三方支付-->>pay-front: 返回支付中
    pay-front->>pay-job: 记录中间状态
    pay-job->>第三方支付: 定时查询状态（每5分钟）
    第三方支付-->>pay-job: 返回最终状态
    pay-job->>数据库: 更新订单状态
          </pre>
<h4 id="配置动态生效"><a href="#配置动态生效" class="headerlink" title="配置动态生效"></a>配置动态生效</h4><p><code>pay-admin</code> 修改数据库配置后，触发 Redis 缓存失效；<code>pay-front</code>下次请求时从数据库加载最新配置</p>
<h4 id="错误处理与一致性"><a href="#错误处理与一致性" class="headerlink" title="错误处理与一致性"></a>错误处理与一致性</h4><p>设计<code>支付中</code>和<code>退款中</code>的中间状态，通过定时任务检查并更新订单状态以保证数据最终一致性。</p>
<h2 id="高可用与监控"><a href="#高可用与监控" class="headerlink" title="高可用与监控"></a>高可用与监控</h2><h3 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a>监控体系</h3><table>
<thead>
<tr>
<th>维度</th>
<th>工具</th>
<th>监控指标</th>
</tr>
</thead>
<tbody><tr>
<td>性能监控</td>
<td>Prometheus+Grafana</td>
<td>QPS、RT、线程池利用率</td>
</tr>
<tr>
<td>日志分析</td>
<td>ELK</td>
<td>支付链路日志、异常堆栈</td>
</tr>
<tr>
<td>分布式追踪</td>
<td>Jaeger</td>
<td>服务间调用耗时、错误节点定位</td>
</tr>
</tbody></table>
<h2 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h2><p><strong>灰度发布流程</strong>：</p>
<pre class="mermaid" style="text-align: center;">
            
            graph LR
    A[旧系统] --> B{流量分配}
    B -->|5%| C[新系统]
    B -->|95%| A
    C --> D[监控中心]
    D -->|异常| E[触发回滚]
    D -->|稳定| F[逐步增加至100%]
          </pre>
<p>我们采用了灰度发布的方式来上线新系统。首先将少量（5%）的用户流量切换到新系统，在一周内逐步增加流量到20%，稳定运行一周后，才进行全量切换。同时，我们的新系统接口能够兼容新旧数据格式，确保可以平滑过渡。</p>
<h2 id="关键挑战与解决方案"><a href="#关键挑战与解决方案" class="headerlink" title="关键挑战与解决方案"></a>关键挑战与解决方案</h2><h4 id="挑战-1：新旧系统平滑切换"><a href="#挑战-1：新旧系统平滑切换" class="headerlink" title="挑战 1：新旧系统平滑切换"></a>挑战 1：新旧系统平滑切换</h4><p>本次重构最大的挑战在于如何在保障现有系统稳定运行的前提下，平滑地切换到新的支付系统，并且几乎不对现有业务造成任何影响。我们主要通过以下策略来应对：</p>
<ul>
<li><strong>灰度发布:</strong> 逐步将用户流量导向新系统，降低风险。</li>
<li><strong>接口兼容:</strong> 新系统接口兼容旧数据格式，减少调用方改动。</li>
<li><strong>完善的监控和回滚计划:</strong> 实时监控系统状态，并制定了详细的回滚方案，以应对可能出现的问题。</li>
</ul>
<h4 id="挑战-2：第三方支付渠道适配"><a href="#挑战-2：第三方支付渠道适配" class="headerlink" title="挑战 2：第三方支付渠道适配"></a>挑战 2：第三方支付渠道适配</h4><p><strong>统一接入层设计</strong>：</p>
<ul>
<li>工厂模式：抽象PaymentChannelFactory，根据渠道ID自动路由到具体实现（如PayPal、Stripe）；</li>
<li>​模板方法模式：定义支付流程标准骨架（创建订单→调用渠道→状态回调），子类仅实现差异步骤。</li>
</ul>
<h2 id="收益与总结"><a href="#收益与总结" class="headerlink" title="收益与总结"></a>收益与总结</h2><p>新的支付系统上线至今，我们已经取得了显著的收益：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>旧系统</th>
<th>新系统</th>
<th>提升幅度</th>
</tr>
</thead>
<tbody><tr>
<td>日均掉单数</td>
<td>20+</td>
<td>0</td>
<td>100%</td>
</tr>
<tr>
<td>支付接口响应时间</td>
<td>1000ms</td>
<td>300ms</td>
<td>70%</td>
</tr>
<tr>
<td>新支付方式接入周期</td>
<td>5 天</td>
<td>1.5 天</td>
<td>70%</td>
</tr>
<tr>
<td>人工对账成本</td>
<td>4 小时 &#x2F; 天</td>
<td>0.5 小时 &#x2F; 天</td>
<td>87.5%</td>
</tr>
</tbody></table>
<p>本次支付系统的重构是一次成功的实践，我们不仅解决了旧系统的历史遗留问题，也为未来的业务发展奠定了坚实的技术基础。通过采用微服务架构、熟悉的技术栈和稳健的部署策略，我们实现了系统的平滑过渡，并显著提升了系统的稳定性、可扩展性和可维护性。</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Sharding-JDBC(ShardingSphere)多数据库与springboot集成 -- 读写分离</title>
    <url>/2020/04/11/ShardingSphere-Springboot/</url>
    <content><![CDATA[<p>Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入<code>sharding-jdbc-spring-boot-starter</code>可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。<span id="more"></span></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h3><ul>
<li><p>实现<code>EnvironmentAware</code>接口 ，在方法<code>setEnvironment</code>解析properties配置可以获取所有配置信息</p>
</li>
<li><p>获取以<code>spring.ydal</code>为前缀的所有数据库配置</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; databases = PropertyUtil.handle(environment, &quot;spring.ydal&quot; , Map.class);</span><br></pre></td></tr></table></figure>

<ul>
<li>构造每个数据库的数据库的MasterSlave数据源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;datasource&quot;, Map.class);</span><br><span class="line"> Preconditions.checkState(!dataSourceProps.isEmpty(), &quot;Wrong datasource properties!&quot;);</span><br><span class="line"></span><br><span class="line"> DataSource datasource = DataSourceUtil.getDataSource(dataSourceProps.get(&quot;type&quot;).toString(), dataSourceProps);</span><br><span class="line"> Optional&lt;DataSourcePropertiesSetter&gt; dataSourcePropertiesSetter = DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get(&quot;type&quot;).toString());</span><br><span class="line"> if (dataSourcePropertiesSetter.isPresent()) &#123;</span><br><span class="line">     dataSourcePropertiesSetter.get().propertiesSet(environment, prefix, dataSourceName, datasource);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">masterSlaveRule = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.masterslave&quot;, YamlMasterSlaveRuleConfiguration.class);</span><br><span class="line">MasterSlaveRuleConfiguration msConfig = new MasterSlaveRuleConfigurationYamlSwapper().swap(masterSlaveRule);</span><br><span class="line"></span><br><span class="line">Properties dsProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.props&quot;, Properties.class);</span><br><span class="line">MasterSlaveDataSourceFactory.createDataSource(datasource, msConfig, dsProps)</span><br></pre></td></tr></table></figure>

<h3 id="禁用ShardingSphere的Springboot的自动配置"><a href="#禁用ShardingSphere的Springboot的自动配置" class="headerlink" title="禁用ShardingSphere的Springboot的自动配置"></a>禁用ShardingSphere的Springboot的自动配置</h3><p>实现该扩展后以jar包的形式提供出去供多个项目使用，所以我们必须在jar里面禁用ShardingSphere的Springboot的自动配置；可以实现如下接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class YdalAutoConfigurationImportFilter implements AutoConfigurationImportFilter &#123;</span><br><span class="line">    private static final Set&lt;String&gt; SHOULD_SKIP = new HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(&quot;org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration&quot;));</span><br><span class="line">    @Override</span><br><span class="line">    public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">        boolean[] matches = new boolean[autoConfigurationClasses.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt; autoConfigurationClasses.length; i++) &#123;</span><br><span class="line">            matches[i] = !SHOULD_SKIP.contains(autoConfigurationClasses[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return matches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>YdalAutoConfigurationImportFilter</code>加入<code>META-INF/spring.factories</code></li>
</ul>
<h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><ul>
<li>详细代码： <a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a></li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>技术给业务赋能</title>
    <url>/2019/04/27/Tech-VS-Biz/</url>
    <content><![CDATA[<p>技术人员在技术选型的时候如何做好技术与业务的平衡，如何推广技术方案，甚至与产品人员沟通改变某些功能的实现方式，这些问题值得每一个技术人员思考。我们不管采用什么技术方案，最终目的是为了帮助业务发展，使公司在商业上获取回报。如果技术人员能有一些产品和运营的思维，对整个业务的发展会起到更好的效果。<span id="more"></span></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型我们要考虑很多因素：产品所处的阶段，技术栈，当前的技术实力，技术债务，时间,等… 。特别是产品的不同阶段其目标也不同：</p>
<ol>
<li><p>初创阶段：这个阶段重点考虑两个方面：</p>
<ul>
<li>1.1 <strong>快</strong>：这个时候重点是<strong>快速上线</strong>，快速验证。同时，技术人员应该注意到有些需求产品人员没有提出来，但以后肯定有这个需求，只是当前优先级比较低。所以技术人员应该考虑到这些需求对现有方案可能存在的影响；如果是举手之劳的事情就顺便实现，至少在设计表结构时应该考虑到。可能有人会说该阶段到底哪些需求应该考虑，哪些不应该考虑；我个人的想法是支撑半年内业务的发展不需要重构为目标。所以在出方案前一定要跟产品，运营等业务方充分沟通拿到所有的数据，比如：半年后PV到多少，单量是多少等业务数据，以此为目标。</li>
<li>1.2 <strong>可维护性</strong>：产品第一版上线后，会持续迭代和bug修复；从可维护性的角度应该考虑这几点：<ul>
<li>当前团队有相应的技术储备</li>
<li>业界有大量的工程师正在使用的技术</li>
<li>如果是开源项目,其社区足够庞大，如果是商业项目需要有充分的技术支持</li>
<li>一定是让团队内部最资深的工程师开始写第一行代码，因为所有的项目在重构前，代码一定会越写越烂</li>
</ul>
</li>
</ul>
</li>
<li><p>成长阶段 ：这个阶段产品的商业模式已经被验证过，产品正在为大量的用户提供服务，而且业务正在快速发展中，此时的技术方案以不影响现有业务为前提，或者说将影响降到最低，就是行业内所说的<strong>给飞行中的飞机换引擎</strong> 。 个人认为此阶段的技术方案应该重点考虑<strong>可落地</strong> ,一般这个阶段团队也会扩大，同时会引入一些外部人才。这个时候会出现一些新的思想，新的方案，此时要特别注意这些方案是不是立足于本团队的实际情况。特别一些大厂背景的工程师，可能会给出一些高大上的方案，但是各项成本可能非常高。即便是一些规模相当友商团队的工程师过来给出的方案也不一定能马上落地，因为没有一家企业的流程，制度，文化跟另一家企业是完全一样的，技术方案本质是用技术的手段解决业务的问题，流程的问题，质量的问题，效率的问题，成本的问题。</p>
</li>
</ol>
<h3 id="技术方案推广"><a href="#技术方案推广" class="headerlink" title="技术方案推广"></a>技术方案推广</h3><p>有人说一个技术方案的效果只有在实施后才能知道，我个人认为一个技术方案如果推广成本太高一定不是一个好的方案。在出方案时候就应该考虑到如何去推广，一般情况下开发团队时间很紧迫，不可能为了一个技术改造耽误太多时间。我个人的做法是在出方案前跟相关团队沟通清楚当前面对的问题，以及各个团队的诉求。根据具体的问题给出适合的方案，接下来跟自己的领导沟通方案以及部分细节，确保能得到领导的支持「这点非常重要」；再准备方案，包括但不限于相应的文档，代码，工具，流程等；在正式推广之前，召集所有团队相关负责人「甚至所有技术人员」宣讲，主要包括几个方面：面对的问题，应对方案，如何实施，相关团队如何配合与执行，达到的效果，deadline 。特别是团队配合与执行部分给出详细的执行步骤，以及常见的QA。要站在执行团队的立场上考虑问题，让执行团队充分意识到，采用了新方案后可以提升效率，提升质量或者节省成本，等；可能经过多次沟通后仍有部分团队不能配合执行，此时只能将问题上升到更高一层管理者来协调 。技术方案的实施要充分权衡成本与业务的影响，比如一个案例：业务方要求实施方案不允许停机，然而跟业务方沟通告知不停机的成本太高，最终选择了凌晨业务低峰时期停机20分钟来完成，实际实施的过程中真正停机的时间只有5分钟；然而，该时间段对业务的影响也非常低，因此最终的方案都是权衡各方的利益后博弈的结果。方案实施后要监控各项指标，查看各项指标是否符合预期，如果没有达到预期目标，一定要找到根本原因是方案本身的问题，还是执行过程的问题，避免相同的问题再次出现。</p>
<h3 id="与产品人员沟通"><a href="#与产品人员沟通" class="headerlink" title="与产品人员沟通"></a>与产品人员沟通</h3><p>我们经常看到一些关于产品人员和技术人员相爱相杀的段子，我认为现实中这样的例子并不多「也许我经历少」。技术人员拿到PRD后要仔细分析PRD背后的逻辑和诉求，有些看似简单需求背后可能需要复杂的技术支撑，不是每一个产品人员都有技术背景，此时需要技术人员跟产品人员充分沟通该需求的实现成本「理论上来说所有的需求都是可以实现的」，帮助产品人员梳理出重点和优先级，适当的时候可以减少需求或者改变产品逻辑。切忌一句“这是一个伪需求”或“这个需求实现不了” ；如果认为是伪需求请给出具体的数据，一切以数据为依据 ，即使实现不了也应该告知当前的困难，是资源问题，还是时间的问题等。如果多次沟通都没效果建议换个产品人员伺候，如果你没有选择的余地或者你认为公司都是这种产品人员，建议还是换工作吧。</p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>技术的世界比较简单，确定的输入一定可以得到确定的输出，然而，我们的世界并不总是这样，有很多东西是没有绝对的对错之分。技术人员可以经常与非技术人员聊聊，听听他们看问题的角度，听听他们的诉求；也许这样可以让技术更好的帮助业务成长。</p>
]]></content>
  </entry>
  <entry>
    <title>Dify 源码改造：自定义品牌实践</title>
    <url>/2025/09/20/dify-custom-brand/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Dify 是一款开源的大语言模型（LLM）应用开发平台，凭借其灵活的插件机制和可视化编排能力，成为企业构建 AI 应用的热门选择。我们希望通过品牌(以品牌 <code>YZHU</code> 为例)定制让 Dify 平台融入其企业形象，强化用户对品牌的认知。<span id="more"></span></p>
<p>本次变更聚焦于品牌定制，覆盖前端界面（标题、Logo）和嵌入式脚本（交互图标），形成了一套完整的品牌替换流程。这种场景在开源项目二次开发中非常常见：企业需要通过品牌替换和配置调整，让工具更贴合业务需求。本文记录了此次变更的实践细节，希望为其他开发者提供可复用的参考模板。</p>
<h2 id="核心变更的技术细节"><a href="#核心变更的技术细节" class="headerlink" title="核心变更的技术细节"></a>核心变更的技术细节</h2><p>本次变更涉及 <strong>前端资源</strong> 和 <strong>嵌入式脚本</strong> 两个模块，围绕品牌定制目标展开。以下从技术视角逐一解析关键修改点。</p>
<h3 id="前端资源"><a href="#前端资源" class="headerlink" title="前端资源"></a>前端资源</h3><p>前端资源是品牌定制的核心，目标是将 “Dify” 品牌替换为 “YZHU”，并优化视觉和无障碍体验。</p>
<h4 id="1-页面标题"><a href="#1-页面标题" class="headerlink" title="1. 页面标题"></a>1. 页面标题</h4><p>修改 <code>web/hooks/use-document-title.ts</code> 中的标题拼接逻辑，将 <code>${prefix}Dify</code> 替换为 <code>${prefix}YZHU</code>，确保所有页面标题（如 “Home - Dify”）显示为 “Home - YZHU”：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// web/hooks/use-document-title.ts</span><br><span class="line"><span class="deletion">- const title = `$&#123;prefix&#125;Dify`;</span></span><br><span class="line"><span class="addition">+ const title = `$&#123;prefix&#125;YZHU`;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试方法</strong>：运行 <code>npm run dev</code>，打开浏览器检查页面标题后缀是否正确更新为 “ - YZHU” 。</p>
<h4 id="2-Logo-描述"><a href="#2-Logo-描述" class="headerlink" title="2. Logo 描述"></a>2. Logo 描述</h4><p>更新以下文件中 Logo 图片的 <code>alt</code> 属性，从 “Dify logo” 改为 “YZHU logo”，提升搜索引擎优化（SEO）和无障碍访问体验（屏幕阅读器会读取 <code>alt</code> 文本）：</p>
<ul>
<li><code>web/app/account/(commonLayout)/header.tsx</code></li>
<li><code>web/app/components/base/logo/dify-logo.tsx</code></li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// web/app/components/base/logo/dify-logo.tsx</span><br><span class="line"><span class="deletion">- &lt;img src=&quot;logo.svg&quot; alt=&quot;Dify logo&quot; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;img src=&quot;logo.svg&quot; alt=&quot;YZHU logo&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>alt</code> 属性的修改需确保描述准确，反映品牌名称，有助于搜索引擎抓取和无障碍工具识别。</p>
<h4 id="3-Logo-图片更新"><a href="#3-Logo-图片更新" class="headerlink" title="3. Logo 图片更新"></a>3. Logo 图片更新</h4><p>将 <code>web/app/components/base/logo/logo.svg</code> 替换为自定义的 YZHU Logo。确保新 SVG 文件的尺寸与原文件一致，以避免界面布局错乱。示例 SVG 结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web/app/components/base/logo/logo.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 200 50&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;35&quot;</span> <span class="attr">font-size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000&quot;</span>&gt;</span>YZHU<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试方法</strong>：在开发环境中检查 Logo 在不同页面和屏幕尺寸下的显示效果，确保无拉伸或模糊。</p>
<h3 id="嵌入式脚本"><a href="#嵌入式脚本" class="headerlink" title="嵌入式脚本"></a>嵌入式脚本</h3><p>嵌入式脚本 <code>embed.js</code> 用于在网页中嵌入 Dify 的交互组件（如聊天窗口）。本次变更更新了脚本中使用的图标文件 <code>closeIcon.svg</code> 和 <code>openIcon.svg</code>，用于 “展开&#x2F;关闭” 交互按钮。</p>
<h4 id="图标文件更新"><a href="#图标文件更新" class="headerlink" title="图标文件更新"></a>图标文件更新</h4><p>在<code>embed.js</code>将 <code>closeIcon.svg</code> 和 <code>openIcon.svg</code> 替换为自定义 SVG 图标。SVG 格式支持矢量缩放，适合高清屏幕，且可通过代码调整样式（例如颜色、大小）。示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- closeIcon.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#FF0000&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M10 10L14 14M14 10L10 14&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- openIcon.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#0000FF&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M12 5V19M5 12H19&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>优势</strong>：SVG 图标支持动态修改 <code>fill</code> 属性（例如，切换为暗模式时更改颜色），比字体图标更灵活。</p>
<p><strong>测试方法</strong>：在网页中嵌入 <code>embed.js</code>，检查交互按钮的图标是否正确显示，点击时是否触发展开&#x2F;关闭功能。</p>
<h3 id="后续优化建议"><a href="#后续优化建议" class="headerlink" title="后续优化建议"></a>后续优化建议</h3><p>新增品牌配置文件：当前品牌标识（如 “YZHU”）硬编码在代码中，后续修改需逐文件替换。建议新增 brand.config.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// web/brand.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> brand = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YZHU&#x27;</span>,</span><br><span class="line">  <span class="attr">logoPath</span>: <span class="string">&#x27;/path/to/logo.svg&#x27;</span>,</span><br><span class="line">  <span class="attr">altText</span>: <span class="string">&#x27;YZHU logo&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; brand &#125; from &#x27;./brand.config.js&#x27;;</span><br><span class="line">const title = `$&#123;prefix&#125;$&#123;brand.name&#125;`;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开源项目的二次开发不一定需要改动核心功能，像本次 Dify 品牌定制这样，通过精细化的文本替换、视觉更新和部署优化，同样能让工具无缝融入企业业务场景。本文提供了一套可复用的品牌替换流程，涵盖前端资源和嵌入式脚本，适合中小型企业或初次接触 Dify 的开发者。</p>
<p>如果你也在进行 Dify 的二次开发，欢迎分享你的经验！希望本文能为你的项目提供参考。</p>
]]></content>
  </entry>
  <entry>
    <title>跨境电商用户标签系统架构设计</title>
    <url>/2023/12/10/User-Tag/</url>
    <content><![CDATA[<h3 id="一、项目背景与业务价值"><a href="#一、项目背景与业务价值" class="headerlink" title="一、项目背景与业务价值"></a>一、项目背景与业务价值</h3><p>在竞争激烈的跨境电商领域，用户体验和精细化运营至关重要。为了实现<strong>精准营销、动态定价和运营分析</strong>等关键业务场景，我们需要更及时、更准确地理解用户行为<span id="more"></span>。</p>
<p>然而，传统用户标签系统依赖离线计算，数据更新频率为<strong>每日一次</strong>，实时性不足，无法满足业务快速响应用户行为变化的需求。例如，<strong>新用户下单后无法立即享受老用户折扣</strong>，<strong>个性化推荐也存在滞后性</strong>。</p>
<p>为了解决这些痛点，我们启动了<strong>实时用户标签系统</strong>项目，旨在构建一套<strong>高性能、低延迟、可扩展</strong>的用户标签基础设施，实现用户行为的<strong>实时采集、计算和应用</strong>，为业务增长提供有力的数据支撑。</p>
<p>系统上线后，成功支撑<strong>日均三千万级</strong>用户行为数据处理，<strong>标签更新延迟控制在500ms内</strong>，为以下关键业务场景提供了有力支持：</p>
<ul>
<li><strong>精准营销</strong>：基于用户标签实现<strong>千人千面</strong>的商品推荐，提升点击率和转化率。</li>
<li><strong>动态定价</strong>：根据用户标签（如新老用户）实施<strong>差异化价格策略</strong>，提升用户粘性和复购率。</li>
<li><strong>运营分析</strong>：通过用户行为标签进行<strong>用户行为洞察和转化率优化</strong>，指导运营策略调整。</li>
</ul>
<h3 id="二、架构设计全景图"><a href="#二、架构设计全景图" class="headerlink" title="二、架构设计全景图"></a>二、架构设计全景图</h3><h4 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h4><pre class="mermaid">graph TD
    AAW[App/Web] -->|HTTP上报| A[区域A数据采集系统]
    ABK[后端系统] -->|SDK上报| A
    BAW[App/Web] -->|HTT上报| B[区域B数据采集系统]
    BBK[后端系统] -->|SDK上报| B
    A -->|MQ| C[标签计算系统]
    B -->|MQ| C
    C --> Da[区域A数据库集群: MongoDB+MySQL+Redis]
    C --> Db[区域B数据库集群: MySQL+Redis]
    Ea[标签查询] --> Da
    Fa[用户系统]-->Ea
    Ga[订单系统]-->Ea
    Ia[营销系统]-->Ea
    Ha[其它...系统]-->Ea
    Eb[标签查询] --> Db
    Fb[用户系统]-->Eb
    Gb[订单系统]-->Eb
    Ib[营销系统]-->Eb
    Hb[其它...系统]-->Eb</pre>


<p><strong>数据流:</strong>  <code>App/Web/后端系统</code> → <code>HTTP/SDK上报</code> → <code>区域采集系统</code> → <code>RabbitMQ</code> → <code>标签计算系统</code> → <code>MongoDB/MySQL/Redis</code></p>
<p><strong>分层架构:</strong></p>
<ul>
<li><strong>数据采集层</strong>：采用 <strong>Nginx+SpringCloud</strong> 技术栈，<strong>双区域独立部署</strong> (区域A和区域B数据采集系统)，支持 <strong>App&#x2F;Web&#x2F;API 多端统一接入</strong>。具备 <strong>高并发 HTTP 接入</strong> 能力和 <strong>区域路由</strong> 功能，确保数据就近接入，降低网络延迟。</li>
<li><strong>消息中间件</strong>：复用现有 <strong>RabbitMQ 集群</strong>，降低运维成本。RabbitMQ 承担 <strong>数据缓冲和异步解耦</strong> 的作用，保障数据采集层和计算层之间的稳定通信。</li>
<li><strong>计算存储层</strong>：<ul>
<li><strong>标签计算系统</strong>：基于 <strong>Spring</strong> 构建，采用 <strong>轻量级规则引擎</strong> 框架，易于扩展和维护。</li>
<li><strong>规则管理</strong>：<strong>MySQL</strong> 存储标签规则，实现 <strong>规则版本控制和回滚</strong>，方便规则迭代和管理。</li>
<li><strong>标签存储</strong>：采用 <strong>MySQL+Redis</strong> 组合，<strong>MySQL</strong> 持久化存储标签规则与计算结果，<strong>Redis</strong> 提供 <strong>实时查询能力</strong>，支撑高并发的标签查询请求。</li>
</ul>
</li>
</ul>
<h4 id="2-核心组件设计"><a href="#2-核心组件设计" class="headerlink" title="2. 核心组件设计"></a>2. 核心组件设计</h4><table>
<thead>
<tr>
<th>模块</th>
<th>技术选型</th>
<th>设计要点</th>
</tr>
</thead>
<tbody><tr>
<td>数据采集</td>
<td>Nginx+SpringCloud</td>
<td>高并发HTTP接入，区域路由</td>
</tr>
<tr>
<td>消息队列</td>
<td>RabbitMQ集群</td>
<td>消息持久化，自动故障转移</td>
</tr>
<tr>
<td>标签计算</td>
<td>Spring</td>
<td>轻量级规则引擎，易于扩展</td>
</tr>
<tr>
<td>规则管理</td>
<td>MySQL</td>
<td>规则版本控制，支持回滚</td>
</tr>
<tr>
<td>标签存储</td>
<td>MySQL+Redis</td>
<td>冷热数据分离存储策略</td>
</tr>
<tr>
<td>用户行为存储</td>
<td>MongoDB</td>
<td>用户行为持久化</td>
</tr>
</tbody></table>
<h3 id="三、核心设计决策"><a href="#三、核心设计决策" class="headerlink" title="三、核心设计决策"></a>三、核心设计决策</h3><h4 id="1-数据采集方案"><a href="#1-数据采集方案" class="headerlink" title="1. 数据采集方案"></a>1. 数据采集方案</h4><ul>
<li><strong>多端统一接入</strong>：定义标准 <strong>HTTP 上报协议</strong>，统一 <code>App/Web/API</code> 多端数据接入方式，降低接入成本。</li>
<li><strong>区域路由策略</strong>：基于 <strong>用户标识自动路由</strong> 到相应区域采集节点，提升数据上报效率，降低网络延迟。</li>
<li><strong>数据校验机制</strong>：<ul>
<li><strong>上报数据格式校验</strong>：在采集层进行数据格式校验，过滤无效数据。</li>
<li><strong>去重处理</strong>：对重复上报数据进行 <strong>去重处理</strong>，保障数据质量，避免重复计算。</li>
</ul>
</li>
</ul>
<h4 id="2-消息中间件选型"><a href="#2-消息中间件选型" class="headerlink" title="2. 消息中间件选型"></a>2. 消息中间件选型</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>RabbitMQ优势</th>
<th>设计考量点</th>
</tr>
</thead>
<tbody><tr>
<td>运维成本</td>
<td>复用现有集群</td>
<td><strong>无需额外运维投入</strong></td>
</tr>
<tr>
<td>可靠性</td>
<td>消息持久化+ACK机制</td>
<td><strong>数据零丢失保障</strong></td>
</tr>
<tr>
<td>扩展性</td>
<td>集群模式支持水平扩展</td>
<td><strong>满足未来增长需求</strong></td>
</tr>
</tbody></table>
<p><strong>选型分析:</strong>  综合考虑 <strong>运维成本、可靠性和扩展性</strong> 等因素，<strong>复用现有 RabbitMQ 集群</strong> 是最优选择。RabbitMQ 集群具备良好的 <strong>消息持久化、ACK 机制和水平扩展能力</strong>，能够满足实时用户标签系统对消息队列的需求。</p>
<h4 id="3-计算存储架构"><a href="#3-计算存储架构" class="headerlink" title="3. 计算存储架构"></a>3. 计算存储架构</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储方案</th>
<th>设计考量点</th>
</tr>
</thead>
<tbody><tr>
<td>上报日志</td>
<td>MongoDB分片集群</td>
<td><strong>高吞吐写入，灵活 Schema</strong>，支持海量用户行为日志存储</td>
</tr>
<tr>
<td>标签规则</td>
<td>MySQL</td>
<td><strong>事务支持，版本管理</strong>，保障规则数据一致性和可维护性</td>
</tr>
<tr>
<td>标签结果</td>
<td>MySQL+Redis</td>
<td><strong>实时查询与持久化存储</strong>，兼顾实时查询性能和数据可靠性</td>
</tr>
</tbody></table>
<p><strong>存储选型:</strong></p>
<ul>
<li><strong>MongoDB 分片集群</strong>：适用于存储 <strong>海量、Schema 灵活</strong> 的用户行为日志数据，满足高吞吐写入需求。</li>
<li><strong>MySQL</strong>：适用于存储 <strong>结构化</strong> 的标签规则和标签结果数据，提供 <strong>事务支持和数据一致性</strong> 保障。</li>
<li><strong>Redis</strong>：适用于缓存 <strong>热点标签数据</strong>，利用其 <strong>高性能内存数据库</strong> 特性，提升标签查询效率。</li>
</ul>
<h3 id="四、性能优化实践"><a href="#四、性能优化实践" class="headerlink" title="四、性能优化实践"></a>四、性能优化实践</h3><h4 id="1-采集层优化"><a href="#1-采集层优化" class="headerlink" title="1. 采集层优化"></a>1. 采集层优化</h4><ul>
<li><strong>负载均衡</strong>：采用 <strong>Nginx 轮询 + 权重分配</strong> 策略，实现采集层负载均衡，<strong>单节点支持 10k QPS</strong> 高并发接入。</li>
<li><strong>异步处理</strong>：数据上报请求 <strong>异步化处理</strong>，降低请求响应时间，<strong>响应时间 &lt;50ms</strong>。</li>
<li><strong>数据压缩</strong>：采用 <strong>Gzip 压缩</strong> 技术，对上报数据进行压缩，<strong>降低 70% 网络传输量</strong>，提升传输效率。</li>
</ul>
<h4 id="2-容灾方案设计"><a href="#2-容灾方案设计" class="headerlink" title="2. 容灾方案设计"></a>2. 容灾方案设计</h4><ul>
<li><strong>消息重试</strong>：RabbitMQ 启用 <strong>死信队列</strong>，处理标签计算失败消息，保障数据可靠性。</li>
<li><strong>数据备份</strong>：MySQL 数据库进行 <strong>每日全量备份 + 增量备份</strong>，防止数据丢失。</li>
<li><strong>故障切换</strong>：Redis 采用 <strong>主从模式</strong> 部署，实现 <strong>主从自动切换</strong>，<strong>切换时间 &lt;30s</strong>，保障缓存服务高可用。</li>
</ul>
<h3 id="五、标签体系设计"><a href="#五、标签体系设计" class="headerlink" title="五、标签体系设计"></a>五、标签体系设计</h3><h4 id="1-标签分类模型"><a href="#1-标签分类模型" class="headerlink" title="1. 标签分类模型"></a>1. 标签分类模型</h4><pre class="mermaid">graph TD
    A[用户标签] --> B(基础标签)
    A --> C(行为标签)
    B --> D[用户属性]
    B --> E[设备信息]
    C --> F[购买行为]
    C --> G[浏览偏好]</pre>

<ul>
<li><strong>基础标签</strong>：描述用户的<strong>静态属性</strong>，例如：用户属性（年龄、地域）、设备信息（设备类型、操作系统）。<strong>更新机制为批量每日更新</strong>。</li>
<li><strong>行为标签</strong>：描述用户的<strong>动态行为</strong>，例如：购买行为（购买商品、订单金额）、浏览偏好（浏览商品类目、浏览时长）。<strong>更新机制为事件驱动实时更新</strong>。</li>
</ul>
<h4 id="2-典型场景实现：新用户转老用户逻辑"><a href="#2-典型场景实现：新用户转老用户逻辑" class="headerlink" title="2. 典型场景实现：新用户转老用户逻辑"></a>2. 典型场景实现：新用户转老用户逻辑</h4><p>以 <strong>新用户转老用户</strong> 标签更新场景为例，说明实时标签系统的应用流程：</p>
<ol>
<li><strong>监听下单事件</strong>：系统 <strong>实时监听</strong> 订单系统产生的下单事件。</li>
<li><strong>校验历史订单数</strong>：标签计算系统接收到下单事件后，<strong>校验用户近一年内历史订单数是否为 1</strong>。</li>
<li><strong>触发标签状态变更</strong>：若校验通过，则 <strong>触发用户标签状态变更</strong>，将用户标签从 “新用户” 更新为 “老用户”。</li>
<li><strong>推送价格策略</strong>：标签计算系统将 <strong>新的用户标签推送至商品服务</strong>。商品服务 <strong>实时更新价格策略</strong>，使用户在 <strong>&lt;500ms 内</strong> 看到商品价格折扣。</li>
</ol>
<h3 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h3><p>实时用户标签系统的成功上线，显著提升了用户标签的<strong>实时性</strong>和<strong>应用效率</strong>，为业务的<strong>精细化运营</strong>提供了强有力的数据支撑。项目在<strong>高性能、高可靠、可扩展</strong>等方面做了深入设计和优化，为后续的迭代升级奠定了坚实基础。</p>
<p>未来，我们将继续在以下方面进行探索和优化：</p>
<ul>
<li><strong>更智能的告警</strong>：引入 <strong>异常检测</strong> 等智能告警策略，提升问题发现和处理效率。</li>
<li><strong>更丰富的标签类型</strong>：扩展 <strong>用户兴趣标签、用户偏好标签</strong> 等，构建更全面的用户画像。</li>
<li><strong>更灵活的规则引擎</strong>：实现更负载的标签计算逻辑，提升系统灵活性。</li>
</ul>
<p>随着实时用户标签系统的不断完善，将为业务带来更大的价值，持续驱动业务增长。</p>
]]></content>
      <tags>
        <tag>技术方案</tag>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与Go之间gRPC调用失败问题排查</title>
    <url>/2019/06/02/gRPC-Go-Java/</url>
    <content><![CDATA[<p>最近接手了一个新项目，被告知Java代码的gRPC客户端无法访问当前项目中Go代码的gRPC服务。通过问题的排查和部分代码改造个人对gRPC的理解更深入了一层.<span id="more"></span></p>
<h3 id="项目背景："><a href="#项目背景：" class="headerlink" title="项目背景："></a>项目背景：</h3><p>接手该项目后跟该项目相关人员多次沟通后得到如下背景信息:</p>
<ol>
<li>该项目Go服务端采用的是2016年9月以前发布的gRPC ；</li>
<li>项目组对官方提供的Go语言gRPC类库做了部分改造，但，由于改造该代码的工程师已经离职，目前没有人知道具体修改了什么​；</li>
<li>由于项目周期紧张，没有富余的人力排查该问题；</li>
<li>目前Java与Go互相交互的接口不到10个，双方先采用HTTP交互;</li>
<li>服务端总是需要维护两套接口，HTTP和gRPC接口，链路跟踪等公共组件都要适配两套接口，增加了维护成本</li>
</ol>
<h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><ol>
<li>采用Java版本gRPC-Java-1.18.0访问现有的Go服务，请求发出以后被hang住没有任何反馈直到客户端设置的连接超时后断开，Java客户端和Go服务端没有任何输出信息；</li>
<li>抓包看包文发现在完成TCP的3次握手后，客户端发送了第一HTTP2的包文后，没有收到服务端的任何回复，整个过程被hang；初步估计是双方采用的HTTP2协议不兼容。</li>
<li>采用低版本的Java gRPC, 调研发现Java的gRPC在2016年9月以前的最新版本是1.0.0，所以从1.0.0开始测试，最终发现0.9.0可以完成正常请求。</li>
</ol>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>调研发现0.9.0版本的Java gRPC依赖了4.1.0.Beta6的Netty，该Netty版本发布与2015年9月， 而HTTP2在2015年有多次修订，版本号也升级到了17；我估计该版本的Netty是根据HTTP2修订版17以前的规范实现的,而且该版本为Beta版，导致跟其它语言的协议存在某些差异。</p>
<h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>采用0.9.0版本的gRPC后会带来以下新问题：</p>
<ol>
<li>现有的Java项目框架采用springcloud2.0.0，该版本依赖了Netty的4.1.27.Final版本，项目集成后会出现版本冲突导致各种异常出现；</li>
<li>0.9.0版本的gRPC缺少很多重要的特性，比如：nameresolver，负载均衡 等 …</li>
<li>最终还是要升级到新版本</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>综合沟通下来最好的方案就是Go服务端升级gRPC到新版本 ，但是团队将官方代码改造后已经无法做到无缝升级，必须要做部分改造才能投入生产​；目前生产环境运行的Go服务超过50+，而且大部分是核心服务；改造后需要充分的测试，总体成本太大，而且目前没有更多的资源投入。最终决定才有用低版本的Java gRPC​，采用以下的措施应对低版本面临的问题:</p>
<ol>
<li>所有的Java项目提供统一的parent pom文件，所有的版本信息在parent pom的dependencyManagement中维护；</li>
<li>增加新功能：nameresolver，负载均衡，兼容Go服务的服务发现，等…</li>
</ol>
<h3 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h3><p>我们在技术选型的不能过于保守也不能过于激进；太过保守不能充分利用新技术的优势，甚至会影响到团队士气；太过激进会遭遇太多的不确定性，面临着遇到问题没有先例可以参考，遭遇新的bug，等；所以，在团队没有足够的技术支撑的情况下，我不太建议生产环境采用1.0以下的版本。作为技术人员应该随时关注业界的新技术，但在生产环境采用新技术前必须考虑清楚所面对的各种风险，包括以后的升级能否做到无缝升级。​</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h5><p><a href="https://grpc.io/">https://grpc.io/</a><br><a href="https://github.com/grpc/grpc-java">https://github.com/grpc/grpc-java</a><br><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/">https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/</a></p>
]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>基于protobuf的定义在跨语言消息传递中的应用</title>
    <url>/2021/09/21/message-dsl-base-protobuff/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中<span id="more"></span>通常通过文档约定消息格式各自定义自己的消息体。在我们实际使用过程中发现不同语言之间传递信息还是会出现一些问题；比如：Java用fastjson输出复杂数据在Go项目解析失败，而且各语言在配置mq参数时候有各自的约定,人工操作容易引起误操作，所以我们希望能有一套跨语言的工具能分别生出各自语言的代码和配置。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>现有系统跨语言之间RPC的调用我们采用了gRPC,很自然的想到可以借鉴gRPC Protobuf定义消息体。具体方法就是扩展<code>google.protobuf.MethodOptions</code>定义</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>下面以RabbitMQ为例，在Protobuf文件中定义MQ相关参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">extend google.protobuf.MethodOptions &#123;</span><br><span class="line">    </span><br><span class="line">    // exchange类型: topic direct fanout ,默认: direct</span><br><span class="line">    string routeType = 7010101;</span><br><span class="line"></span><br><span class="line">	// producer 发送到exchange上有效的routekey; 仅topic模式有效</span><br><span class="line">    repeated string routeKey = 7010102;</span><br><span class="line"></span><br><span class="line">    //consumer监听的队列名称，direct模式 该参数无效</span><br><span class="line">    repeated string listener = 7010103;</span><br><span class="line"></span><br><span class="line">   // 延迟队列的延迟时间</span><br><span class="line">   int32 delay = 6010106;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 如果exchange为topic模式，监听队列绑定的routekey必须根据此处定义的routKey定义设置;比如文件定义的routeKey是a.b.c则consumer端绑定到队列的routkey只能是 a.b.c, a.b.<em>, a.</em>, * 其中之一</p>
<h5 id="生产Java代码"><a href="#生产Java代码" class="headerlink" title="生产Java代码"></a>生产Java代码</h5><p>通常在Maven工程中我们使用<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成gRPC的Java代码。现在我们可以扩展<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成MQ的代码。核心扩展点如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Mojo(</span><br><span class="line">        name = &quot;compile-mq&quot;,</span><br><span class="line">        defaultPhase = LifecyclePhase.GENERATE_SOURCES,</span><br><span class="line">        requiresDependencyResolution = ResolutionScope.COMPILE,</span><br><span class="line">        threadSafe = true</span><br><span class="line">)</span><br><span class="line">public class ProtocCompileMQMojo extends AbstractProtocCompileMojo&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</span><br><span class="line">        super.execute();  </span><br><span class="line">        // 利用 DescriptorProtos.FileDescriptorSet 读取proto文件的定义根据规范生出Java文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后配合MQ的SDK可以大大提高开发效率而且减低配置的复杂性。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>海恩法则与生产Bug</title>
    <url>/2019/03/01/product-bug/</url>
    <content><![CDATA[<p><img src="/2019/03/01/product-bug/heinrich-law.jpeg"><br>「海恩法则」是航空涡轮发动机的发明者帕布斯·海恩提出一个在航空界关于飞行安全的法则。海恩指出：每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。法则强调两点：一是事故的发生是量的积累的结果；二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。「海恩法则」虽然针对的是飞行领域，在软件开发领域遭遇生产bug<span id="more"></span>，用「海恩法则」也可以解释。</p>
<p>当生产环境出现bug的时候，通常情况下，我们会很快定位出bug产生的原因具体在哪一行代码上，然后根据实际情况决定回滚或者修复。然而事后总结发现，每一个线上bug的出现绝不仅仅是代码的问题，会涉及到开发、测试和运维多个环节；更多暴露出的是流程的问题，管理的问题，执行力的问题。特别是初创团队和架构大规模升级后最容易暴露出代码以外的问题。以我个人处理过的生产bug，事后分析原因最多的一次有14项措施要么缺失，要么执行不到位，其中与代码相关的只有2项，更多的原因是方案和流程执行不到位。</p>
<p>上线前通常会采取一些措施来保证质量；比如：开发阶段的code review，ut以及测试阶段的压测等；而且会有配套的流程确保必要的步骤都执行到位；然而即便采取多么复杂的流程也不能避免bug的出现。归根结底，代码是人写的，是人就可能出错 ；我们要做的<strong>不是不出bug，而是不出低级bug</strong> 。对于可能出现的低级bug要擅于通过工具发现；诚然，再好的工具和流程也比不上人自身的素质和责任心。</p>
<p>上线后系统会有各种维度的监控确保系统正常运行；在出现生产bug前监控系统通常会有异常表现，比如CPU，内存，IO，线程等指标可能会有同比变化；此时报警策略的精准性和人的责任心就比较重要；发现异常后第一时间根据各项指标分析出异常的根本原因，是正常波动，是受到攻击还是程序bug。特别是新功能或者bug修复后上线要特别注意这些指标。在确认系统出现问题时候后立刻采取相应措施，回滚，扩容，限流，熔断等，避免或者尽可能减少造成的损失 。</p>
<p>其实所有的问题都可以归结为人的问题。最后想到奈飞文化准则的第一条「我们只招成年人」 。</p>
]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提一个问题</title>
    <url>/2018/12/23/how-to-question/</url>
    <content><![CDATA[<p>在我们日常生活以及工作中经常会遇到提问题, 我们有没有想过如何提一个好问题？也许有人会说，「提问谁不回？会讲话的小孩子就会问为什么，这有什么值得说的？」没错，从这个角度上说机会每个人都会提问。但是，我们有没有想过，我们问问题的目的是什么？是得到对问题的解答。大家有没有遇到过这样的情况，自己问题发给对方后始终得不到回复，或者对方敷衍了事，更有甚者被对方怼回去。如果遇到这些情况，我们应该好好反思一下，我们是不是提了一个好问题；在说好问题之前结合个人的经历谈谈什么样的问题不是一个好问题。<span id="more"></span></p>
<ol>
<li>提问者在im上发一个截图，截图里面是一个异常栈，没有任何上下文，然后就没有然后了；解答者在那里等对方进一步的信息，结果什么也等到；过了很久(估计等很久没回复)，亲自过来说「帮我看看我的问题」；这个时候才开始沟通，问题是怎么出现的，什么环境，上下文，等… </li>
<li>有些问题在技术文档，产品文档上都已经说的很清楚；但提问者不看文档，直接把问题抛过来；也许是提问者自己没有按照文档要求操作，或者真的是一个问题但文档FAQ部分已经解释的很清楚 ；</li>
<li>提问者直接将问题抛出来，不做任何思考和尝试，只在那里等答案；不知道提问者有没有想过，解答者也要花费大量的时间去调研；</li>
<li>提问者提问道时候，发的关键信息是一张截图，截图中可能有id之类的标示，此时解答者可能需要根据id搜索，只能手工输入，这样既浪费时间也容易出错；</li>
</ol>
<p>对于以上的案例，个人觉得提问者需要加强独立思考的能力，不然会给对方留下「伸手党」的感觉；个人觉得可以按照如下的方式考虑提问:</p>
<ol>
<li>对于技术问题或者产品问题，一般作者会提供相应的文档；首先我们应该阅读相关文档，特别注意FAQ部分；</li>
<li>善于使用搜索引擎，具备基本的搜商(SQ) ,推荐用google(对技术工作者，这个不需要解释), 百度请忽略所有「广告」字样的文章，微信，知乎等工具;</li>
<li>在以上两步都没有找到答案情况下，可以参考第二步搜索过程中出现的文章以及官方提供的文档尝试；比如是否可以升级软件版本，是否可以调整某些参数；相信在尝试过程中会加深自己对问题的理解以及提升自己解决问题的能力</li>
<li>经过以上步骤能解决95%的问题了；如果还没有解决，这时候再提问，相信这个时候提出的问题质量是非常高的；比如: 该问题是如何出现的，什么环境，硬件型号是什么，软件版本是什么，我的操作步骤是什么，我做了哪些调研，尝试了哪些方式，得到结果是什么,等..</li>
</ol>
<p>那么提一个好问题有那么重要吗？我认为提一个好问题比解答一个问题更能体现一个人的真实水平，因为这证明提问者有独立思考的能力；比如在职场中一个常见的场景是这样的，面试最后部分面试官会问面试者有什么问题吗？这个时候如果提一个高质量的问题，相信会加深面试官的印象,在同等条件的候选者中相信胜出的概率会更高;</p>
<p>最后关于什么是好问题，这里引用某大佬的一句话 「什么是好问题，你对某个领域有一定研究，你已经翻阅和查询了足够的资料，然后你基于你的理解，对这些资料中，某几个无法理解的细节提出来，希望专业人士给与解惑，而这个细节问题确实具有足够代表性，是理解一些关键问题的钥匙，这就是好问题。」</p>
]]></content>
  </entry>
  <entry>
    <title>服务化架构升级实践</title>
    <url>/2019/01/03/servcie-deploy-summary/</url>
    <content><![CDATA[<p>目前我们大部分业务都接入了服务化，在过去将近一年的时间里，我们踩了很多坑，也出现了几次生产事故，同时，从某种意义上讲，我们也做了某些「微创新」，使得架构更适合我们团队的实际情况。从目前的结果来看，基本达成了预定目标； <span id="more"></span></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>在前期技术选型的时候，我们调研了<a href="http://dubbo.apache.org/">Dubbo</a>和<a href="https://spring.io/projects/spring-cloud">Spring Cloud</a>，主要从以下这些方面考虑各自的优缺点；最终选择以<a href="http://dubbo.apache.org/">Dubbo</a>为基础技术框架：</p>
<ol>
<li>社区支持</li>
<li>生态建设</li>
<li>服务治理</li>
<li>服务监控</li>
<li>与现有系统的集成</li>
<li>代码迁移成本</li>
<li>团队的流程</li>
<li>运维成本</li>
<li>团队的经验</li>
<li>学习成本</li>
</ol>
<h3 id="服务化SDK"><a href="#服务化SDK" class="headerlink" title="服务化SDK"></a>服务化SDK</h3><p>考虑到当时<a href="http://dubbo.apache.org/">Dubbo</a>刚开始进入Apache孵化器，也方便我们以后升级；我们提供了封装<a href="http://dubbo.apache.org/">Dubbo</a>的服务化SDK给开发团队使用。我们扩展了如下功能: </p>
<ol>
<li>启动完成标示，单个JVM中确保所有服务启动完成而且在注册中心注册</li>
<li>集成<a href="https://github.com/ctripcorp/apollo">Apollo</a> ，开发团队不用关心基础组件配置信息 </li>
<li>集成监控，保证服务化后项目必须接入监控</li>
<li>集成限流降级系统，确保所有的provider必须接入流降级功能</li>
<li>定向指定服务节点，测试环境中多项目测试的情况下，可以对运行中的服务动态指定provider工作节点 。(我们也注意到官方在2.7版本的tag feature提供了类似的功能)</li>
</ol>
<h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>系统架构服务化后，服务间调用关系错综复杂，出现问题很难定位。所以监控系统极为重要；而且我们一致认为投入生产前必须有全链路监控。为了快速上线，我们在Dubbo官方提供的监控系统<a href="https://dubbo.incubator.apache.org/">dubbo-monitor</a>和<a href="https://zipkin.io/">zipkin</a>基础上做了部分改造：</p>
<ol>
<li>dubbo-monitor官方的方案是将监控数据持久化到磁盘。我们考虑到数据保存到磁盘不方便查询，而且多个节点之间共享磁盘不是一个好的方案。所以，我们将数据持久化到MySql。</li>
<li>配置信息接入<a href="https://github.com/ctripcorp/apollo">Apollo</a> 。</li>
<li>接入我们现有的报警系统；将监控数据实时上报到我们的报警系统 。</li>
<li><a href="https://zipkin.io/">zipkin</a>的链路跟踪信息接入我们的日志系统 </li>
<li>打通全链路监控,从web系统到最后端基础服务调用关系</li>
</ol>
<h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>我们采用阿里开源的<a href="https://github.com/alibaba/Sentinel">Sentinel</a>作为限流降级组件。<a href="https://github.com/alibaba/Sentinel">Sentinel</a>官方提供了与<a href="http://dubbo.apache.org/">Dubbo</a>集成的适配器，可以最快的速度投入生产使用。但是，由于<a href="https://github.com/alibaba/Sentinel">Sentinel</a>官方默认的限流降级规则是存储在节点内存中的，节点重启后规则会丢失。所以，团队根据官方提供<a href="https://github.com/ctripcorp/apollo">Apollo</a>的Datasource做了少许改造，使得规则可以持久化到<a href="https://github.com/ctripcorp/apollo">Apollo</a> 。</p>
<h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>服务拆分是服务化改造的重点。 通常大家都会根据领域来拆分，而领域的划分可大可小没有一个绝对的标准。拆分太细，服务众多，运维成本较高；拆分太粗发挥不了服务化的优势，因此在服务拆分的时候要根据团队当前的实际情况而定。我们团队在具体执行的过程中采用了领域+上&#x2F;下层服务的方式拆分。我们各个开发团队的划分就是按照领域划分的，而每个团队都会有底层服务(会提供接口给其它团队)和上层服务(为个自业务服务)；所以，原则上每个团队两个服务，一个底层服务，另一个是上层服务；针对部分关键服务(比如，详情页，订单，支付等..) 有独立的服务 。真正做到独立开发，独立测试，独立发布，独立运维。</p>
<h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>服务化后开发人员的智能发生了变化 :</p>
<ol>
<li>开发团队的处警方式有被动告知转变为主动处理，系统的运行状态不仅仅依赖SA，更多依靠开发团队主动关注，SA更多关注系统级别的指标，开发人员必须关注系统，业务等各种指标；以最快的速度对系统的异常作出响应。</li>
<li>测试任务更多依赖开发人员完成，专职测试人员更多关注自动化和质量。</li>
<li>上线发布不再由SA直接参与，SA负责提供发布&#x2F;回滚工具，在质量达标后由开发团队独立完成 。</li>
</ol>
<h4 id="上线流程"><a href="#上线流程" class="headerlink" title="上线流程"></a>上线流程</h4><ol>
<li>效率；之前上线涉及多个团队，依赖Jar包过多，上线过程经常遇到代码冲突，包依赖冲突等问题；排查问题涉及多个团队，耗时长，效率低。服务化后每次上线只涉及自己团队成员，不再有代码冲突和包冲突的问题，效率得到了很大的提升 。</li>
<li>CI&#x2F;CD流程的建立；我们在服务化推进的过程中同时建立了初步的CI&#x2F;CD流程 。</li>
<li>自动化测试；服务化后上线频率更高，为了保证质量我们开始建立了自动化测试系统。</li>
</ol>
<h4 id="编码规范增加如下内容"><a href="#编码规范增加如下内容" class="headerlink" title="编码规范增加如下内容:"></a>编码规范增加如下内容:</h4><ul>
<li>事务处理</li>
<li>SQL中多表join</li>
<li>引用的传递 </li>
<li>限流异常的处理</li>
<li>超时异常处理</li>
<li>单元测试规范</li>
</ul>
<h5 id><a href="#" class="headerlink" title></a></h5><h4 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h4><ol>
<li>流量切换方式；服务化之前我们大部分应用都是web应用；系统发布过程中流量的切换是通过Nginx完成的。服务化后流量切换需要依赖服务发现(我们用<a href="http://zookeeper.apache.org/">Zookeeper</a>作为<a href="http://dubbo.apache.org/">Dubbo</a>服务发现的组件)组件完成；因此我们增加了流量切换组件 。</li>
<li>回滚方式：服务化后系统上线频率变高；同时意味着回滚的频率也会变高。考虑到回滚应用的时候如果需要回滚配置必须手工完成，这样效率并不高。因此，我们根据利用<a href="https://github.com/ctripcorp/apollo">Apollo</a>的OpenAPI真正做到了一键回滚。</li>
</ol>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>接下来，我们会聚焦如下方面：</p>
<ul>
<li>分库分表</li>
<li>前&#x2F;中台战略</li>
<li>容器化</li>
<li>自动化测试的加强</li>
<li>监控系统的加强，缩短问题排查的时间</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>给出一个「可落地的方案」能真正体现一个架构师实力；架构师遇到的很多问题都不是技术问题，只是用技术手段解决业务问题，流程问题，质量问题。架构师给出的每一个方案，必须立足于团队的实际情况，实际情况包括但不限于：成本，时间，团队能力，等。而且时刻关注执行结果；如果没有到达预期效果或者在执行过程中偏离方向，尽快根据团队实际情况调整方案。总之，所有的方案都是冲着三个目标 <strong>效率</strong>，<strong>质量</strong>，<strong>成本</strong> 。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>消息的可靠投递</title>
    <url>/2021/04/13/reliable-message-delivery/</url>
    <content><![CDATA[<p>在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递<span id="more"></span>,即：不能丢消息。</p>
<h3 id="MQ消费术语"><a href="#MQ消费术语" class="headerlink" title="MQ消费术语"></a>MQ消费术语</h3><pre><code>为了保证保证消息的可靠投递，先了解一下MQ的消费术语
</code></pre>
<ul>
<li><p>At Lest Once(至少一次)<br> 消息在消费的过程中，至少被发送到一个consumer; 如果consumer处理失败，会再次发送到consumer； 所以消息可能会重复被消费，通常会要求consumer保证幂等性</p>
</li>
<li><p>At Most Once(至多一次)<br> 消息在消费的过程中，至多被一个consumer消费; 如果consumer处理失败，消息可能会丢失；只能用于可接受消息丢失的场景  </p>
</li>
<li><p>Exactly Once(仅有一次)<br>  发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。常用MQ产品没有太多理想的实现 。</p>
</li>
</ul>
<h3 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h3><p>我们以<a href="https://www.rabbitmq.com/">RabbitMQ</a>为例从以下几个方面保证说明如何实现消息的可靠投递</p>
<h4 id="消息中间件可靠性"><a href="#消息中间件可靠性" class="headerlink" title="消息中间件可靠性"></a>消息中间件可靠性</h4><ul>
<li>使用RabbitMQ的集群模式，basic模式和镜像模式都可以保证消息不丢失；根据业务特点在吞吐量和高可用之间权衡选择合适的集群模式</li>
<li>确保exchange和queue的持久化</li>
</ul>
<h4 id="生产端可靠性"><a href="#生产端可靠性" class="headerlink" title="生产端可靠性"></a>生产端可靠性</h4><ul>
<li>发送消息时候设置消息持久化属性<strong>DeliverModel</strong> </li>
<li>消息持久化到数据库状态为发送中</li>
<li>消息到达exchange开启confirm模式，生产者发送完消息后等待broker的ack，超过一定时间没有收到broker的ack后启动job重试，直到收到broker的ack，数据库消息状态更新为已发送</li>
<li>消息未到达队列开启回退机制，如果消息从exchange无法投递到队列，回调通知调用者，调用者可以重试</li>
</ul>
<h4 id="消费端的可靠性"><a href="#消费端的可靠性" class="headerlink" title="消费端的可靠性"></a>消费端的可靠性</h4><ul>
<li>消费端确保消息处理逻辑的幂等性</li>
<li>关闭自动ack</li>
<li>消费端每处理完一次消息后手动回复ack; 如果处理消息程失败回复nack, 默认情况下broker会继续下发消息直到消费成功；注意：消息处理失败必须回复nack，否则broker认为该consumer节点down，不再下发消息到该节点</li>
</ul>
<h4 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h4><p>对中间件，存储系统，应用等增加监控，在出现问题的时候能第一时间发现</p>
<p>综上所述，为了保证消息的可靠投递我们需要从开发和运维的角度去考虑；确保每一个环节都能可靠。</p>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：寂静之城 -- 马伯庸</title>
    <url>/2020/09/05/The-Silence-City/</url>
    <content><![CDATA[<p>转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻<span id="more"></span></p>
<blockquote>
<p>And in the naked light I saw ten thousand people, maybe more. People tal<br>king without speaking, people hearing without listening. People writing<br>songs that voices never shared, no one dared disturb the sound of silenc<br>e. 　　　　　　　　　　　　　　　 — The sound of silence 　美利坚合众国，2015年，纽约。</p>
<p>　　当电话响起来的时候，阿瓦登正趴在电脑前面睡觉。电话铃声十分急促，尖锐<br>，每一次振动都让他的耳膜难受好久。他揉了揉干涩的眼睛，十分不情愿地爬起来<br>，觉得脑子沉滞无比。<br>　　其实他的脑子一直就很沉滞，这种感受既然是生理上的也是心理上的。他身处<br>的房间很狭窄，空气不很好，唯一的两扇窗户紧闭着——即使打开窗户也没用，外<br>面的空气更加浑浊。这是一间大约只有三十平米的小屋子，屋子墙壁上泛黄的墙纸<br>有好几处开始剥落，天花板上的水渍渗成奇怪的形状；一张老式的军绿色行军床摆<br>在墙角，床腿用白漆写着编号；紧挨着行军床的是一张三合板制成的电脑桌，桌上<br>摆着一台浅白色的电脑，机箱后面五颜六色的电线纠缠在一起，把它们自己打成一<br>个古怪的死结，杂乱无章地蔓延到地板与墙角，仿佛常春藤一样。</p>
<p>　　阿瓦登走到电话前，慢慢坐到地板上，目光呆滞地盯着电话，手却没有动。这<br>部古怪的东西是老式的按键式电话，大概是十几年前的款式，这是阿瓦登有一次去<br>费城出差时偶尔在一家杂货店里买到的；他拿回家以后稍微修理了一下，发现居然<br>还能用，这让他当时小小地兴奋了一阵子。<br>　　电话继续在响着，已经是第七声。阿瓦登意识到自己不得不去接听了。于是他<br>弓下腰，用两个指头拈起电话，慢慢把电话放到耳边。<br>　　“请说出你的网络编号？”话筒里传来的声音并不急噪，事实上它也不带其他<br>任何的感情色彩，因为这是电脑合成的人工智能语音系统。<br>“19842015”<br>　　阿瓦登熟练地报出一连串数字，同时开始觉得胸有些更闷了。说实话他并不喜<br>欢这些空洞的电子声音， 他有时候想，假如打过电话来的是一位声音圆润的女性该<br>多好。阿瓦登知道这是一种不切实际的幻想，不过这幻想会让他的身体得到几秒钟<br>的舒缓。</p>
<p>　　话筒里的声音仍旧在继续着。</p>
<p>　　“关于你在十月四日提交的网络论坛用户注册申请已经被受理，经有关部门审<br>查后确认资格无误，请在三日内持本人身份证件、网络使用许可证及相关文件前往<br>办理登记手续，并领取用户名及密码。”</p>
<p>　　“知道了，谢谢。”</p>
<p>　　阿瓦登谨慎地选择词语，同时努力挤出一副满足的微笑，好象话筒的另一侧有<br>人在看着自己一样。放下电话，阿瓦登先是茫然地盯着它看了大约两分钟，然后站<br>起来活动一下手腕，坐回到电脑前面，缓慢地推动了一下鼠标。</p>
<p>　　</p>
<p>　　电脑屏幕“啪”地一声亮了起来，显示出一个登陆的界面，还有一行英文：“<br>请输入你的网络编号和姓名。”阿瓦登将那八位数字敲进去，又输入了自己的名字<br>，点击“登陆”。随即机箱的指示灯开始频繁地闪动起来，整个机器发出细微的噪<br>音。</p>
<p>　　每一个使用互联网的人都有一个网络编号，没有这个编号，就无法连接进互联<br>网络。每一个编号都是独一无二的，每个人只有一个；这是使用者在网上的唯一代<br>号，既不能修改，也不能取消。这些编号分别对应着使用者身份证上的名字，因此<br>19842015就是阿瓦登，阿瓦登就是19842015。阿瓦登知道有些记忆力不好的人会把<br>自己的编号印在衣服的后面，那看起来颇为滑稽，也容易引发一些不正当的联想。</p>
<p>　　有关部门说使用网络实名制是为了规范网络秩序方便管理，杜绝因匿名使用网<br>络而产生的一系列重大问题和混乱。阿瓦登不太清楚那一系列重大问题会是什么，<br>他自己没试过用假名上网，他所认识的任何人里也不曾有人尝试过——事实上，从<br>技术角度来说，他根本没办法匿名登陆互联网络，没有编号就没有权限上网，而编<br>号则连接着他的详细档案，换句话说，没人能在网上隐藏自己。有关部门把这一切<br>都考虑的很周详。</p>
<p>　　“有关部门”，这是一个语意模糊、但却有着权威与震慑力的词组。它既是泛<br>指，又是确指，其所涵盖的意义相当广泛。有时候，它指的是为阿瓦登颁发网络编<br>号的美国联邦网络管理委员会；有时候它是将最新通告及法规发到阿瓦登EMAIL信箱<br>的服务器；还有时候它是监察网络的FBI特属网络调查科；总之一句话，有关部门是<br>无处不在，无职不司的，总会在适当的时候出现，给予指导、监控或者警告，无论<br>你是在网上还是网下。</p>
<p>　　简直就象是老大哥一样无微不至。</p>
<p>　　电脑仍旧在持续运转着，阿瓦登知道这得花上一阵子。这台电脑是有关部门配<br>发给他的，具体型号和配置阿瓦登并不清楚，机箱是被焊死的，无法打开。于是他<br>拿出一小瓶清凉油，用右手小拇指的指甲挑出一点抹在自己的太阳穴，然后从脚下<br>堆积如山的杂物里翻出一个塑料杯子，从桌子旁的饮水机里接了半杯蒸馏水，就着<br>一片镇痛片一饮而尽。蒸馏水穿过喉咙和狭长的食道滑进胃里，空泛的味道让他有<br>些恶心。</p>
<p>　　音响里忽然传来一阵美国国歌的旋律，阿瓦登放下杯子，重新把目光投到电脑<br>上去。这是已经连入互联网络的标志。屏幕上首先跳出来的是有关部门的通告，白<br>底黑色四号字，里面陈述了使用互联网的意义以及最新的规章制度。</p>
<p>　　“缔造健康的互联网络，美国万岁！”</p>
<p>　　音响里传来激昂的男性呼声，阿瓦登不大情愿地跟着大声念了一遍。“缔造健<br>康的互联网络，美国万岁！”</p>
<p>　　这段呼号持续了三十秒钟，然后消失，取而代之的是写着“缔造健康的互联网<br>络”标语的桌面背景。另外一个窗口慢慢浮上开，上面开列出几个选项：工作、娱<br>乐、电子信箱和BBS论坛。其中BBS选项呈现灰色，说明这项功能还没有开通。</p>
<p>　　整个操作系统简洁明了，这台电脑的浏览器没有地址输入栏，只是在收藏夹里<br>有几个无法修改的的网站地址。理由很简单，这些网站都是健康向上的，假如其他<br>站点和这些网站一样，那么只保留这些网站就够了；假如其他站点与这些网站不一<br>样，那么就是不健康的，是低级趣味，不能保留。这是有关部门精心设计的，是为<br>了公民的精神健康着想，生怕他们受到不良信息的侵染。</p>
<p>　　阿瓦登首先点开了“工作”，一连串和他工作相关的站点列表与相关软件在电<br>脑上显示出来。阿瓦登是一名程序员，他每天的工作就是根据上级的要求编写程序<br>。这份工作很无聊，不过可以保证他有稳定的收入。他不知道自己的源代码会被用<br>到哪里去，上级也从来没有跟他说过。 　　他打算继续昨天的工作，但是很快发现<br>自己很难继续下去。阿瓦登觉得今天的情绪比以前要烦躁，无法集中精神，大脑还<br>是很呆滞，胸口仍旧发闷。他试图娱乐自己，但是他发现“娱乐”选项里只有纸牌<br>与挖地雷，根据有关部门的说法，这是两个健康的游戏，没有暴力，没有色情，不<br>会让人产生犯罪冲动，也不涉及任何政治色彩。据说美国境外也是有互联网络站点<br>的，不过无法连上去，因为本国的互联网络自成格局，独立自主，普通人无法直接<br>连接到国外——IE浏览器没有地址栏，就算知道地址也没有用处。</p>
<p>　　“您有一封新邮件。”</p>
<p>　　系统忽然跳出来提示，阿瓦登终于找到了可以暂停工作的理由，他很快移动鼠<br>标到电子信箱的选项上，点开，很快一个新的界面出现了。</p>
<p>　　“To: 19842015</p>
<p>　　From：10045687</p>
<p>　　Subject: 模块、已经、完成、当前、项目、是否、开始。”</p>
<p>　　阿瓦登微微地叹了一口气，觉得有些失望。每一次他收到新的电子邮件，都希<br>望能够有一次新鲜的刺激来撞击他日益迟钝的脑神经，每一次他都失望了。其实他<br>早就知道这一点，只不过他觉得保持期待至少能够享受到几秒钟快感。就好象他期<br>待着打电话过来的是一个圆润温柔的女性声音一样。不给自己一些渺茫的希望，阿<br>瓦登觉得自己迟早会疯掉的。</p>
<p>　　这封信很简短，但是内容很充实。19842015是阿瓦登的网络编号，而10045687<br>则是他的一位同事的编号，这种工作性质的信件通常都以编号相称。信的内容是几<br>个不连续的英文单词，这是有关部门所提倡的一种电子邮件书写方式，因为这样可<br>以方便软件检查信件中是否含有敏感词汇。</p>
<p>　　阿瓦登打开回信的页面，同时另开了一个窗口，打开一份名字叫做“网络健康<br>语言词汇列表”的TXT文档。这是有关部门要求每一位网民所必须使用的词汇。当他<br>们书写电子邮件或者使用论坛服务的时候，都得从这个词汇列表中寻找适合的名词<br>、形容词、副词或者动词来表达自己想要说的话。一旦过滤软件发现网民使用了列<br>表以外的词，那么这个词就会被自动屏蔽，取而代之的是“请使用健康语言”。</p>
<p>　　“屏蔽”是个专有名词，被屏蔽的词将不允许再度被使用，无论是在书信里还<br>是口头都不允许。讽刺的是，“屏蔽”一词本身也是被屏蔽的词汇之一。</p>
<p>　　这个列表是经常更新的，每一次更新都会有几个词在列表上消失，于是阿瓦登<br>不得不费劲脑汁寻找其他词语来代替那个被屏蔽掉的词语或者单字。比如在以前，<br>“运动”这个词是可以使用的，但后来有关部门宣布这也是一个敏感词汇，阿瓦登<br>只好使用“质点位移”来表达相同的意思。</p>
<p>　　他对照着这份列表，很快就完成了一封文字风格与来信差不多的EMAIL——健康<br>词汇表迫使人们不得不用最短的话来表达最多意思，而且要尽量减少不必要的修辞<br>，所以这些信件就好象是那杯蒸馏水一样，淡而无味，阿瓦登有时候想，他早晚也<br>会和这些水和信一样腐烂，因为这些信是他写的，水是他喝的。</p>
<p>　　接下来阿瓦登启动检查软件先扫了一遍，确保自己没无意中加入什么敏感词汇<br>。等这一切都完成后，他按下了发送键，邮件被送出去了。</p>
<p>　　阿瓦登没有留下备份，因为他的机器里没有硬盘，也没有软驱、光驱或者USB接<br>口。这个时代宽带技术已经得到了很大发展，应用软件可以集中在统一的一个服务<br>器中，个人用户调用时的速度丝毫不会觉得迟滞。因此个人不需要硬盘，也不需要<br>本地存储，他们在自己电脑里写的每一份文档、每一段程序、甚至每一个动作都会<br>被自动传送到有关部门的公共服务器中，这样便于管理。换句话说，阿瓦登所使用<br>的电脑，仅仅具备输入和输出两种功能。</p>
<p>　　完成了这封信后，阿瓦登再度陷入了软绵绵的焦躁状态，这是一个连续工作了<br>三天的程序员的正常反应。这种情绪很危险，因为它让人效率低下精神低迷，而且<br>没有渠道发泄。“疲劳”、“烦躁”以及其他负面词汇都属于危险词汇，如果他写<br>信给别人抱怨的话，那么对方收到的将会是一封写满“请使用健康语言”的EMAIL。</p>
<p>　　这就是阿瓦登每天的生活，今天比昨天更糟糕，但应该比明天还稍微好一点。<br>事实上这个叙述也很模糊，因为阿瓦登自己并不清楚什么是“好一点”，什么是“<br>更糟糕”。“好”与“坏”是两个变量，而他的生活就是一个定量，只有一个常数<br>叫“压抑”。</p>
<p>　　阿瓦登推开鼠标，把脑袋向后仰去，长长地呼了一口气。（至少“呼”这个字<br>还没有被屏蔽）这是空虚的表现，他想哼些歌，但却又不记得什么，转而吹了几下<br>口哨，但那听起来与一只生了肺结核的狗差不多，只得做罢。有关部门象幽灵一样<br>充斥在整个房间里，让他无法舒展自己的烦闷。就好象一个人在泥沼里挣扎，刚一<br>张口就被灌入泥水，甚至无法大声呼救。</p>
<p>　　他的头不安分地转了几转，眼神偶尔撇到了摆在地板上的老式电话机，他忽然<br>想到还必须要去有关部门申请自己的BBS论坛浏览许可证。于是他关掉“工作”和“<br>电子邮件”窗口，退出了网络登陆。阿瓦登在做这些事的时候毫不犹豫，他很高兴<br>能够暂时摆脱互联网络，在那上面他只是一串枯燥的数字和一些“健康词汇”的综<br>合体。</p>
<p>　　阿瓦登找出一件破旧的黑色呢子大衣，那件大衣继承自他的父亲，袖口和领子<br>已经磨损的很严重，个别地方有灰色的棉花露出来，但还是很耐寒。他把大衣套到<br>身上，戴上一副墨绿色的护镜，用过滤口罩捂住嘴。他犹豫了一下，拿起“旁听者<br>”别在耳朵上，然后走出家门去。</p>
<p>　　纽约的街上人很少，在这个时代，互联网的普及率相当地高，大部分事务在网<br>上就可以解决，有关部门并不提倡太多的户外活动。太多的户外活动会导致和其他<br>人发生物理接触，而两个人发生物理接触后会发生什么事则很难控制。</p>
<p>　　“旁听者”就是为了防止这种事而发生的，这是一种便携式的语言过滤器，当<br>携带者说出敏感词汇的时候，它就会自动发出警报。每一位公民外出前都必须要携<br>带这个装置，以便随时检讨自己的言语。当人们意识到旁听者存在的时候，他们往<br>往会选择沉默，至少阿瓦登是如此。有关部门正逐步试图让网络和现实生活统一起<br>来，一起“健康”。</p>
<p>　　这时候正是11月份，寒风凛冽，天空漂浮着令人压抑的铅灰阴云，街道两旁的<br>电线杆仿佛落光了叶子的枯树，行人们都把自己包裹在黑色或灰色的大衣里面，浓<br>缩成空旷街道上的一个个黑点飞快移动着。一层若有若无的烟雾将整个纽约笼罩起<br>来，不用过滤口罩在这样的空气里呼吸将会是一件很有挑战的事情。</p>
<p>　　距离上一次离开家门已经有两个月了吧，阿瓦登站在公共汽车站的站牌下，不<br>无感慨地想，周围的一切看起来很陌生，泛黄，而且干燥。那是上一次沙尘暴的痕<br>迹。不过沙尘暴这个词也已经被屏蔽了，因此阿瓦登的脑海里只是闪过那么一下，<br>思想很快就转移到别的事情上去了。</p>
<p>　　站在阿瓦登旁边的是一个穿着蓝色制服的高个男人。他先是狐疑地看了阿瓦登<br>一眼，看到后者沉默地沉在黑色大衣里，他的两只脚交替移动，缓慢地凑了过去，<br>装做漫不经心对阿瓦登说：</p>
<p>　　“烟，有吗？”</p>
<p>　　男人说，每一个字都说的很清晰，而且词与词之间间隔也足够长。这“旁听者<br>”还没有精密到能够完全捕捉到每一个人语速和语调的程度，因此有关部门要求每<br>一位公民都要保持这种说话风格，以方面检测发言人是否使用了规定以外的词汇。</p>
<p>　　阿瓦登转过头去，看了他一眼，舔舔自己干裂的嘴唇，回答说：</p>
<p>　　“没有。”</p>
<p>　　男人很失望，又一次不甘心地张开嘴。</p>
<p>　　“酒，有吗？”</p>
<p>　　“没有。”</p>
<p>　　阿瓦登又重复了一次这个词，他也已经很久没有收到烟和酒了，也许是缺货的<br>关系吧，这是常有的事。不过有一点很奇怪，“旁观者”这一次却没有发出警报。<br>以阿瓦登的经验，以往一旦烟、酒或者其他生活必需品发生短缺现象，这个词就会<br>暂时成为被屏蔽掉的敏感词汇，直到恢复供给为止。</p>
<p>　　这个男人看起来很疲惫，红肿的眼睛是这个时代的人们普遍的特征，这是长时<br>间挂在网上的关系。他的头发蓬乱，嘴边还留着青色的胡子碴，制服下的衬衣领口<br>散发着刺鼻的霉味。能看的出，他也很久不曾到街上来了。</p>
<p>　　阿瓦登这时候才注意到，他的耳朵上空荡荡的，没有挂着那个银灰色的小玩意<br>“旁听者”，这实在是一件严重的事情。不携带“旁听者”外出，就意味着语言不<br>会再被过滤，一些不健康的思想和言论就有可能孳生，因此有关部门相当严厉地规<br>定公民上街必须携带旁听者。而这个男人的耳朵旁却什么也没有。阿瓦登暗暗吃惊<br>，一时间不知道是该去提醒还是装做没看到。他暗自想，也许向有关部门举报会更<br>好。</p>
<p>　　这时候那个男人又朝他靠近了一点，眼神变的饥渴起来。阿瓦登心里一阵紧张<br>，下意识地向后退去。这难道是一次抢劫？还是说他是个压抑太久的同性恋者？那<br>个男人忽然扯住他的袖子，阿瓦登狼狈地挣扎却没有挣开。出乎他的意料，那个男<br>人并没有进一步的动作，而是大吼一声，用一种阿瓦登已经不太习惯了的飞快语速<br>向他倾泻起话语来。阿瓦登被这突如其来的爆发弄的莫名其妙，不知所措。</p>
<p>　　“我只是想和你多几句话，就几句，我很久没有说过话了。我叫斯多葛，今年<br>三十二岁，记得，是三十二岁。我一直梦想有一套在湖边的房子，有一副钓鱼竿和<br>一条小艇；我讨厌网络，打倒网管；我妻子是个可恶的网络中毒者，她只会用枯燥<br>乏味的话叫我的网络编号；这个城市就是一个大疯人院，里面大疯子管着小疯子，<br>并且把所有没疯的人变的和他们同样疯狂；敏感词汇都去他X的，老子受够了……”</p>
<p>　　男人的话仿佛一瓶摇晃了很久然后突然打开的罐装碳酸饮料，迅猛，爆裂，而<br>且全无条理。阿瓦登惊愕地望着这个突然狂躁起来的家伙，却不知道如何应对；更<br>可怕的是，他发现自己居然对他产生了一点同情，那种“同病相怜”式的同情。男<br>人的话这时候已经从唠叨变成了纯粹谩骂，全部都是最直抒胸臆的那种。阿瓦登已<br>经有五、六年不曾说过这些脏话，最后一次听到这些也是四年前。有关部门认为这<br>都有碍精神文明，于是全部都屏蔽掉了。</p>
<p>　　而现在这个男人就在公众场合对着他大吵大嚷，似乎要将被屏蔽掉的敏感词汇<br>一口气全倒出来。他的目光和手势并不针对任何人，甚至也不针对阿瓦登，更象是<br>在一个人在自说自话。阿瓦登的耳膜似乎不习惯这种分贝，开始有些隐隐做痛，他<br>捂着耳朵，拿不定主意是干脆逃掉还是……这时候，远处街道出现两辆警车，一路<br>闪着警灯直直冲着这座公共汽车站而来。</p>
<p>　　警车开到站台旁时，男人仍旧在痛骂着。警车门开了，涌出了五、六名全副武<br>装的联邦警察。他们扑过去将那个男子按在地上，用橡皮棍痛打。男人两条腿挣扎<br>着，嘴里的语速更快了，骂出来的话也越来越难听。其中一名警察掏出一卷胶带，<br>“嚓”地一声扯下一条向男人的嘴贴去。男人在嘴被胶带封住之前，突然提高嗓门<br>，冲着警察痛快无比地喊了一句：“FUXKYOU, YOUSONOFBITCH！”阿瓦登看到他的<br>表情由疯狂变成享受，面带着微笑，似乎完全陶醉在那一句话所带来的无上快感和<br>解脱感中。</p>
<p>　　联邦警察们七手八脚地将男人送进了警车，这时才有一名警察走到了阿瓦登的<br>跟前。</p>
<p>　　“他，是，你朋友？”</p>
<p>　　“我，不，认识。”</p>
<p>　　警察盯了他一阵，取下他耳朵上的“旁观者”查看记录，发现他并没有提及任<br>何敏感词汇，于是重新给他戴回去，警告他说那名男子说的全部都是极度反动的词<br>汇，要求他立刻忘掉，然后转身押着那男子离开了。</p>
<p>　　阿瓦登松了一口气，其实刚才他有一瞬间涌现出一种冲动，也想在这空旷的街<br>道上大喊一声“FUXKYOU, YOUSONOFBITCH”那一定很爽快，他心里想，因为那男子<br>说出这句话的时候表情很享受。不过他也知道，这也是妄想的一种，“旁观者”紧<br>帖在耳朵上的冰凉感觉时刻提醒着他。 　　街上很快就恢复了冷清，十分钟后，一<br>辆公共汽车慢吞吞地开进站里，锈迹斑斑的车门哗啦一声打开，一个电子女声响彻<br>整个空荡荡的车厢：“请乘客注意文明用语，严格按照健康词汇发言。”</p>
<p>　　阿瓦登把自己缩进大衣，压抑住自己异样的兴奋，决定继续保持沉默下去。</p>
<p>　　大约过了一个小时，公共汽车到了目的地。从破碎的车窗玻璃里吹进来的寒风<br>让阿瓦登脸上挂起一层暗灰色的霜气，面部被风中的沙砾和煤渣刮的生疼。他听到<br>电子女声报出了站名，就站起身来，象一条狗一样抖抖身上的土，走下车去。</p>
<p>　　车站对面就是阿瓦登要去的地方，那是有关部门负责受理BBS论坛申请的网络部<br>。这是一间五层的大楼，正方形，全水泥混凝土结构，外表泛灰。如果没有那几个<br>窗户的话，那么它的外貌将与水泥块没有任何区别：生硬、死气沉沉，让蚊子和蝙<br>蝠都退避三舍。</p>
<p>　　BBS论坛是一种奇特的东西，从理论上来讲它完全多余，BBS的功能完全可以由<br>EMAIL新闻组来取代，后者更容易管理和审查。而且申请使用BBS论坛资格不是件容<br>易的事，申请人必须要通过十几道手续和漫长的审查才能有浏览资格，浏览资格三<br>个月才会被允许在指定论坛发布帖子，至于自己开设BBS则几乎是不可能。</p>
<p>　　因此真正对BBS有兴趣的人少之有少。阿瓦登当初之所以决定申请BBS论坛资格<br>，纯粹是因为他那种模糊但却顽强的怀旧心态，就好象他从杂货店里买的那部老式<br>电话一样。他也不知道自己为什么会自找麻烦，也许是为了给生活带来些刺激，还<br>是说为了强调自己和曾经旧时代的那么一点点联系，也许两者兼有之。</p>
<p>　　阿瓦登恍惚记得在他小的时候，互联网与现在并不太一样。并不是指技术上的<br>不同，而是一种人文的感觉。他希望能通过使用BBS论坛回想起一些当年的事情。</p>
<p>　　阿瓦登走进网络部的大楼，大楼里和外面一样寒冷，而且阴森。走廊里没有路<br>灯，蓝白色调的两侧墙壁贴满了千篇一律的网络规章条文与标语，冰冷的空气呼吸<br>到肺里，让阿瓦登一阵痉挛。只有走廊尽头的小门缝隙里流泻出一丝光亮，小门的<br>上面挂着一块牌子，上面写的是“网络部BBS论坛科。”</p>
<p>　　一走进这间屋子，阿瓦登立刻感觉到一阵温洋洋的热气。屋子里的暖气（或者<br>是空调）开的很大，让阿瓦登冻麻了的手脚和脸麻酥酥的，有些发痒，他不禁想伸<br>出手去挠挠。</p>
<p>　　“公民，请您站在原地不要动。”</p>
<p>　　一个电子女声忽然从天花板上的喇叭里传来，阿瓦登触电似地把手放下，恭敬<br>地站在原地不同。他借这个机会观察了一下这间屋子。这屋子准确来说应该是一个<br>狭长形的大厅，一道拔地而起的大理石柜台象长城一样将房间割裂成两部分，柜台<br>上还装着一排银白色的圆柱形栅栏，直接连到天花板。屋子里没有任何装饰，没有<br>观赏植物，没有塑料鲜花，甚至没有长椅和饮水机。</p>
<p>　　“缔造健康的互联网络，美国万岁。”</p>
<p>　　阿瓦登跟着声音重复了一遍。</p>
<p>　　“请前往八号窗口。”</p>
<p>　　电子女声的语调很流畅，因为这是电脑制作出来的，因此没有敏感词汇的限制<br>。</p>
<p>　　阿瓦登转头看到在自己右手边的不远处，大理石柜台上的液晶屏幕显示着八号<br>的字样。他走过去，拼命抬起头，因为柜台实在太高了，他只能勉强看到边缘，而<br>无法看到柜台另一侧的情形。不过他能听到，一个人走到柜台对面，坐下去，并有<br>翻动纸张与敲击键盘的声音。</p>
<p>　　“请把文件放入盒子里。”</p>
<p>　　柜台上的喇叭传来命令。出乎意料，这一次在喇叭里的声音却变了。虽然同样<br>冷漠枯燥，但阿瓦登还是能分辨出它与电子女声的不同——这是一个真正的女性的<br>声音。他惊讶地抬头望去，却什么都看不到，柜台太高了。</p>
<p>　　“请把文件放入盒子里。”</p>
<p>　　声音又重复了一次，语气里带着一丝烦躁，似乎对阿瓦登的迟钝很不满。</p>
<p>　　“是的，这是真正的女声……”阿瓦登想，电子女声永远是彬彬有礼不带任何<br>感情色彩的。他把相关的电子身份证、网络许可证、网络编号和敏感词汇犯罪记录<br>等一系列个人资料卡片一起放进柜台外的一个小金属盒子里，然后把盒子插进柜台<br>上一个同样大小的凹槽中，关好门。 很快他听到“唰”的一声，他猜测这也许是对<br>面的人——也许是个女人——将盒子抽出去的声音。</p>
<p>　　“你申请BBS服务的目的是什么？”</p>
<p>　　</p>
<p>　　喇叭后的女声浸满了纯粹事务性的腔调。</p>
<p>　　“为了、提高、互联网络、工作效率、为了、缔造、一个、健康、的网络、环<br>境，更好地、为、祖国、做出、贡献。”</p>
<p>　　阿瓦登一字一句地回答，心里知道这只是一道官方程序，只需要按标准回答就<br>可以。</p>
<p>　　对面很快就陷入沉默，大约过了十五分钟，喇叭再度响起。</p>
<p>　　“最后手续确认，你已经获得BBS论坛浏览权。”</p>
<p>　　“谢谢。”</p>
<p>　　“砰”的一声，金属盒子从柜子里弹了出来，里面除了阿瓦登的证件以外还多<br>了五张小尺寸光盘。</p>
<p>　　“这是有关部门核发给你的BBS论坛统一用户名与密码，BBS论坛列表、互联网<br>BBS论坛使用指南及相应法规、以及最新健康网络词汇列表。”</p>
<p>　　阿瓦登向前踏了一步，从盒子里将这些东西一股脑全拿出来，揣进大衣的大兜<br>里。那些东西其实是可以全部放在同一张光盘里的，不过有关部门认为每一张光盘<br>装一份文件有助于用户理解这些文件的严肃性和重要性，并产生敬畏。</p>
<p>　　他心里盼望着那个喇叭能再说两句。让他失望的是，对面传来的是一个人起身<br>并且离开的声音，从脚步声的韵律判断，阿瓦登愈发相信这是一名女性。</p>
<p>　　“手续办理完毕，请离开网络部回到自己的工作岗位上。”</p>
<p>　　甜美空洞的电子女声从天花板上传来，阿瓦登厌恶地抽动鼻翼，拿手揉了揉，<br>转身离开这间温暖的大厅，重新进入到寒冷的走廊。</p>
<p>　　在回家的路上，阿瓦登蜷缩在公共汽车上一动不动，顺利申请到BBS的使用权让<br>他有些虚无缥缈的兴奋。他闭着眼睛，找了一个合适的角度躲开破窗而入的寒风，<br>右手在兜里不断摩挲那一系列光盘，还在怀念着那一个神秘的女声。</p>
<p>　　如果能再一次听到该多好，他不能抑制自己这样的想法，同时用拇指的指肚在<br>光盘上轻轻地摩擦，幻想这几张光盘也曾经被她的手触摸过。他兴奋的几乎也想破<br>口大骂一句“FUXKYOU, YOUSONOFBITCH”，真奇怪，那名男子的骂声在他的记忆里<br>根深蒂固，并时不时不自觉地滑到唇边。</p>
<p>　　忽然，他的手指在光盘上发觉到一丝异常的感觉。阿瓦登下意识地朝四周望去<br>，确认周围一个乘客也没有后，他小心翼翼地把光盘全拿出来，就着窗外的光亮仔<br>细端详。</p>
<p>　　阿瓦登很快注意到，在装有BBS论坛列表的光盘背面，被人用指甲轻轻地划了一<br>道刮痕。这条刮痕很轻，如果不是阿瓦登仔细地抚摩光盘的话，是很难发觉到的。<br>这条刮痕很奇特，是一条直线，而在这条直线末端的不远处，则是另外一条极短的<br>刮痕，似乎刻意想弯成一个圆点。整体看上去就好象是一个叹号，或者倒过来说，<br>象是字母i。</p>
<p>　　很快他在其他四张光盘上也发现了类似的刮痕，它们造型都不同，但都似乎代<br>表着某种符号。阿瓦登回想起喇叭里那个女声最后一句提到过的文件顺序，于是把<br>这五张光盘按照BBS论坛统一用户名与密码、BBS论坛列表、互联网BBS论坛使用指南<br>、相应法规、以及最新健康网络词汇列表的顺序排列好，接着依次把那五道刮痕用<br>手指临摹到汽车窗户上。很快那些刮痕构成了一个英文单词：</p>
<p>　　title</p>
<p>　　题目？这是什么意思？</p>
<p>　　阿瓦登看着这个单词莫名其妙，这究竟是纯属无意的痕迹，还是有人刻意为之<br>？如果是有人刻意为之，他这么做的用意是什么？</p>
<p>　　这时候汽车停住了，又有几名乘客走上车来。阿瓦登挪动一下身体，不让他们<br>看到自己在车窗上写出来的字迹，然后装做打呵欠的样子抬起袖子，轻轻把那五个<br>字母擦掉。</p>
<p>　　阿瓦登暗自庆幸，如果他没有在现在发现这些光盘上的痕迹，那么以后就永远<br>没有机会发觉了。按照规定，个人电脑是不允许使用任何存储存设备的，因此阿瓦<br>登的电脑并没有光驱。他下一步所要做的是将这些光盘送交到管区网络安全部，由<br>他们将光盘内资料登陆到服务器中，再转发给阿瓦登。这是为了防止个人私自在家<br>里制造、阅读或者传播黄色或者反动信息，网络安全部发出的通告是这么解释的。<br>联邦的网络警察经常会突入到个人家中进行临时检查，看用户是否非法拥有信息贮<br>存设备，阿瓦登曾经亲眼见过一个邻居被警察带走，原因仅仅是因为他私自藏了一<br>张光盘在家里——其实他只是打算拿那个当茶杯垫用。那个邻居再没回来过。</p>
<p>　　无论这些符号代表的是什么意思，它都是一种全新的体验，这让阿瓦登感觉到<br>兴奋。怀旧与渴望新奇是阿瓦登生活在这个时代的两根精神支柱，否则他会与这座<br>城市一样变的僵硬，然后窒息而死。</p>
<p>　　他先来到网络安全分部，将光盘交给那里的负责人，负责人反复地检查光盘和<br>阿瓦登的表情，好象所有使用BBS论坛的人都不可信赖一样。末了负责人终于找不到<br>什么破绽，只得将光盘收下，然后举起右手，阿瓦登和他一起高呼“缔造健康的互<br>联网络”。这句话是唯一被允许可以连贯着被说出来的句子。</p>
<p>　　回到家里，阿瓦登脱掉大衣，摘了过滤口罩，将旁观者扔到了行军床上，然后<br>整个人也倒进枕头里。每次出去外面都会让他疲劳，这一半是因为他孱弱的肉体已<br>经不大适合室外活动；另外一半原因是因为他必须花费大量的精力来应付旁观者。</p>
<p>　　过了四十分钟，他才悠悠地醒过来，头还是和平常一样地疼，胸口还是一如既<br>往地闷。胡乱吃了一点东西以后，阿瓦登爬到电脑桌前，打开电脑，按程序登陆上<br>网络，习惯性地先检查了一遍信箱。</p>
<p>　　信箱里有七、八封新的信件，其中两封是同事发来的事务信。另外五封则是网<br>络安全部发给他的，内容就是他送交的那几张光盘。</p>
<p>　　阿瓦登打开了包含有BBS论坛的用户名、密码和BBS论坛列表的两封信。他看到<br>自己的论坛通用用户名叫做19842015，和自己的网络编号完全一样，不由得有些失<br>望。他依稀记得在小的时候，BBS论坛的用户名是可以自己决定的，而且每一个论坛<br>都可以不同，一个人在网上并不单只是一串枯燥数字。</p>
<p>　　小时候的记忆往往是跟童话和幻想混杂在一起，未必与实际相符。现实中你只<br>能使用有关部门指定的用户名和密码，理由很简单，用户名和密码内也可能含有敏<br>感词汇。</p>
<p>　　阿瓦登又打开了那份BBS列表，全部都是有关部门开设的官方论坛，没有私人的<br>——事实上个人能够合法持有的电脑设备从技术上来说也无法架设新BBS——这些论<br>坛的主题各有侧重点不同，但基本上是围绕着如何更好响应国家号召，缔造健康互<br>联网络来说的。比如其中一个电脑技术论坛，主题就是如何更好地屏蔽掉敏感词汇<br>。</p>
<p>　　居然在这些论坛中还有一个是关于游戏的。里面正在讨论的是一个如何帮助别<br>人使用健康词汇的网络游戏，玩家可以操纵一名小男孩在街上侦察，看是否有人使<br>用了敏感词汇，小男孩可以选择上前指责或者通知警察，抓到的人越多，小男孩得<br>到的褒奖就越高。</p>
<p>　　阿瓦登随便打开了几个论坛，里面的人都彬彬有礼，说话很“健康”，就好象<br>街上的那些行人一样。不，准确地说，比街上的气氛还要压抑。在街上的人也许还<br>有机会保留一下自己的小动作，比如阿瓦登刚才在公共汽车上就偷偷地写了TITLE五<br>个字母；而在网上论坛，人的最后的一点隐私也全被暴露出来，有关部门随时可以<br>调看你的一切行动，无从遁形，这就是科学技术发展所带来的进步。</p>
<p>　　一阵失落和失望袭上阿瓦登的心头，他合上眼睛，把鼠标甩开，重重地向后靠<br>去。原来他天真地以为BBS论坛也许会少许宽松一些，现在看来甚至比现实中更叫人<br>窒息，他感觉到自己好象陷入沉滞的电子淤泥之中，艰于呼吸。“FUXKYOU, YOUSO<br>NOFBITCH”再一次涌现到他的唇边，强烈无比，要化好大的力气才控制住。</p>
<p>　　忽然，他又想到了那个神秘的title，那究竟是什么意思？那五张光盘里或许隐<br>藏着什么？也许这跟title有关系？</p>
<p>　　阿瓦登想到这里，把目光重新转向电脑屏幕，仔细去看网络安全部发来的五封<br>信的title部分。五张光盘各隐藏着一个字母，凑到一起就是title，那么按照这个<br>方式，那五封EMAIL的title凑到一起，就变成了一句话：去用户学习论坛。”</p>
<p>　　阿瓦登记得刚才他确实看到其中一个论坛的名字叫做“用户学习”，于是他抱<br>着姑且一试的心态连接到这个论坛去。他希望这并不是一个巧合。</p>
<p>　　用户论坛是一个事务性论坛，里面是一些关于BBS用户资料的投诉帖和管理帖，<br>斑竹的是一个叫19387465的人；发帖的人和回帖的人数量都很少，里面冷冷清清的<br>。阿瓦登打开帖子列表，按照刚才的规律去搜寻每一个帖子的标题，并把它们综合<br>到一起，很快他就得到了另外一句话： 　　“每周日辛普森大楼5层B户。”</p>
<p>　　又是一个谜团，阿瓦登想。但这却坚定了他的信心，这其中必定隐藏着玄机。<br>光盘、EMAIL和BBS论坛，连续三次都可以通过首词组组合的方式得到暗示，绝非巧<br>合。</p>
<p>　　究竟是什么人会在有关部门的官方文件中隐藏着这样的信息呢？每周日在效率<br>大楼5层B户又会发生什么事情呢？</p>
<p>　　阿瓦登终于找到了久违的兴奋感，未知事物的新奇刺激着他麻木很久的神经。<br>更重要的是，这种在有关部门正式文件中玩弄的文字技巧，叫他有一种喘息的快感<br>，仿佛一个密不透风的铁面罩上几个透进空气的小孔。</p>
<p>　　营造健康的互联网络。</p>
<p>　　FUXKYOU, YOUSONOFBITCH。</p>
<p>　　阿瓦登盯着屏幕上的桌面背景，用嘴唇比出了那句粗话的口型，并且比出了中<br>指。</p>
<p>　　在接下来的日子里，阿瓦登一直处于一种潜藏的兴奋状态，就象是一个摆出无<br>辜表情嘴里却藏着糖果的小孩子，在大人转身过去之后露出狡黠的笑容，尽情享受<br>心中藏有秘密的乐趣。</p>
<p>　　日子一天一天地过去，健康词汇在列表里又少了几个，窗外的空气又浑浊了几<br>分，这已经是生活的常态。阿瓦登自己已经开始拿网络健康词汇表当日历来用，划<br>掉三个词就证明过了三天，划掉七个就证明过了一周，于是周日终于到来了。</p>
<p>　　阿瓦登抵达辛普森大楼的时间是中午，暗示的句子里并没有指明时间，阿瓦登<br>认为在中午前往应该是比较可以接受的。当穿着深绿军大衣，耳朵上别着旁观者的<br>阿瓦登来到辛普森大楼的入口时，他的心开始忐忑不安地跳跃起来。他在上一星期<br>设想了无数种可能发生的情景，而现在这个谜底就要揭晓了。无论在周日效率大楼<br>会发生什么，也不会比现在的生活更加糟糕，阿瓦登心里想，所以他并不怎么害怕<br>。</p>
<p>　　他走进大楼内部，发现这里的人也很少，空旷的走廊里只听到他哒哒的脚步声<br>与回音。一部老电梯里贴着“缔造美好网络家园”的广告，以及一个充满了正义感<br>的男性头像海报，背景是星条旗，他在纸里用右手食指指向观看者，头上写着一行<br>字是“公民，请使用健康词汇。”阿瓦登厌恶地转过身去，发现另外一侧也贴着同<br>样的海报，避无可避。</p>
<p>　　值得庆幸的是五楼很快就到了，电梯的门一开，对面的门上就赫然挂着B户的牌<br>子。门是掉了漆的绿色，门框上还点了几滴墨水，一部简易的电子门铃挂在右上角<br>。</p>
<p>　　阿瓦登深深吸了一口气，伸手去按电纽。</p>
<p>　　电铃响起，很快屋子里传来脚步声。阿瓦登觉得这脚步的韵律很熟悉，似乎是<br>在哪里见到过。门“咔拉”一声被打开一半，一名年轻女子一手握着把手，把身体<br>前倾望着阿瓦登，警惕地说：</p>
<p>　　“你，找谁？”</p>
<p>　　女子疑惑地问道。阿瓦登一下子就认出了她的声音，就是那个在网络部BBS论坛<br>科柜台后面的女性。她很漂亮，穿着墨绿色绒线衫，头上梳着这时代流行的短发，<br>皮肤特别的白，只有嘴唇能看到一些血色。</p>
<p>　　看着女子的眼神，一瞬间阿瓦登不知道该说什么好，犹豫了一下，他举起右手<br>，轻声回答说：“title。”</p>
<p>　　阿瓦登不知道这句话能否奏效，也不知道自己是否真的找对了地方，但这是他<br>唯一能想到的回答了。他紧张地望着那女子，假如那女子忽然报警，那么自己就会<br>被抓起来仔细审问为什么无缘无故跑到陌生人家里。“肆意游走罪”只比“使用敏<br>感词汇罪”轻那么一点。</p>
<p>　　女子听到他这么说，脸上还是毫无表情，只是把头幅度很轻微地点了一下，右<br>手谨慎地做了一个“进来”的手势。阿瓦登刚要张口，那女子严厉地瞪了他一眼，<br>吓的他把话又吞回去了，乖乖地跟着她进了屋子。</p>
<p>　　一进屋子，女子首先做的就是把门关好，然后拉起来一层铅灰色的门帘挡在门<br>口。阿瓦登不安地眨着眼睛，趁她拉门帘的时候环顾四周。这屋子是标准的两室一<br>厅，在厅里摆放的是一套双人沙发与一个茶几，茶几上居然还有几束红紫色的塑料<br>花。靠墙是电脑桌和电脑，墙上挂着普通的白色日历， 但被主人用粉红色的纸套了<br>边，看起来颇为温馨。一盏粗笨的日光灯从天花板上垂下来，上面象是恶作剧一样<br>挂了几缕绿色的电线，象是垂下藤蔓的葡萄架。阿瓦登注意到厅口的鞋架上有四双<br>鞋，尺码不同，说明今天的客人并不只他一个。</p>
<p>　　阿瓦登正踌躇不安，忽然女子从背后拍了拍他的肩膀，示意他朝里面走。于是<br>两个人穿过客厅另一侧的短小回廊来到其中一间卧室。卧室上挂着同样质地的铅灰<br>色帘子，女子伸手举起帘布，推开了门。阿瓦登迈了进去，首先映入眼帘的是三名<br>面带微笑的人类，以及一间用真正的鲜花装点的房间。屋子里有很多旧日记忆里的<br>古老物品，比如一幅印象派的油画、一尊乌干达木雕，甚至还有一个银烛台，唯独<br>没有电脑。</p>
<p>　　他正在迟疑，女子也进了屋子。她谨慎地拉好门帘关上门，将耳边的旁观者取<br>下，回过身来对阿瓦登用曼妙的声音说道：</p>
<p>　　“欢迎加入说话会！”</p>
<p>　　“说话会？”</p>
<p>　　出于习惯，阿瓦登并没有把这三个字说出口，因为他不确定是否“健康”，只<br>是用眼神表示自己的疑惑。</p>
<p>　　“在这里你可以随便说话，这个该死的东西不会起作用的。”女子把自己的旁<br>观者晃了晃，那个小东西象死掉了一样，对女子句子里两个敏感词汇“随便”和“<br>该死”充耳不闻。</p>
<p>　　阿瓦登一下子想到上星期在公共汽车站前碰到的男子，如果他摘下旁观者，会<br>不会也会落到同一境地呢？那女子见他犹豫不决，指了指门口的铅灰色门帘说：“<br>放心好了，这里是可以屏蔽掉旁观者信号的，不会有人觉察到。”</p>
<p>　　“你们，是什么，人，这，是，哪里？”</p>
<p>　　阿瓦登一边摘下耳朵上的旁观者，一边小声说道，语调还是改不了那种有关部<br>门规定的说话方式。</p>
<p>　　“这里是说话会，是一个完全自由场所，在这里你可以畅所欲言，请不要拘束<br>。”</p>
<p>　　另外一个人起身对他说道，这是一名瘦高的中年男子，鼻梁上的眼镜非常地厚<br>。</p>
<p>　　阿瓦登嗫嚅着，却找不到发音的焦点，在四个人的注视下显得窘迫不堪，脸都<br>要红起来。女子同情地看了他一眼：“可怜的家伙，不用太紧张，每一个刚到这里<br>的人都是这样。慢慢就习惯了。”</p>
<p>　　她把手搭到阿瓦登的肩上：“我们其实见过的，当然，我见过你，而你没见过<br>我。”她一边说，一边将自己的头发解下来，原来她留的是一头齐肩的乌黑长发，<br>头发披下来的一瞬间阿瓦登觉得她真的很美。</p>
<p>　　“我……我记得你，记得你的声音。”阿瓦登终于说出了一句完整的话，虽然<br>不够流畅。</p>
<p>　　“是吗，那可太好了。”女子笑起来，拉着他的手，让他坐到沙发上，递给他<br>一杯水。阿瓦登注意到这是一个款式古老的茶杯，上面还刻着花纹，杯子里的水带<br>着浓郁的香气，阿瓦登尝了一点，那种甜丝丝的味道对喝惯纯净水的舌头来说刺激<br>格外地大。让他觉得浑身一下子被注进了许多活力。</p>
<p>　　“弄到这个可不容易，我们也不是每周都能喝到。”女子坐到他身边，两只乌<br>黑的眼睛注视着他，“你是怎么知道这个集会的？”</p>
<p>　　阿瓦登把发现光盘暗示的过程说了一遍，其他四个人都赞许地点了点头。“果<br>然是个聪明人，脑筋还没被陈腐的空气腐蚀掉。”一个三十多岁的胖子称赞道，他<br>的嗓门大的要命。那个戴眼镜的中年人把两只手交叉在一起，表示赞同。</p>
<p>　　“这正是天生的说话会成员，聪明、敏锐，而且不甘屈从于沉默。”</p>
<p>　　“那么。”胖子提议，“先让我们鼓掌欢迎说话会的新成员吧。”</p>
<p>　　于是四个人鼓起掌来，小小的屋子里响起一片掌声。阿瓦登羞涩地举起杯子做<br>回应，他还不太习惯这样的场面。等到掌声稍息，他抬起头怯生生地问道：</p>
<p>　　“可以问个问题吗？说话会到底是什么？”</p>
<p>　　带他进屋的女子伸出食指，在他鼻子前两公分的地方比了一比，解释道：</p>
<p>　　“说话会，就是可以畅所欲言的集会。在这里你不必顾忌什么，说出任何你想<br>说的东西。这里没有敏感词汇，也没有健康互联网络。这里是绝对自由的空间，你<br>可以尽情释放你的灵魂，舒展你的身体，没有任何禁锢与束缚。”说着说着，她的<br>声音变的高亢、奔放，里面饱含了许多早已经被屏蔽掉的词汇，阿瓦登不曾听到这<br>样流畅连贯的话语很久了。</p>
<p>　　“我们的宗旨就是，说话，就这么简单。”中年人扶扶眼镜，补充道。</p>
<p>　　“可是，要说些什么呢？”阿瓦登又问道。</p>
<p>　　“任何事情，你心里想的任何事情都可以说出来。”中年人露出宽和的笑容，<br>“尤其是那些被美国政府限制的思想。”</p>
<p>　　这可真是一个大胆的集会啊，这分明就是犯罪，阿瓦登心想，但他发觉自己却<br>被这种犯罪慢慢地吸引住了。</p>
<p>　　</p>
<p>　　“当然，有件事我们会事先说明。说话会是危险的，每一个成员都冒着被有关<br>部门拘捕的风险。联邦执法人员也随时可能破门而入，以非法集会以及非法使用不<br>合法词语的名义把我们抓起来。你现在有权拒绝加入，并且离开。”</p>
<p>　　阿瓦登听到女子的警告，心里一度犹豫起来。但一想到此刻离去的话，那么又<br>要开始持续那种窒息的泥沼生活，他就难以压抑自己的烦闷。阿瓦登第一次发现，<br>原来“说话”对他来说是一个致命的诱惑，他先前并不知道自己原来是如此地渴望<br>着说话。</p>
<p>　　“我不会离开的，我要加入你们，说话。”</p>
<p>　　“那太好了。唔，那么不妨就从自我介绍开始吧。”女子高兴地说，同时站起<br>身来，把右手搭到胸前，“从我开始。我的名字叫阿尔特弥斯，至于网络编号和身<br>份证号码，让他们见鬼去吧！谁会去管那个！我有我自己的名字，我不是数字。”</p>
<p>　　她的话让所有人包括阿瓦登都笑了起来。接着她继续说道：“不过，这其实只<br>是一个假名，这是希腊神话里的女神。”</p>
<p>　　“假名？”</p>
<p>　　“是的，和我户籍本上的名字是不同的。”</p>
<p>　　“可是，为什么？”</p>
<p>　　“你不会对自己在档案里的名字厌倦吗？我想起一个自己喜欢的名字，哪怕只<br>有一次机会也好，自己想叫什么就叫什么。在这个说话会里的每一个人都有一个自<br>己喜欢的名字，我们彼此拿这个称呼。”</p>
<p>　　阿瓦登若有所思地点点头，他很理解阿尔特弥斯的想法。事实上当他在使用网<br>络论坛的时候，也希望能够自己取一个称心如意的名字，而不是被分配一个用户名<br>。</p>
<p>　　通过介绍，阿瓦登了解到阿尔特弥斯是网络部BBS论坛管理科的职员，今年23岁<br>，未婚，最讨厌蟑螂和蜘蛛，喜欢缝纫与园艺，屋子里的花就是她偷偷从城市边缘<br>摘回来的。</p>
<p>　　接下来是那名中年人，他自我介绍说名字叫兰斯洛特，41岁，是城市电厂的一<br>名工程师；兰斯洛特这名字出自英国的亚瑟王传说，是一名忠贞的骑士。他有自己<br>的老婆和两个孩子，一男一女；男孩三岁，女孩四岁，他们最喜欢吃的就是柠檬味<br>道的水果糖。说到这里，兰斯洛特说希望下次聚会能把他们也带了，孩子们正是学<br>说话的时候，他想教给他们真正的说话。</p>
<p>　　那个三十多岁的胖子是网络部的一名网管，叫瓦格纳。这个身份让阿瓦登吃惊<br>不已，他的印象里网管都是些绷着脸全无表情的冷漠生物，但眼前的瓦格纳脸圆滚<br>滚的，油光锃亮，嘴边两条翘起的小胡子神气十足。他喜欢的是雪茄和歌剧，利用<br>网管的特权这两样东西都不难弄到。</p>
<p>　　“这个能屏蔽掉信号的门帘就是他弄的。”阿尔特弥斯补充说，瓦格纳冲她做<br>了个“乐意为您效劳”的手势，然后点燃了雪茄，把它放到嘴里，很快屋子里就笼<br>罩起一片稀薄的烟雾。</p>
<p>　　说话会的第四名成员是一位穿着黑色制服的女性，今年刚满三十。她的名字是<br>杜拉丝，城市日报（那个时代的报纸已经全部都数字化了）的编辑，她比阿尔特弥<br>斯还瘦，颧骨高高耸起，眼窝身陷，两片薄薄的嘴唇即使在最说话的时候也很少分<br>开，看不到牙齿。爱好是饲养狗和猫，尽管她并没有养。</p>
<p>　　“那么，到你了。”阿尔特弥斯对阿瓦登说。阿瓦登想了想，结结巴巴地把自<br>己的情况说了一遍，当谈到自己的爱好时候，他一时间居然想不到自己喜好什么，<br>似乎什么都没有，在那之前他甚至从来没想过。</p>
<p>　　“那，你最想做的是什么事呢？”阿尔特弥斯把手再一次放在他肩上，诱导着<br>问道。</p>
<p>　　“真的什么都可以？”</p>
<p>　　“什么都可以，在这里没有任何限制。”</p>
<p>　　阿瓦登觉得自己终于找到机会了，他咳了一声，抓抓头，脱口而出一句响亮的<br>叫喊：“FUXKYOU, YOUSONOFBITCH！”</p>
<p>　　在一瞬间，在座的四个人都被他这句话震惊了。瓦格纳率先反应了过来，他先<br>叼住雪茄，用力鼓掌，然后用右手把雪茄取下来，张嘴大声地赞叹道：“真棒，痛<br>快，这简直是最完美的入会誓词。”</p>
<p>　　“我宁可听十遍这样的脏话，也不想再去碰那个乏味的电子女声。”兰斯洛特<br>也是一脸陶醉，毫不掩饰自己对电子女声的厌恶。而阿尔特弥斯和杜拉丝全都咯咯<br>地笑起来，杜拉丝发现自己的笑容幅度大了一点，不好意思地把嘴掩住。阿瓦登觉<br>得他们与其说是觉得新奇，不如说是在享受这句脏话所带来的对体制的蔑视与挑战<br>。</p>
<p>　　“那你叫希望自己叫什么名字呢？” 阿尔特弥斯歪着头问。</p>
<p>　　“唔……王二。“ 阿瓦登沉吟了一下，回答说。这是一个中式的名字，他以前<br>有一个中国人朋友，喜欢讲故事，故事里的主角名字总是叫王二。</p>
<p>　　屋子里的气氛现在完全融洽了，大家都开始谈些比较自然的话题，每个人都摆<br>出了最舒服的姿势，阿尔特弥斯不时拿起茶壶来为大家续水。阿瓦登紧张的心情逐<br>渐放松下来，他感觉到自己的脑子前所未有地轻松。</p>
<p>　　“你知道的。”阿尔特弥斯又给他倒了一杯甜水，“我们一直想把说话会保持<br>在一定规模，平日是没有办法畅所欲言的，我们需要空间。麻烦的是，我们没办法<br>公开征集会员，又不可能直接通过物理接触去寻找，那风险太大。于是兰斯洛特就<br>设计了一套暗示系统，只有发现这些暗示的人才能知道本会的存在。”</p>
<p>　　“这套系统考虑到的还不止是安全问题。”兰斯洛特把自己的眼镜摘下来仔细<br>擦拭了一下，得意地说，“这其实也是一个会员资格验证。说话会所吸纳的成员，<br>必须有智慧，有头脑，内心渴望激情，并且对自由有着渴望。”</p>
<p>　　瓦格纳用两根指头夹着雪茄，在事先准备好的烟灰缸里弹了弹烟灰，大声说道<br>：“据我的经验，申请BBS论坛服务的人，大多数都是为了怀旧，或者说渴望一些新<br>鲜的东西，这样的人往往都怀有激情，认为BBS论坛也许能给他们一些与现实不一样<br>的东西——当然，事实上并非如此，美国政府对BBS论坛的管理甚至严厉过电子邮件<br>——这暗示着他们心里渴望解脱束缚。因此我们将暗示隐藏在申请BBS论坛的光盘之<br>中，只有申请人才有机会接触到这些暗示。而只有那些有智慧、观察敏锐的人才会<br>发觉到这些暗示的存在，并顺利解读出来，找到这里。”</p>
<p>　　“归根到底，说话会也不过是一群渴望自由说话的秘密小团体罢了。”兰斯洛<br>特笑道。</p>
<p>　　“你是第二个找到说话会的人，第一个是杜拉丝小姐。”</p>
<p>　　阿尔特弥斯告诉阿瓦登。阿瓦登敬佩地看了杜拉丝一眼，后者淡淡地回答道：<br>“这没什么，这是我的工作，我的工作就是摆弄文字。”</p>
<p>　　阿瓦登想到上一周在公共汽车站碰到的那个疯狂男子，于是把这件事讲给其他<br>成员听。听完之后，兰斯洛特摇了摇头，从嘴唇里滑出一声叹息：</p>
<p>“这样的事情我也是见过的，我的一个同事就是如此。所以说话会的存在是必要的<br>，这是缓解压力的阀门。长时间的敏感词汇限制会让人都疯掉的，因为他们既无法<br>思考又没办法表达。”</p>
<p>“这正是美国政府有关部门所希望看到的，这样只有傻瓜能够存活下来，一个全是<br>傻瓜的社会是稳定的。” 瓦格纳费力地把自己肥胖的身躯挪了一下位置，轻蔑地说<br>。</p>
<p>“你也是有关部门的一分子，瓦格纳先生。”阿尔特弥斯一边往茶杯里续了些热水<br>，一边抬头轻声说道。</p>
<p>“阿尔特弥斯小姐，我只是一个能比普通人多使用几个敏感词汇的普通人而已。”</p>
<p>　　大家都笑了起来。阿瓦登从来没有见过这么多的人说这么多的话，这是前所未<br>有的奇妙经验。他惊讶地发现自己居然很快就融进了这个小圈子里，隔阂与陌生感<br>很快就消失了；同时消失的还有胸闷与头晕等习惯性的毛病。</p>
<p>　　很快话题就从说话会本身扩展到了更加宽泛随意的话题，阿尔特弥斯唱支歌，<br>兰斯洛特说了几个笑话，杜拉丝则给大家讲了美国南部诸州的风土人情；瓦格纳甚<br>至还唱了一段歌剧，虽然阿瓦登一个字也听不懂，但他一点也不吝惜掌声。在这个<br>城市的某一个被屏蔽掉的角落里，五个不甘沉默的人正在享受着在这个时代视为奢<br>侈品的事情——说话。</p>
<p>　　“王二，你可曾看过《1984》？”</p>
<p>　　阿尔特弥斯忽然问道，她就靠着阿瓦登坐下，阿瓦登摇摇头，反问道：“这是<br>网络编号的一段么？”</p>
<p>　　“这是一本书的名字。”</p>
<p>　　“书？”阿瓦登听到这个名词，头摇的更大了。这是个古老的名词，在这个电<br>脑技术非常发达的时代，网络可以承载一切信息，任何人都可以在网上图书馆查到<br>电子版；因此有关部门认为实体书籍变成了一种没有必要存在的浪费，实体书也就<br>逐渐消亡了。瓦格纳对此的评论是：“有关部门喜欢电子书籍的心情是可以理解的<br>，电子书籍的话，只需要FIND和REPLACE两个命令就可以消灭掉全部不健康词汇，替<br>一本书消毒；而实体书籍的校对与修订却是件旷日持久的工作。”</p>
<p>　　“这是一本伟大的书，是旧世界哲人们对我们这个时代的预言。”阿尔特弥斯<br>认真地说。“它很早以前就洞察到了肉的束缚与解脱，灵的束缚与解脱，这是说话<br>会的基石。”</p>
<p>　　阿瓦登不无惊奇地发现他的网络编号开头恰好是这这本书名字：19842015。</p>
<p>　　“那么，该怎么样才能看到呢？”阿瓦登盯着阿尔特弥斯乌黑色的眼睛问。</p>
<p>　　“我们也无法找到纸质版，网络图书馆不可能存在这样的书。”兰斯洛特摇摇<br>头，然后重新露出笑容，左手向着杜拉丝摆了个请的姿势，“但我们的杜拉丝小姐<br>应该为她的记忆力而自豪，她在很早已经有幸阅读过这两本书，并且能够记得里面<br>的大部分文字。”</p>
<p>　　“太好了，然后她写下来了，对吗？”</p>
<p>　　“那太危险，这时代持有实体书是个大罪过，也容易让说话会暴露。我们只是<br>在每次聚会的时候请杜拉丝小姐为我们背诵。既然是说话会，那么把这两个故事讲<br>出来不是更名符其实吗？”</p>
<p>　　大家都安静下来，杜拉丝站起来走到屋子中央，其他四个人坐在旁边看着她。<br>阿瓦登不经意地把手搂在阿尔特弥斯肩上，后者微微朝这边靠过来，女性头发的幽<br>香“咝咝”地划过他的鼻子，让他的心里一阵荡漾。屋子里非常暖和，他分不清这<br>是花香还是阿尔特弥斯的味道。</p>
<p>　　杜拉丝的声音并不高，不过却很清晰有力；她的记忆力确实惊人，不仅记得情<br>节，包括一些细节和句子都可以复述下来。杜拉丝讲到了朱丽亚假装摔倒，然后偷<br>偷递给温斯顿一张写着“我爱你”的纸条，绘声绘色，这让听众们都听的入神了，<br>阿尔特弥斯听的尤其认真，以至于都没有注意到阿瓦登一直注视着她。</p>
<p>　　“1984的作者预见到了专制的进步，却没有预见到技术的进步。”瓦格纳在杜<br>拉丝停下来喝水的时候发表自己的评论，阿瓦登觉得他与外貌不太相称，是个很有<br>洞察力的技术官僚。</p>
<p>　　“在大洋国人们还可以靠传递纸条来偷偷表达自己的想法，但是现在不一样了<br>。美国政府有关部门把我们全赶到了网上，而在网络技术发达的今天，我们即使想<br>发一条短信都会被系统或者网管看的一清二楚，无从遁形。现实里呢，还有旁观者<br>在。”瓦格纳在腿上敲了敲雪茄根部，“一句话，技术是中性的，但技术的进步会<br>让自在的世界更自在，集权的世界更加集权。”</p>
<p>　　“这句话说的很有哲学家的味道哟。”阿尔特弥斯冲瓦格纳挤了挤眼睛，从抽<br>屉里取来一把饼干和曲奇散发给大家。</p>
<p>　　“就好象同样是0和1，有的人就能写出工具软件，有人却拿那个编出恶性病毒<br>？”</p>
<p>　　阿瓦登想到一个类似的比喻，瓦格纳听了以后满意地打了个响指。</p>
<p>　　“很不错的比喻，王二，就是如此，真不愧是程序员。”</p>
<p>　　谈话持续了不知道有多久，杜拉斯看了一眼墙壁上的挂钟，连忙提醒谈兴正浓<br>的四个人时间快到了。说话会不能持续很长时间，旁听者被屏蔽的越久，暴露的危<br>险就越大。</p>
<p>　　“那么好吧，我们就抓紧最后半个小时来完成今天的活动。”</p>
<p>　　阿尔特弥斯一边说着，一边将桌子上的空杯子收走。兰斯洛特和瓦格纳也都站<br>起身来，活动一下已经有些酸疼的肩膀和腰，只有杜拉丝坐在位子上没有动。</p>
<p>　　“活动？还有什么活动？”</p>
<p>　　阿瓦登奇怪地问道，说话会除了说话还有其他活动？</p>
<p>　　“唔，对啊，我们还有其他活动。”阿尔特弥斯撩起额前的长发，对他妩媚一<br>笑：“我们还会和对方完全交流。”</p>
<p>　　“完全交流？”</p>
<p>　　“就是intercourse”</p>
<p>　　“………………”阿瓦登一下子变的脸色苍白，呼吸急促起来，仿佛胃里被灌<br>进去零下三十度的寒风，他几乎不相信自己的耳朵。</p>
<p>　　“说话会有说话的自由，也有选择与谁上床的自由。”阿尔特弥斯毫不羞涩地<br>说，“我们互相谈话，然后选择合适的人做爱，就象我们选择我们喜欢的词汇说话<br>一样。”</p>
<p>　　兰斯洛特看阿瓦登很窘迫，走过去拍拍他的肩膀，慢慢地说：“当然，我们不<br>会强迫任何人，这完全是在自愿的基础上。今天我还要早点回去照顾小孩，你们人<br>数正好合适。”</p>
<p>　　阿瓦登的脸色涨红，热的仿佛夏季的电脑CPU，他甚至不敢多看阿尔特弥斯一眼<br>。他憧憬过女性很长时间，但如此接近还是第一次。</p>
<p>　　还要回家去照顾小孩子的兰斯洛特向大家道别后就先行离去了，阿尔特弥斯将<br>房间留给瓦格纳与杜拉丝，然后带着惶恐不安的阿瓦登来到了另外一间房间。这间<br>显然是阿尔特弥斯的卧室，屋子里很简单，但却收拾的十分干净，在床上枕头旁还<br>摆着一个手制的布娃娃，床单和窗帘都是粉红色的。</p>
<p>　　最初的是由阿尔特弥斯主动开始的，丝毫没心理准备的阿瓦登只是被动地任她<br>摆布。经过了几轮挑逗，阿瓦登才逐渐放开，任由潜藏在自己心内的原始欲望奔流<br>出来，那种期待听到圆润女声的青春憧憬本来只是苦闷生活的意淫，而在今天它加<br>倍实现了。很快这种憧憬与他在现实中被压抑的郁闷合流，转化成了猛烈的冲动，<br>让他一次又一次与阿尔特弥斯融为一体。阿瓦登不知道这种冲动和他想大声说出“<br>FUXKYOU, YOUSONOFBITCH”冲动有什么不同，不过现在不是考虑这个的时候，他现<br>在脑子里想的只有尽情地、全无束缚地让自己释放激情，完全没有任何束缚。</p>
<p>　　强烈的刺激一波波地冲击着兴奋中枢，最终一阵快感浪潮在狂暴洋面扬起头来<br>，达到了一个极高的顶端。阿瓦登在那一瞬间感觉到了前所未有的自由，那种轻盈<br>无比的自由，以及因自由而生的快乐与疲惫。浑身是汗的他喘息着倒在了阿尔特弥<br>斯身上，一阵舒畅的倦意如潮水般淹没了他的身体……</p>
<p>　　……当他醒来的时候，发现阿尔特弥斯躺在自己身边，赤裸的身体好象一尊白<br>玉雕像，睡姿恬美静谧。他侧过身子去，慵懒地打了个呵欠，然后阿尔特弥斯睁开<br>了眼睛。</p>
<p>　　“很舒服，对不对？”她问道。</p>
<p>　　“是啊……”阿瓦登不知道该说什么好，他顿了顿，犹豫地说道：“你以前和<br>兰斯洛特、瓦格纳他们也……呃，我是说，象刚才那样子过吗？”</p>
<p>　　“是的。”阿尔特弥斯温柔地回答，她半支起胳膊，长发从肩膀披到了胸口。<br>她的大方坦白反而让阿瓦登有些不知所措。屋子里出现了一段时间的沉默，然后阿<br>尔特弥斯忽然开口问道：</p>
<p>　　“还记得今天杜拉丝讲的那段故事吗？女主角偷偷递给男主角写着“我爱你”<br>的纸条。”</p>
<p>　　“唔，还记得。”阿瓦登回答，很高兴终于能从那个拙劣的话题摆脱出来了。</p>
<p>　　“在有关部门的健康互联网络词汇列表里，没有爱这个字呢。在我们这个时代<br>，我爱你也是一个敏感词汇，被屏蔽掉了。”阿尔特弥斯的眼神里似乎是感慨，又<br>象是失落。</p>
<p>　　“我爱你。”阿瓦登不禁脱口而出，他知道在这间屋子里可以说出任何自己想<br>说的话，不必顾忌。</p>
<p>　　“谢谢你。”</p>
<p>　　阿尔特弥斯听到之后只是笑了笑，起身穿上衣服，催促阿瓦登时间差不多了。<br>阿瓦登有些失望，因为她没有预期反应的热烈，仿佛他刚才说的只是有些无关紧要<br>的东西。</p>
<p>　　这时候杜拉丝和瓦格纳已经离开了，屋子里只剩他们两个人。阿尔特弥斯把他<br>送到门口，将旁观者交给他，然后叮嘱他说：“记得在外面绝对不要提及说话会的<br>任何事情或者任何人，我们在说话会以外的地方是完全不认识的。”</p>
<p>　　“我记住了。”阿瓦登回答，然后转身要走。</p>
<p>　　“王二。”</p>
<p>　　阿尔特弥斯忽然叫道，阿瓦登连忙转身，还没等他反应过来，两片柔软温暖的<br>嘴唇忽然贴到了他的双唇，然后是一个细切的声音在耳边响起：“谢谢你，我爱你<br>。”</p>
<p>　　阿瓦登觉得眼睛有些湿润，他戴上旁观者，推开门，重新步入到那一片令人窒<br>息的世界中去，但他此时已与来时的心境大不相同。</p>
<p>　　此后阿瓦登的精神面貌明显有了改善。他谨慎地享受着这种秘密集会的乐趣，<br>并且乐在其中。每一周或者两周，他们五个人都会在周日秘密地举行说话会的活动<br>，聊天，唱歌或者听杜拉丝讲1984的故事。阿瓦登同阿尔特弥斯又“完全交流”了<br>几次，偶尔他也会跟杜拉丝“交流”。他有了两个身份，一个是现实中和网上的阿<br>瓦登，编号19842015，还有一个是说话会里的王二。他很享受这个名字，觉得这就<br>是自己另外的一个人生。</p>
<p>　　有一次集会，他们谈到了敏感词汇的问题。阿瓦登记得很早的时候——他对这<br>方面的记忆有点模糊——有关部门给出的是一份敏感词汇列表，由网站的内部管理<br>人员秘密参考使用，他对如何演变成现在的局面大惑不解。那一天瓦格纳带了一瓶<br>葡萄酒，兴致很高，于是索性给他们讲了讲“屏蔽”的进化史，身为网管的他经常<br>可以接触到这些资料。</p>
<p>　　在最开始美国政府只是单纯地屏蔽掉敏感词汇，但很快他们就发现这样的措施<br>根本没有用处。很多人会采取在词组中夹杂符号或者数字的方式来绕开系统检查；<br>于是有关部门不得不将这些近似敏感词汇也一一屏蔽掉。然而众所周知，数字与符<br>号之间的组合方式是近乎无限的，只要你有想象力，就完全可以组合出一个新的词<br>组而且不失掉他的原意。比如说“politic”这个词，就有“politi&#x2F;c”、“政pol<br>it&#x2F;ic”、“pol&#x2F;itic”等近乎无限种表达方式。</p>
<p>　　当有关部门意识到这个问题时，他们采取了新的策略。既然无法辨识词组，那<br>么就用单词屏蔽。这一举措在一开始是奏效的，违规交谈的人显著减少，但很快人<br>们就发现可以用同音字或者谐音的方式来继续表达自己的危险思想。即使有关部门<br>封掉全部敏感词汇的同音字，也无济于事，思想活跃的美国人充分发挥了自己的想<br>象力，使用隐喻，借代、类比、引申及其他修辞方法，或者将一个敏感词用数个不<br>敏感的字来代替。人类的思维方式要比电脑开阔许多。电脑屏蔽掉一条路，他们还<br>会有更多的路可以选择。</p>
<p>　　这一场水面以下的角力看起来似乎是美国大众要取得胜利。这时候，一个具有<br>逆向思维精神的人出现了。他的身份不明。有人说他是有关部门的主管；也有人说<br>他是因过度使用敏感词汇而被捕的危险人士。无论他是谁，总之整个局面被扭转过<br>来。他向有关部门建议，不再告诉大众禁止说什么，而是规定他们只能说什么，用<br>什么方式去说。有关部门很快就心领神会，制订了新的规章制度：取消了敏感词汇<br>列表，取而代之的是互联网络健康语言列表，并把这举措推广到了日常生活中的语<br>言屏蔽系统中去。</p>
<p>　　这一次，大众终于处于下风。以往他们与有关部门尽情地在网络与现实中捉着<br>迷藏，而现在他们却被有关部门扼住了咽喉。这样一来，有关部门可以有效率地掌<br>握住言论，因为整个语言的框架都被彻底控制了。在有限的空间内，大众几乎是无<br>计可施。</p>
<p>　　尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他<br>们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思<br>就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一<br>动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使<br>用。</p>
<p>　　“当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组<br>，那么就可以继续自由交流——你知道莫尔斯电码吧？”</p>
<p>　　瓦格纳说到这里，拿起茶杯一饮而尽，满意地打了一个嗝。</p>
<p>　　“可是，这场战争的代价就是语言的失落。表达能力会越来越贫乏，越来越淡<br>而无味，人们会越来越倾向于沉默，这对有关部门反而是好事。”兰斯洛特摆出一<br>副忧虑的表情，有节奏地用指关节敲击着桌面，“这样一来，岂不就等于是大众的<br>自由意识将语言推向死亡的边缘？真讽刺啊。按照这个趋势，有关部门是不会败的<br>，他们会笑到最后。”</p>
<p>　　“不，不，笑这种情感他们是不会了解的。”瓦格纳淡淡地回答。</p>
<p>　　“我倒是觉得，美国是一直处于恐惧的情感之中呢，生怕人们掌握了太多的词<br>汇，表达出太多的思想，变的难以掌握。”阿尔特弥斯说完摆出一副她在上班期间<br>冷若冰霜的呆板脸孔，学着僵硬的腔调喊了一句：“营造健康的网络环境，美国万<br>岁！”</p>
<p>　　杜拉丝、兰斯洛特与瓦格纳都哈哈大笑，唯一没笑的是王二（阿瓦登）。他对<br>于兰斯洛特刚才的那句话始终耿耿于怀：大众与有关部门的对抗，其最终结局就是<br>语言的消亡。那么他们现在这个小小的说话会，也只不过是在一列开向悬崖的列车<br>里关上窗帘，享受坠毁前最后的宁静罢了。</p>
<p>　　不过他没有说出口，因为这太煞风景了。阿瓦登不希望破坏说话会的气氛，这<br>对他很重要。</p>
<p>　　从说话会回到家里，阿瓦登躺在行军床上，双手枕着脑袋，陷入了沉思。自从<br>加入说话会以后，他变的比以前更容易陷入思考。有时候他想的是这个社会、这个<br>互联网络或者这座城市中存在的荒谬性；有时候他想的是自己的生活；还有时候他<br>想的是阿尔特弥斯。他不知道是不是在一个压抑的世界里，人的情感会变的格外强<br>烈，他现在陷入对阿尔特弥斯的迷恋无法自拔。阿瓦登一直很羡慕杜拉丝讲的《19<br>84》里面的温斯顿，他和朱利亚有一间两个人独处的小屋，一个只属于他们两个人<br>的小世界。</p>
<p>　　他在与阿尔特弥斯“完全交流”的时候曾经吐露过自己的心声，阿尔特弥斯没<br>有直接回答，而是表示两个人的关系无法再比说话会更近一步——维持现在的状态<br>就已经是个人行为的极限，有关部门可不会一直打瞌睡。“我们只能把感情生活压<br>缩在每周一次的说话会活动里，这已经很奢侈了。”她对他说，同时温柔地抚摩他<br>的胸膛。“只有在说话会里，我们才是阿尔特弥斯和王二。而在其他时间里，你是<br>19842015，而我是19387465。”</p>
<p>　　对此，阿瓦登只能发出一声轻轻的叹息，确实他不该奢求更多。</p>
<p>　　除了感情，发生变化的还有互联网络。自从加入说话会以后，阿瓦登逐渐发现<br>互联网表面下潜藏的一些东西。正如瓦格纳在一次活动的时候指出，普罗大众与有<br>关部门的战争从未结束，总会有思想和言论从严厉管制的缝隙中流泻出来。阿瓦登<br>发现，在完全公式化的EMAIL与网络论坛中其实隐藏着不少耐人寻味的细节，就好象<br>那个title一样，存在着各式各样的密码与隐藏寓意。这些东西出自不同人的手里，<br>样式和破译方式都不同，阿瓦登不知道那些密码背后隐藏的是怎样的内容。不过有<br>一点可以确知的是，说话会并不是唯一的一个地下集会，瓦格纳说的对，始终还是<br>有人在试图用“健康”词汇表达“不健康”思想。</p>
<p>　　讽刺的是，给阿瓦登感触最深的，是有关部门的管制。以往他只是模糊地感觉<br>到自己被绑缚起来，现在他能清晰地看清这种束缚与压抑的脉络，以及加诸在自己<br>身上的各种手段。在小小说话会中享受到的自在让他更加深刻地感受到在宽阔现实<br>中的不自在。</p>
<p>　　“FUXKYOU, YOUSONOFBITCH！”</p>
<p>　　每一次的聚会，三位男士都会轻蔑地一起高喊这一句粗话。他们清楚这不会给<br>有关部门带来什么不良影响，不过这确实很痛快。</p>
<p>　　这一周，阿瓦登特别地忙碌，他的同事因为不明原因而被屏蔽掉了，这样一来<br>整个项目就全压在了他一个人身上。这项目是为有关部分设计一种软件，用来控制<br>大功率主动式“旁观者”的能源分配控制。软件很复杂，他不得不每天在电脑前工<br>作十几个小时，只有在身体实在支撑不住的时候才停下来随便吃一点东西，喝一口<br>纯净水，困了就躺在旁边的行军床上睡上一觉，爬起来继续工作。屋子里满是浑浊<br>的烟味与袜子脏衣服的酸臭味，阿瓦登就在这种环境下蓬头垢面地敲着键盘，并不<br>时揉揉满布血丝的眼睛。</p>
<p>　　偏偏在这个时候屋子里的暖气坏掉了。洋灰色的暖气片从昨天开始就变的冰凉<br>，不再有热水流动。阿瓦登检查了一下，发现并不是管道问题，而且邻居们也碰到<br>同样的事，看来是供热系统出了问题。这一变故的正面影响是稍微淡化了屋子内的<br>酸臭味，负面影响是整个屋子变的有如冰窖一样。紧闭的窗户和门能挡住寒风，却<br>挡不住寒冷，低温让本来就寒酸的房间更笼罩上一层霜气。无论是那把木椅还是行<br>军床都象是冷酷的冰雕，屋子里唯一还有些热气的就只剩下电脑。阿瓦登不得不披<br>上所有的御寒衣物，蜷缩在床上，把电脑的散热口对准自己。</p>
<p>　　有关部门宣布“供热”和“暖气”暂时也被列入敏感词汇，于是阿瓦登没办法<br>写信向供热部门询问，只好静待，除了用来敲键盘的指头以外，尽量保持全身一动<br>不动，以节约热量。在停止供暖后的第四天，暖气片里终于传来“哗啦哗啦”的声<br>音，带着热气的水开始流动，屋子里恢复了温暖，“供热”和“暖气”又可以恢复<br>使用了。于是EMAIL与网络论坛上全都是“庆祝有关部门恢复供应暖气，急人民之所<br>急”的帖子，EMAIL新闻组里也全是类似主题。</p>
<p>　　不过这对阿瓦登来说太晚了，他生了病，感冒，而且是重感冒。他面色苍白，<br>全身软弱无力，头疼的象是被一枚达姆弹射入头部，只能躺在床上等医生。医生来<br>到他家里，给他做了两三次点滴，喂了一些叫不上名字的药片，叫他静养。这一场<br>病足足持续了数天，他不得不放弃参加这一星期的说话会，身体状况实在太差了，<br>阿瓦登甚至怀疑自己搞不好会因此而死掉。</p>
<p>　　阿瓦登躺在床上，心里懊悔不已，说话会是他唯一的乐趣，现在他却没办法参<br>加。他把头蒙在被子里胡思乱想，瓦格纳这一次会带什么特别的东西来呢？兰斯洛<br>特有没有把两个孩子也领过来？还有阿尔特弥斯，他没参加的话，她会和谁“完全<br>交流”呢？瓦格纳还是兰斯洛特？他还想到了杜拉丝，上一次的聚会里，杜拉丝讲<br>到了温斯顿在秘密幽会的屋子里对朱丽亚说“我们已经死了”，朱丽亚附和着说“<br>我们已经死了”，这时候第三个声音说道“你们已经死了。”</p>
<p>　　杜拉丝就讲到这里，就停住了。阿瓦登急切地想知道接下来发生了什么，第三<br>个声音是谁，是党吗？温斯顿和朱丽亚是否会被捕，他们会有什么样的下场？不光<br>是他，阿尔特弥斯也很希望知道后续情节的发展，不过她并没有去追问杜拉丝。</p>
<p>　　“让这成为一个悬疑，这样接下来的一周我们的生活都会在期待的乐趣中度过<br>。”她对阿瓦登说，然后两个人继续沉溺于intercourse的快乐。</p>
<p>　　“也许他们都会死。”阿尔特弥斯在交流结束后，看着天花板说。</p>
<p>　　“也许那只是奥布林的声音，他去探望他们。”阿瓦登安慰她道，但是他的心<br>里也不确定。</p>
<p>　　阿瓦登的病持续了十天，然后他终于痊愈了。他痊愈后的第一件事就是从床上<br>爬起来，然后去看墙上的日历：这一天恰好是星期日，说话会活动的日子。阿瓦登<br>已经缺席了一周，这已经令他如饥似渴，甚至做梦都在和他们一起喋喋不休地说着<br>话——所幸他并没有说梦话的习惯，所以24小时工作的旁观者并没发出任何警报。</p>
<p>　　阿瓦登简单地洗了一下脸，用一把有些生锈的剃刀沾着肥皂仔细地刮掉脸上粗<br>硬的胡须，然后咕噜咕噜地刷了刷牙齿，用手和毛巾沾着热水将自己蓬起的乱发压<br>下去。因为生病，有关部门发了一些补贴给他，其中包括两块羊角面包、两瓶姜汁<br>啤酒和一份精制砂糖。他将这些东西都用塑料布仔细包好，揣到宽大的军大衣里，<br>打算带到说话会上去与大家分享。</p>
<p>　　今天的天气和往常一样地冷，阿瓦登把自己裹在大衣里，登上前往效率大楼的<br>公共汽车。一路上车厢里的广播重复着“营造健康的互联网络”以及一些优秀网络<br>用户的先进事迹；车厢前面的电子屏幕不断滚动显示着最新的健康词汇列表，一个<br>旁观者自车顶垂下来睥睨着车内的每一个表情呆滞的人。阿瓦登坐在最后一排，望<br>着窗外不断向后移动的建筑物与枯黄的树木发呆。</p>
<p>　　车子很快就到达了辛普森大楼附近的车站，阿瓦登下了车，把手放到怀里摸了<br>摸塑料布包着的食物，朝着大楼走去。他在半路无意中抬起头，忽然一阵冰冷的寒<br>流刺入他的胸腔，迫使他停住了脚步。</p>
<p>　　有什么地方不对劲！</p>
<p>　　他看到了效率大楼的第五层阿尔特弥斯家的窗户发生了一些奇怪的变化。以前阿尔特弥斯家面向大街的窗户总是挂着粉红色的窗帘，而现在窗帘则被扯到了两边<br>，窗户大开，用肉眼可以勉强看到窗玻璃和屋子里雪白的墙壁。假如今天有说话会<br>的话，阿尔特弥斯绝对不会把有屏蔽效果的窗帘打开。而且打开窗户这件事也绝不<br>寻常，在这个城市里的室外空气十分浑浊，几乎不会有人会去开窗换气。</p>
<p>　　也就是说，今天并没有说话集会召开，而是发生了另外一些事情。阿瓦登望着<br>那窗户，心情开始变的有些慌乱，他把手从兜里掏出来，叼起一支香烟，把身体靠<br>在一根电线杆旁故做镇静，以免被行人怀疑。究竟说话会发生了什么，为什么这一<br>周停办了呢？要知道，只要还有复数的成员能够出席，说话会就会一直办下去，难<br>道说瓦格纳、兰斯洛特、杜拉丝和阿尔特弥斯同时无法出席？这种概率实在太小了<br>。阿瓦登一边这样想着，一边向四周不安地张望。忽然他看到了一样东西，一个念<br>头霎时占据了他的全部心灵，让他几乎眩晕过去。</p>
<p>　　“说话会本周不会有了，以后也不会有了。”阿瓦登嘴唇默默地蠕动着，面如<br>死灰。</p>
<p>　　他看到在街道内侧一处不起眼的地方隐藏着一个类似雷达天线的东西，其造型<br>很象是两个背部贴在一起的大碗。阿瓦登心里清楚这是什么东西：这正是他负责软<br>件设计的大功率主动式“旁观者”，这造型他很熟悉。这装置可以主动发射电波去<br>探测人们的声音，并检查其中是否存在敏感词汇。</p>
<p>　　这样的装置居然就安放在阿尔特弥斯家附近，那么就等于说话会完全暴露在了<br>有关部门的监控之下。主动式旁观者的强大刺探电波会轻易刺穿她家中的铅质窗帘<br>，把所有成员的话原封不动地传到有关部门耳朵里。</p>
<p>　　这是一个划时代的发明，这一技术的突破意味着有关部门可以不再被动地等待<br>警报，可以主动出击去刺探人们在任何时间任何地点说的任何话语。阿瓦登可以想<br>象接下来会发生什么，阿尔特弥斯他们的每一句话都被有关部门记录下来，会有机<br>器统计出到底有多少违禁词汇被他们使用过；然后联邦警察会冲进她的屋子，将正<br>在聚会的成员们都带走，只留下搜查过后空荡荡的房间和窗户。</p>
<p>　　阿瓦登想到这里，心如刀绞，他一点也不为自己的侥幸逃脱而感到幸运。他的<br>胃袋翻腾起来，一种恶心的感觉从胃里直接升到嘴边，让他想吐，却又不能吐——<br>因为“呕”也是个敏感词汇；大病初愈的孱弱身躯无法承受这种打击，象害了风寒<br>一样颤抖起来，几乎站立不住。</p>
<p>　　他不敢继续朝前走去，仓皇地转过身去，登上另外一辆公共汽车，把嘴闭的更<br>紧了。等阿瓦登回到自己家楼下，看到楼房附近另外一架新的主动式旁观者正在兴<br>建中，漆黑的天线在半空舒展开来，仿佛一面巨大的蜘蛛网。看来有关部门已经着<br>手在整个纽约市部署这种新兴高科技产品。</p>
<p>　　他不敢驻足观看，低着头从那巨大装置旁边走过，一路不停地走回家，然后把<br>自己的脸紧紧地压在枕头里，却不敢哭出声音来，连一句“FUXKYOU, YOUSONOFBIT<br>CH”都不能说。</p>
<p>　　从那以后，阿瓦登的生活回到了普通状态——就是说和原来一样沉滞、压抑、<br>欠缺激情，健康向上，缺乏低级趣味。兰斯洛特说过：“战争的结果就是，大众的<br>自由意识会将语言推向死亡的边缘”，现在看来，他的预言是很准确的：说话会的<br>覆灭，导致“说话”、“歌剧”、“完全”、“交流”几个词先后被剔除出了健康<br>词汇列表，成为敏感词汇。</p>
<p>　　另外，虽然阿拉伯数字还能用，但“1984”这一个数字组合也被屏蔽掉了，这<br>让包括阿瓦登在内的程序员在编写程序时不得不谨慎地检查数字是否违规，这额外<br>增加了很多工作量，让他更加疲惫。</p>
<p>　　阿瓦登不是没有担心过，也许在某一天的深夜，他就会忽然接到一封EMAIL，让<br>他留在家里不要动，不要试图在网络做任何动作；接着电话会响起，电子女声会把<br>这一要求重复再重复，直到警察打开他家的大门，把他带去未知的地方，那里有未<br>知的命运等待着他。《1984》后面的情节发展阿瓦登始终不知道，唯一知道的杜拉<br>丝已经彻底失踪了，所以温斯顿和朱丽亚的结局始终是个谜；就好象兰斯洛特、瓦<br>格纳、杜拉丝和阿尔特弥斯的结局一样，也不从得知。其实这两件事对于阿瓦登来<br>说没什么本质性的区别，所以它们也可以看做是同一个谜。</p>
<p>　　其实他最担心的，是阿尔特弥斯。每次想到这个名字，阿瓦登就难以抑制心中<br>的郁闷。她究竟会怎么样，彻底被屏蔽掉吗？如果是那样，那么她在这世界上遗留<br>下来的唯一痕迹，就是一个程序员记忆里的假名而已了。</p>
<p>　　说话会消失后三个星期，仍旧风平浪静，没有任何人来找过阿瓦登，他也没收<br>到过任何类似内容的EMAIL，阿瓦登一直在想，也许是他们没有吐露出自己的下落，<br>也可能是因为他们根本不知道——他们认识的只是一个叫王二的程序员。这个城市<br>里有数以千计的程序员，而王二是个假名。</p>
<p>　　因此，生活一如既往地平静。不，确切地说，还是有一点不同的，那就是互联<br>网络健康词汇列表：那上面的词组消失的速度比以前要快的快，每小时每分钟都有<br>词与单字飞快地在名单上消失，阿瓦登不得不花上大量时间去更新列表，以跟紧当<br>前形势。</p>
<p>　　与词汇列表更新速度相对的，EMAIL和网络论坛上的东西越来越乏味。因为人们<br>不得不用极有限的词去表达广泛的意思，大家都变得寡言少语。就连那些秘密的暗<br>语和联系方式也少了许多；整个网络就象是前些天阿瓦登家里出了问题的暖气片一<br>样：虽然名义上是给人带来温暖的东西，但却变的冰冷、僵硬，让人如坠冰窟。</p>
<p>　　这一天，阿瓦登从电脑前抬起头来，他看了看窗外迷茫的灰色天空，胸口一阵<br>抽搐，不由得痛苦地咳了一声。他拿起塑料杯，将杯子里的纯净水一饮而尽，杯子<br>丢进同样是塑料质地的垃圾桶里，发出钝钝的撞击声，他觉得自己的脑子也是一团<br>垃圾，举起手敲了敲，果然发出同样钝钝的撞击声。</p>
<p>　　然后他拿起大衣，戴上墨绿色的护目镜，走出门去。阿瓦登没带便携式的旁观<br>者，那东西已经不需要了，城市里到处都是主动式的旁观者，随时监听是否有违禁<br>词汇的存在。整个纽约现在就象是互联网络一样，被有关部门营造成十分健康。</p>
<p>　　阿瓦登这一次外出是有正当理由的，他决定去取消网络论坛服务，这服务已经<br>用不着了，因为无论EMAIL，新闻组，BBS论坛还是其他什么现在全部都变成了一样<br>的东西。</p>
<p>　　从日历来说现在应该是春季，但外面还是很冷，高大的灰色建筑矗立在平地上<br>，仿佛绝对零度下的石林。大团大团的风裹着黄沙与废气穿行其间，风沙无处不在<br>，让人置身其中而难以摆脱。阿瓦登把手揣进兜里，脖子缩进领口，畏缩着向网络<br>部的大楼走去。</p>
<p>　　忽然，他停下了脚步，惊讶地站在原地无法动弹。他看到阿尔特弥斯正站在前<br>面的路灯下，穿着黑色的制服。可是她的变化有多么大啊，面容象是老了十岁，满<br>脸都是衰老的皱纹，年轻的活力荡然无存；她听到脚步声，转过头来，两个乌黑的<br>大眼睛显得异常空洞，目光越过阿瓦登延伸到远方，没有一个明晰的焦点。</p>
<p>　　阿瓦登万万没有想到会在这个时间这个地点碰到她，这让他已经沉寂已久的心<br>灵泛起了几点火花，可惜他迟钝的神经已经无法表达出“激动”这一个简单的情感<br>了。两个人互相对视了一阵，他终于木然走到她身边，张了张嘴唇，想对她说些什<br>么。但是他掏出今天新发布的健康词汇列表，发现上面是一片空白——终于连最后<br>一个词组也被有关部门屏蔽了。<br>　于是阿瓦登只好保持着沉默，默默地与面无表情的她擦肩而过，继续向前走去<br>。他的身影逐渐融入同样安静的灰色人群之中，整个城市都显得寂静极了。</p>
</blockquote>
<p>全文完。</p>
]]></content>
  </entry>
  <entry>
    <title>EspoCRM 选型记录：约束、PoC 与总成本核算</title>
    <url>/2025/10/26/espocrm/00-why-espocrm/</url>
    <content><![CDATA[<blockquote>
<p>适用场景：中小团队、需要定制开发、偏好自托管&#x2F;私有部署</p>
</blockquote>
<p>选择 CRM 不是选“功能最强的”，而是选“在你约束下长期最省心的”。很多团队选型翻车，不是因为功能不够，而是因为忽略了三件事：<strong>定制成本、运维成本、合规成本</strong>。本文给出一套可复用的选型方法，并用 EspoCRM 做一次完整落地。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li><strong>选型核心</strong>：先锁定“非妥协需求”，再做 PoC（概念验证）与成本核算</li>
<li><strong>最终选择</strong>：EspoCRM 9.2.2+ 开源版（自托管）</li>
<li><strong>关键理由</strong>：元数据驱动、升级可控、扩展点清晰、社区活跃</li>
<li><strong>提前警告</strong>：AGPLv3 合规 + 中文本地化 + 报表&#x2F;移动端短板要提前设计兜底</li>
</ul>
<hr>
<h2 id="1-选型核心维度"><a href="#1-选型核心维度" class="headerlink" title="1. 选型核心维度"></a>1. 选型核心维度</h2><p>选择 CRM 前，先明确你的“非妥协需求”（不满足就直接淘汰），避免陷入“看功能列表越看越爽”的幻觉。</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">说明</th>
<th align="left">推荐取向</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能覆盖</strong></td>
<td align="left">客户管理、商机、销售漏斗、日历、任务</td>
<td align="left">✅ 基础 CRM 功能</td>
</tr>
<tr>
<td align="left"><strong>定制能力</strong></td>
<td align="left">能否二次开发、扩展性如何</td>
<td align="left">✅ 必须支持深度定制</td>
</tr>
<tr>
<td align="left"><strong>部署方式</strong></td>
<td align="left">SaaS vs 自托管</td>
<td align="left">✅ 必须支持私有部署</td>
</tr>
<tr>
<td align="left"><strong>成本</strong></td>
<td align="left">许可费、服务器成本、开发成本</td>
<td align="left">✅ 开源免费为主</td>
</tr>
<tr>
<td align="left"><strong>技术栈</strong></td>
<td align="left">开发语言、框架、数据库</td>
<td align="left">⚠️ 不做硬性限制</td>
</tr>
<tr>
<td align="left"><strong>社区活跃度</strong></td>
<td align="left">更新频率、问题解决速度</td>
<td align="left">✅ 活跃维护</td>
</tr>
</tbody></table>
<p>很多团队漏掉但“后期一定会咬你”的维度：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">为什么关键</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>权限模型</strong></td>
<td align="left">组织架构、数据隔离、字段级&#x2F;记录级权限决定能否落地</td>
</tr>
<tr>
<td align="left"><strong>审计与合规</strong></td>
<td align="left">操作日志、数据导出控制、留存策略影响风控与合规</td>
</tr>
<tr>
<td align="left"><strong>数据迁移</strong></td>
<td align="left">Excel&#x2F;旧系统导入、字段映射、去重策略常常是项目的主战场</td>
</tr>
<tr>
<td align="left"><strong>集成能力</strong></td>
<td align="left">邮件、日历、IM、呼叫中心、财务系统对接决定“是不是工具孤岛”</td>
</tr>
</tbody></table>
<h3 id="1-1-选型流程（可复用模板）"><a href="#1-1-选型流程（可复用模板）" class="headerlink" title="1.1 选型流程（可复用模板）"></a>1.1 选型流程（可复用模板）</h3><p>把“选型”当一个小项目做，效率反而更高：</p>
<ol>
<li><strong>列清单</strong>：写下 10 条非妥协需求 + 10 条可妥协需求</li>
<li><strong>拉候选</strong>：3-5 个产品即可（太多只会把精力浪费在表格上）</li>
<li><strong>做 PoC</strong>：用真实业务跑通 3 条关键流程（线索→商机→成交；客户→活动→跟进；导入→分配→权限）</li>
<li><strong>算总成本</strong>：一年内人力（开发&#x2F;运维&#x2F;培训）+ 服务器 + 机会成本</li>
<li><strong>做合规评估</strong>：尤其是许可证（如 AGPL）与数据安全边界</li>
</ol>
<h3 id="1-2-技术栈：为什么-Java-背景也可能选择-PHP"><a href="#1-2-技术栈：为什么-Java-背景也可能选择-PHP" class="headerlink" title="1.2 技术栈：为什么 Java 背景也可能选择 PHP"></a>1.2 技术栈：为什么 Java 背景也可能选择 PHP</h3><p>如果你的团队偏 <strong>Java 背景</strong>，起初可能也会优先看 Java 技术栈的 CRM（例如 Apache OFBiz 等）。但在 CRM 这类”产品复杂度极高”的系统里，<strong>技术栈匹配往往不是第一优先级</strong>。</p>
<p>AI 编程助手的普及进一步降低了语言切换成本，但它解决的是“语法与样板”，不是“架构理解与可维护性”。真正应该优先关心的，是产品本身是否成熟、扩展点是否清晰、升级是否可控，而不是“我团队会不会写 PHP”。</p>
<p><strong>为什么不把语言当硬门槛</strong>：</p>
<table>
<thead>
<tr>
<th align="left">评估项</th>
<th align="left">Java CRM</th>
<th align="center">EspoCRM (PHP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">Java 开发者上手快，但 CRM 本身复杂</td>
<td align="center">PHP 语法简单，通常数天内可完成基本上手</td>
</tr>
<tr>
<td align="left"><strong>部署成本</strong></td>
<td align="left">JVM + 应用服务器，资源占用高</td>
<td align="center">传统 LAMP 堆栈，资源占用相对可控</td>
</tr>
<tr>
<td align="left"><strong>定制友好</strong></td>
<td align="left">框架厚重，改一行代码可能牵一发动全身</td>
<td align="center">元数据驱动，大部分定制只需改配置</td>
</tr>
<tr>
<td align="left"><strong>维护成本</strong></td>
<td align="left">依赖多，升级复杂</td>
<td align="center">依赖少，升级友好</td>
</tr>
</tbody></table>
<p><strong>核心决策</strong>：</p>
<blockquote>
<p><strong>“选产品本质，不是选语言。”</strong> 一个优秀的 PHP CRM，往往胜过一个不成熟的同类产品。</p>
</blockquote>
<p>实践中更稳妥的策略是：优先选成熟产品，再解决语言与工程体系的适配问题。</p>
<hr>
<h2 id="2-对比样本：Twenty-CRM-vs-EspoCRM-vs-OFBiz"><a href="#2-对比样本：Twenty-CRM-vs-EspoCRM-vs-OFBiz" class="headerlink" title="2. 对比样本：Twenty CRM vs EspoCRM vs OFBiz"></a>2. 对比样本：Twenty CRM vs EspoCRM vs OFBiz</h2><p>这里用三款代表性产品做样本：<strong>Twenty CRM</strong>（新兴现代）、<strong>EspoCRM</strong>（成熟稳定）、<strong>Apache OFBiz</strong>（企业级 Java 框架）。</p>
<h3 id="2-1-对比总览"><a href="#2-1-对比总览" class="headerlink" title="2.1 对比总览"></a>2.1 对比总览</h3><table>
<thead>
<tr>
<th align="left">产品</th>
<th align="left">技术栈</th>
<th align="center">成熟度</th>
<th align="left">定制难度</th>
<th align="left">部署复杂度</th>
<th align="center">最终选择</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>EspoCRM</strong></td>
<td align="left">PHP + MySQL + JS</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="left">⭐⭐ 容易</td>
<td align="left">⭐⭐ 简单</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="left">Twenty CRM</td>
<td align="left">React + NestJS + PG</td>
<td align="center">⭐⭐⭐</td>
<td align="left">⭐⭐ 容易</td>
<td align="left">⭐⭐⭐⭐ 复杂</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="left">Apache OFBiz</td>
<td align="left">Java + PostgreSQL</td>
<td align="center">⭐⭐⭐⭐</td>
<td align="left">⭐⭐⭐⭐ 困难</td>
<td align="left">⭐⭐⭐⭐⭐ 复杂</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<h3 id="2-2-Twenty-CRM：看起来很美，但太新"><a href="#2-2-Twenty-CRM：看起来很美，但太新" class="headerlink" title="2.2 Twenty CRM：看起来很美，但太新"></a>2.2 Twenty CRM：看起来很美，但太新</h3><p>Twenty CRM 是 2022 年启动的新项目，技术栈非常现代（React + NestJS + TypeScript），界面精美，架构设计优秀。</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">Twenty CRM</th>
<th align="left">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>技术栈</strong></td>
<td align="left">React + NestJS + PostgreSQL</td>
<td align="left">需要全栈 JS&#x2F;TS 能力</td>
</tr>
<tr>
<td align="left"><strong>成熟度</strong></td>
<td align="left">快速迭代中</td>
<td align="left">版本演进快，兼容性需要自己验证</td>
</tr>
<tr>
<td align="left"><strong>文档</strong></td>
<td align="left">英文为主，覆盖有限</td>
<td align="left">遇到问题难以找到答案</td>
</tr>
<tr>
<td align="left"><strong>社区</strong></td>
<td align="left">GitHub 活跃</td>
<td align="left">实际用户少</td>
</tr>
<tr>
<td align="left"><strong>功能完整性</strong></td>
<td align="left">核心功能齐全</td>
<td align="left">高级功能（报表、工作流）尚在开发</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：Twenty CRM 代表未来方向，值得持续关注。但当前阶段作为生产系统使用风险较大 —— 你不希望成为早期踩坑的用户。</p>
<h3 id="2-3-Apache-OFBiz：强大但笨重"><a href="#2-3-Apache-OFBiz：强大但笨重" class="headerlink" title="2.3 Apache OFBiz：强大但笨重"></a>2.3 Apache OFBiz：强大但笨重</h3><p>Apache OFBiz 是 Apache 基金会的企业级 ERP&#x2F;CRM 框架，功能极其强大，但学习曲线陡峭。</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">Apache OFBiz</th>
<th align="left">问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>技术栈</strong></td>
<td align="left">Java + PostgreSQL</td>
<td align="left">技术栈匹配 ✅</td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">ERP + CRM + 电商全都有</td>
<td align="left">功能过于庞大，用不上</td>
</tr>
<tr>
<td align="left"><strong>架构</strong></td>
<td align="left">组件化，高度可配置</td>
<td align="left">概念复杂，学习成本极高</td>
</tr>
<tr>
<td align="left"><strong>界面</strong></td>
<td align="left">传统企业风，可定制</td>
<td align="left">UI 现代化需要大量投入</td>
</tr>
<tr>
<td align="left"><strong>文档</strong></td>
<td align="left">官方文档详细</td>
<td align="left">文档组织混乱，新手迷失</td>
</tr>
<tr>
<td align="left"><strong>部署</strong></td>
<td align="left">JVM + Tomcat + 数据库</td>
<td align="left">资源占用高，运维复杂</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：OFBiz 适合大型企业的复杂 ERP 需求。对于只需要 CRM 的团队，杀鸡用牛刀，维护成本过高。</p>
<h3 id="2-4-EspoCRM：成熟稳定，定制友好"><a href="#2-4-EspoCRM：成熟稳定，定制友好" class="headerlink" title="2.4 EspoCRM：成熟稳定，定制友好"></a>2.4 EspoCRM：成熟稳定，定制友好</h3><p>EspoCRM 发布于 2014 年，经过 10+ 年发展，已经非常成熟。</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">EspoCRM</th>
<th align="left">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>技术栈</strong></td>
<td align="left">PHP + MySQL + JS</td>
<td align="left">PHP 简单，跨语言上手成本可控</td>
</tr>
<tr>
<td align="left"><strong>成熟度</strong></td>
<td align="left">10+ 年历史</td>
<td align="left">稳定可靠，破坏性更新少</td>
</tr>
<tr>
<td align="left"><strong>架构</strong></td>
<td align="left">元数据驱动 + 模块化</td>
<td align="left">大部分定制只需改配置文件</td>
</tr>
<tr>
<td align="left"><strong>文档</strong></td>
<td align="left">官方文档完善</td>
<td align="left">社区贡献多，问题能找到答案</td>
</tr>
<tr>
<td align="left"><strong>社区</strong></td>
<td align="left">GitHub 活跃，全球用户</td>
<td align="left">商业支持可选，社区免费支持也够用</td>
</tr>
<tr>
<td align="left"><strong>部署</strong></td>
<td align="left">传统 LAMP 堆栈</td>
<td align="left">部署路径清晰，运维成本可控</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：EspoCRM 在成熟度、定制友好性、运维成本之间达到了最佳平衡。</p>
<blockquote>
<p><strong>关于语言</strong>：EspoCRM 官方以英语为主，中文本地化相对弱。如果你的用户需要强中文支持，可能需要额外投入做本地化或维护语言包覆盖。</p>
</blockquote>
<h3 id="2-5-决策矩阵"><a href="#2-5-决策矩阵" class="headerlink" title="2.5 决策矩阵"></a>2.5 决策矩阵</h3><p>说明：下面的打分是基于本文开头的“非妥协需求”（可自托管、可深度定制、成本可控、可维护）以及我对三款产品的试用与资料调研做的主观评分。你在自己的 PoC 阶段，建议按业务关键流程重新打分，别照抄星星。</p>
<table>
<thead>
<tr>
<th align="left">评估维度</th>
<th align="center">Twenty CRM</th>
<th align="center">EspoCRM</th>
<th align="center">OFBiz</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>短期上线</strong></td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐</td>
</tr>
<tr>
<td align="left"><strong>长期维护</strong></td>
<td align="center">⭐⭐</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐⭐</td>
</tr>
<tr>
<td align="left"><strong>定制效率</strong></td>
<td align="center">⭐⭐</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐</td>
</tr>
<tr>
<td align="left"><strong>团队适应</strong></td>
<td align="center">⭐⭐⭐</td>
<td align="center">⭐⭐⭐</td>
<td align="center">⭐⭐⭐</td>
</tr>
<tr>
<td align="left"><strong>运维成本</strong></td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐</td>
</tr>
<tr>
<td align="left"><strong>风险可控</strong></td>
<td align="center">⭐⭐</td>
<td align="center">⭐⭐⭐⭐⭐</td>
<td align="center">⭐⭐⭐</td>
</tr>
</tbody></table>
<p><strong>最终选择：EspoCRM</strong></p>
<h3 id="2-6-其他常见开源-CRM（快速扫一眼）"><a href="#2-6-其他常见开源-CRM（快速扫一眼）" class="headerlink" title="2.6 其他常见开源 CRM（快速扫一眼）"></a>2.6 其他常见开源 CRM（快速扫一眼）</h3><p>如果你想把候选池拉大，下面这些名字几乎绕不开。这里不做结论，只给你“适合什么&#x2F;要注意什么”，方便你快速决定要不要纳入 PoC。</p>
<table>
<thead>
<tr>
<th align="left">产品</th>
<th align="left">适合什么</th>
<th align="left">要注意什么</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SuiteCRM</strong></td>
<td align="left">偏传统 CRM 形态、对“开源老牌生态”有偏好、能接受较传统的 UI</td>
<td align="left">定制与升级成本需要提前评估，别只看功能列表</td>
</tr>
<tr>
<td align="left"><strong>Vtiger</strong></td>
<td align="left">需要更“产品化”的现成能力、愿意考虑商业支持&#x2F;付费版路线</td>
<td align="left">开源版与商业版边界要看清楚，避免选到后期被能力卡死</td>
</tr>
<tr>
<td align="left"><strong>Dolibarr</strong></td>
<td align="left">更偏“轻量 ERP&#x2F;进销存 + CRM”的场景，小团队想一套系统覆盖更多模块</td>
<td align="left">CRM 深度可能不如专门 CRM，复杂销售流程要先做 PoC 验证</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-最终选择-EspoCRM-的关键理由"><a href="#3-最终选择-EspoCRM-的关键理由" class="headerlink" title="3. 最终选择 EspoCRM 的关键理由"></a>3. 最终选择 EspoCRM 的关键理由</h2><h3 id="3-1-代码质量与架构"><a href="#3-1-代码质量与架构" class="headerlink" title="3.1 代码质量与架构"></a>3.1 代码质量与架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优势：</span><br><span class="line">├── 元数据驱动：大部分定制只需改配置，不改代码</span><br><span class="line">├── 模块化架构：custom/ 目录隔离，可升级</span><br><span class="line">├── 清晰的扩展点：Formula → Dynamic Logic → Hook → Service</span><br><span class="line">├── RESTful API：完善的 API 设计，易于集成</span><br><span class="line">└── 前端技术栈稳定：Backbone.js + Handlebars，二次开发路径清晰</span><br></pre></td></tr></table></figure>

<h3 id="3-2-定制友好性"><a href="#3-2-定制友好性" class="headerlink" title="3.2 定制友好性"></a>3.2 定制友好性</h3><p>EspoCRM 对开发者非常友好：</p>
<ul>
<li><strong>元数据驱动</strong>：entityDefs、clientDefs、scopes 等配置文件控制大部分行为</li>
<li><strong>rebuild 机制</strong>：修改元数据后执行 rebuild，系统自动生成&#x2F;更新表结构</li>
<li><strong>模块隔离</strong>：<code>custom/Espo/Modules/</code> 下的改动不影响核心升级</li>
<li><strong>丰富的 Hook</strong>：BeforeSave、AfterSave、BeforeDelete 等拦截数据操作</li>
</ul>
<h3 id="3-3-社区与文档"><a href="#3-3-社区与文档" class="headerlink" title="3.3 社区与文档"></a>3.3 社区与文档</h3><ul>
<li><strong>GitHub 活跃</strong>：持续更新，issue 响应及时</li>
<li><strong>官方文档</strong>：涵盖开发、定制、API</li>
<li><strong>社区论坛</strong>：全球用户分享经验</li>
<li><strong>中文资源</strong>：国内有少量实践案例（正在增长）</li>
</ul>
<h3 id="3-4-部署与运维"><a href="#3-4-部署与运维" class="headerlink" title="3.4 部署与运维"></a>3.4 部署与运维</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  -e ESPOCRM_DATABASE_HOST=<span class="string">&quot;&lt;DB_HOST&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_DATABASE_USER=<span class="string">&quot;&lt;DB_USER&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_DATABASE_PASSWORD=<span class="string">&quot;&lt;DB_PASSWORD&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_ADMIN_USER=<span class="string">&quot;&lt;ADMIN_USER&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_ADMIN_PASSWORD=<span class="string">&quot;&lt;ADMIN_PASSWORD&gt;&quot;</span> \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  espocrm/espocrm</span><br></pre></td></tr></table></figure>

<ul>
<li>支持 Docker 部署</li>
<li>支持 PHP 8.2 - 8.4</li>
<li>支持 MySQL 8.0+ 或 MariaDB 10.3+（也支持 PostgreSQL 15+）</li>
<li>资源占用相对可控，小规模可从低配起步，按并发与数据量扩容</li>
</ul>
<hr>
<h2 id="4-EspoCRM-的局限与规避"><a href="#4-EspoCRM-的局限与规避" class="headerlink" title="4. EspoCRM 的局限与规避"></a>4. EspoCRM 的局限与规避</h2><h3 id="4-1-已知局限"><a href="#4-1-已知局限" class="headerlink" title="4.1 已知局限"></a>4.1 已知局限</h3><table>
<thead>
<tr>
<th align="left">局限</th>
<th align="left">说明</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>移动端较弱</strong></td>
<td align="left">移动版功能有限</td>
<td align="left">外勤多需要额外适配</td>
</tr>
<tr>
<td align="left"><strong>报表功能基础</strong></td>
<td align="left">内置报表较简单</td>
<td align="left">复杂报表需要二次开发</td>
</tr>
<tr>
<td align="left"><strong>中文本地化</strong></td>
<td align="left">官方中文支持有限</td>
<td align="left">需要自己翻译语言包</td>
</tr>
<tr>
<td align="left"><strong>高级功能付费</strong></td>
<td align="left">高级功能在付费版中</td>
<td align="left">如需某些功能需购买</td>
</tr>
<tr>
<td align="left"><strong>许可约束（AGPL）</strong></td>
<td align="left">以 AGPLv3 发布</td>
<td align="left">修改后供用户通过网络使用时需履行源码提供义务</td>
</tr>
</tbody></table>
<h3 id="4-2-规避方式"><a href="#4-2-规避方式" class="headerlink" title="4.2 规避方式"></a>4.2 规避方式</h3><p><strong>移动端弱</strong> → 使用响应式布局 + PWA，或对接移动端入口（企业 IM&#x2F;门户等）</p>
<p><strong>报表功能基础</strong> →：</p>
<ul>
<li>使用 BI 工具（Metabase、Superset）直连数据库</li>
<li>自定义 API 导出数据到 Excel&#x2F;BI 系统</li>
</ul>
<p><strong>高级功能付费</strong> →：</p>
<ul>
<li>大部分功能可以通过定制开发实现</li>
<li>本系列文章给出一套“开源版可落地”的扩展路径</li>
</ul>
<p><strong>许可约束（AGPL）</strong> →：</p>
<ul>
<li>在立项&#x2F;PoC 阶段明确：是否会修改源码（或形成衍生作品）、哪些用户会通过网络访问系统</li>
<li>若触发 AGPL 义务，预留源码提供与法律声明的交付路径；必要时评估商业许可或官方付费方案</li>
</ul>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h3 id="5-1-选择-EspoCRM-的核心原因"><a href="#5-1-选择-EspoCRM-的核心原因" class="headerlink" title="5.1 选择 EspoCRM 的核心原因"></a>5.1 选择 EspoCRM 的核心原因</h3><ol>
<li><strong>架构现代</strong>：元数据驱动 + 模块化，长期可维护</li>
<li><strong>定制友好</strong>：丰富的扩展点，开发效率高</li>
<li><strong>成本可控</strong>：开源免费，自托管无许可费</li>
<li><strong>社区活跃</strong>：持续更新，问题能找到答案</li>
<li><strong>部署简单</strong>：Docker 一键启动，运维成本低</li>
</ol>
<h3 id="5-2-适合人群"><a href="#5-2-适合人群" class="headerlink" title="5.2 适合人群"></a>5.2 适合人群</h3><p>EspoCRM 特别适合：</p>
<ul>
<li>✅ 有开发能力的团队（或可外包）</li>
<li>✅ 需要深度定制的业务场景</li>
<li>✅ 注重数据隐私，必须私有部署</li>
<li>✅ 预算有限，不想付高昂 SaaS 费用</li>
</ul>
<h3 id="5-3-不适合的情况"><a href="#5-3-不适合的情况" class="headerlink" title="5.3 不适合的情况"></a>5.3 不适合的情况</h3><ul>
<li>❌ 完全没有技术能力，也不想外包</li>
<li>❌ 需要开箱即用的复杂报表</li>
<li>❌ 对 UI&#x2F;UX 有极高要求（需要二次开发）</li>
</ul>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.espocrm.com/">EspoCRM</a></li>
<li><a href="https://twenty.com/">Twenty CRM</a></li>
<li><a href="https://ofbiz.apache.org/">Apache OFBiz</a></li>
</ul>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>CRM</tag>
        <tag>selection</tag>
        <tag>comparison</tag>
        <tag>open-source</tag>
      </tags>
  </entry>
  <entry>
    <title>EspoCRM定制篇总纲——扩展点选择、模块架构与工程化</title>
    <url>/2025/11/16/espocrm/01-upgrade-safe-customization-redlines/</url>
    <content><![CDATA[<blockquote>
<p>适用版本：EspoCRM 9.2.2+（开源版）</p>
</blockquote>
<p>你以为”能跑起来”就完了？真正的难点从你第一次升级开始。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>用”扩展点金字塔”选择最小侵入方案，能配置就不写代码</li>
<li>用”目录分区”隔离管理员配置与开发者代码，避免不可审计混乱</li>
<li>用”模块化架构”把改动锁在可控边界内</li>
<li>用”清单化部署+回滚”把风险降到可控</li>
</ul>
<hr>
<h2 id="1-扩展点金字塔"><a href="#1-扩展点金字塔" class="headerlink" title="1. 扩展点金字塔"></a>1. 扩展点金字塔</h2><h3 id="1-1-我们解决的不是”能不能改”，而是”能不能长期维护”"><a href="#1-1-我们解决的不是”能不能改”，而是”能不能长期维护”" class="headerlink" title="1.1 我们解决的不是”能不能改”，而是”能不能长期维护”"></a>1.1 我们解决的不是”能不能改”，而是”能不能长期维护”</h3><p>很多团队做 EspoCRM 定制，第一阶段靠”改得快”赢；第二阶段会被”不可升级、不可回滚、不可定位问题”拖垮。</p>
<p>这套系列文章的目标很明确：</p>
<ul>
<li>不讨论”改核心文件最快”的玩法，只讨论”升级后仍可活”的做法</li>
<li>不是展示技巧堆叠，而是给一套可复用的工程模板</li>
</ul>
<h3 id="1-2-选择扩展点的优先级（金字塔）"><a href="#1-2-选择扩展点的优先级（金字塔）" class="headerlink" title="1.2 选择扩展点的优先级（金字塔）"></a>1.2 选择扩展点的优先级（金字塔）</h3><p>我们的默认策略：<strong>能不写代码就不写代码</strong>，能用系统机制就不用自造轮子。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. Formula (优先)      - 简单计算和条件逻辑</span><br><span class="line">2. Dynamic Logic        - 界面显示与字段依赖</span><br><span class="line">3. Workflow / BPM       - 复杂业务流程（谨慎）</span><br><span class="line">4. Hook                 - 数据一致性保障（禁止复杂计算/HTTP/发信）</span><br><span class="line">5. Service / Controller - API 与复杂逻辑（最后手段）</span><br></pre></td></tr></table></figure>

<p>你会在后面几篇里看到同一个套路反复出现：<br>先用 Dynamic Logic 解决体验，再用 Hook&#x2F;Service 解决”绕过与一致性”。</p>
<h3 id="1-3-红线（违反就注定不可维护）"><a href="#1-3-红线（违反就注定不可维护）" class="headerlink" title="1.3 红线（违反就注定不可维护）"></a>1.3 红线（违反就注定不可维护）</h3><ul>
<li>不修改 <code>application/</code> 目录下任何文件（除非你准备永久自己维护一个 fork）</li>
<li>不在代码里硬编码环境信息（域名、容器名、数据库连接、密钥）</li>
<li>不把管理员配置和开发者代码混在同一套元数据文件里</li>
<li>不在 Hook 里做重逻辑（尤其是发邮件、复杂计算、HTTP 请求）</li>
<li>不绕过 ACL（任何”方便调试的后门”最终都会变成安全事故）</li>
</ul>
<hr>
<h2 id="2-模块化架构"><a href="#2-模块化架构" class="headerlink" title="2. 模块化架构"></a>2. 模块化架构</h2><h3 id="2-1-目录分区：开发者模块-vs-管理员配置区"><a href="#2-1-目录分区：开发者模块-vs-管理员配置区" class="headerlink" title="2.1 目录分区：开发者模块 vs 管理员配置区"></a>2.1 目录分区：开发者模块 vs 管理员配置区</h3><p>我们把”可升级”落到物理结构上：</p>
<ul>
<li>管理员（GUI）产生的配置：<code>custom/Espo/Custom/</code></li>
<li>开发者（代码）交付的模块：<code>custom/Espo/Modules/{ModuleName}/</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">custom/</span><br><span class="line">├── Espo/Custom/                    # 管理员配置区（GUI）</span><br><span class="line">│   └── Resources/metadata/</span><br><span class="line">└── Espo/Modules/&#123;ModuleName&#125;/      # 开发者模块区（代码）</span><br><span class="line">    ├── Controllers/</span><br><span class="line">    ├── Services/</span><br><span class="line">    ├── Hooks/</span><br><span class="line">    ├── Jobs/</span><br><span class="line">    └── Resources/</span><br><span class="line">        ├── metadata/</span><br><span class="line">        ├── routes.json</span><br><span class="line">        └── i18n/</span><br></pre></td></tr></table></figure>

<p><strong>为什么这么苛刻？</strong><br>因为管理员配置可变、不可审计，而开发者代码必须可审计、可回滚、可复现。混在一起，等于把两种生命周期掺成一锅粥。</p>
<h3 id="2-2-完整后端模块结构"><a href="#2-2-完整后端模块结构" class="headerlink" title="2.2 完整后端模块结构"></a>2.2 完整后端模块结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom/Espo/Modules/MyModule/</span><br><span class="line">├── Module.php                          # 模块定义类</span><br><span class="line">├── composer.json                       # 第三方依赖（可选）</span><br><span class="line">│</span><br><span class="line">├── Controllers/                        # API 控制器</span><br><span class="line">│   └── MyEntity.php</span><br><span class="line">│</span><br><span class="line">├── Services/                           # 业务逻辑服务层</span><br><span class="line">│   └── MyService.php</span><br><span class="line">│</span><br><span class="line">├── Hooks/                              # 数据钩子</span><br><span class="line">│   ├── MyEntity/</span><br><span class="line">│   │   └── BeforeSave.php</span><br><span class="line">│   └── AnotherEntity/</span><br><span class="line">│       └── AfterSave.php</span><br><span class="line">│</span><br><span class="line">├── Jobs/                               # 定时任务</span><br><span class="line">│   └── MyScheduledJob.php</span><br><span class="line">│</span><br><span class="line">├── Entities/                           # 实体类（可选）</span><br><span class="line">│   └── MyEntity.php</span><br><span class="line">│</span><br><span class="line">├── Repositories/                       # 数据仓库（可选）</span><br><span class="line">│   └── MyEntityRepository.php</span><br><span class="line">│</span><br><span class="line">└── Resources/                          # 元数据与配置</span><br><span class="line">    ├── metadata/</span><br><span class="line">    │   ├── entityDefs/                 # 实体定义</span><br><span class="line">    │   ├── clientDefs/                 # 前端定义</span><br><span class="line">    │   ├── scopes/                     # 权限作用域</span><br><span class="line">    │   ├── app/</span><br><span class="line">    │   │   ├── adminPanel.json        # 管理面板菜单</span><br><span class="line">    │   │   └── config.json            # 系统配置</span><br><span class="line">    │   └── routes.json                 # API 路由</span><br><span class="line">    │</span><br><span class="line">    ├── layouts/                         # 界面布局</span><br><span class="line">    │   └── MyEntity/</span><br><span class="line">    │       ├── list.json</span><br><span class="line">    │       ├── detail.json</span><br><span class="line">    │       ├── edit.json</span><br><span class="line">    │       └── create.json</span><br><span class="line">    │</span><br><span class="line">    └── i18n/                            # 语言包</span><br><span class="line">        └── en_US/</span><br><span class="line">            ├── Global.json</span><br><span class="line">            └── MyEntity.json</span><br></pre></td></tr></table></figure>

<h3 id="2-3-前端模块结构"><a href="#2-3-前端模块结构" class="headerlink" title="2.3 前端模块结构"></a>2.3 前端模块结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client/modules/my-module/</span><br><span class="line">└── src/</span><br><span class="line">    ├── views/                           # 自定义视图</span><br><span class="line">    │   └── my-entity/</span><br><span class="line">    │       ├── detail.js</span><br><span class="line">    │       ├── edit.js</span><br><span class="line">    │       └── list.js</span><br><span class="line">    ├── fields/                          # 自定义字段类型</span><br><span class="line">    │   └── my-field-type.js</span><br><span class="line">    └── templates/                       # Handlebars 模板（可选）</span><br><span class="line">        └── my-template.tpl</span><br></pre></td></tr></table></figure>

<h3 id="2-4-管理员配置区（开发者不要动）"><a href="#2-4-管理员配置区（开发者不要动）" class="headerlink" title="2.4 管理员配置区（开发者不要动）"></a>2.4 管理员配置区（开发者不要动）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom/Espo/Custom/</span><br><span class="line">└── Resources/</span><br><span class="line">    └── metadata/                        # 管理员通过 GUI 添加的配置</span><br><span class="line">        ├── entityDefs/</span><br><span class="line">        ├── clientDefs/</span><br><span class="line">        └── scopes/</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-各层职责分工"><a href="#3-各层职责分工" class="headerlink" title="3. 各层职责分工"></a>3. 各层职责分工</h2><h3 id="3-1-Controller：API-入口"><a href="#3-1-Controller：API-入口" class="headerlink" title="3.1 Controller：API 入口"></a>3.1 Controller：API 入口</h3><p><strong>职责</strong>：</p>
<ul>
<li>处理 HTTP 请求</li>
<li>权限检查（ACL）</li>
<li>调用 Service 处理业务逻辑</li>
<li>返回 JSON 响应</li>
</ul>
<p><strong>示例骨架</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Controllers</span>\<span class="title">Record</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">BadRequest</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">Forbidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> <span class="keyword">extends</span> <span class="title">Record</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionMyAction</span>(<span class="params"><span class="variable">$params</span>, <span class="variable">$data</span>, <span class="variable">$request</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 权限检查</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getUser</span>()-&gt;<span class="title function_ invoke__">isAdmin</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Forbidden</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数验证</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>-&gt;param)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequest</span>(<span class="string">&quot;param is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Service</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getContainer</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;MyService&#x27;</span>)-&gt;<span class="title function_ invoke__">doSomething</span>(<span class="variable">$data</span>-&gt;param);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Service：业务逻辑层"><a href="#3-2-Service：业务逻辑层" class="headerlink" title="3.2 Service：业务逻辑层"></a>3.2 Service：业务逻辑层</h3><p><strong>职责</strong>：</p>
<ul>
<li>复杂业务逻辑</li>
<li>跨实体操作</li>
<li>数据计算与转换</li>
<li>调用外部 API</li>
</ul>
<p><strong>示例骨架</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Services</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">ORM</span>\<span class="title">EntityManager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Config</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Config <span class="variable">$config</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$param</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&quot;MyService::doSomething started with param: <span class="subst">&#123;$param&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">processData</span>(<span class="variable">$param</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&quot;MyService::doSomething completed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$param</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Hook：数据一致性保障"><a href="#3-3-Hook：数据一致性保障" class="headerlink" title="3.3 Hook：数据一致性保障"></a>3.3 Hook：数据一致性保障</h3><p><strong>职责</strong>：</p>
<ul>
<li>数据保存前的校验&#x2F;补充（BeforeSave）</li>
<li>数据保存后的联动（AfterSave）</li>
<li>数据删除前的检查（BeforeDelete）</li>
</ul>
<p><strong>原则</strong>：</p>
<ul>
<li>只做轻逻辑判断</li>
<li>不发邮件、不做 HTTP 请求</li>
<li>不做复杂计算</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Hooks</span>\<span class="title class_">MyEntity</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">ORM</span>\<span class="title">Entity</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">BadRequest</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeforeSave</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeSave</span>(<span class="params">Entity <span class="variable">$entity</span>, <span class="keyword">array</span> <span class="variable">$options</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;status&#x27;</span>) === <span class="string">&#x27;Closed&#x27;</span> &amp;&amp; !<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;closedReason&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequest</span>(<span class="string">&quot;closedReason is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据补充</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">isNew</span>()) &#123;</span><br><span class="line">            <span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;assignedUserId&#x27;</span>, <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">getUser</span>()-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Job：定时后台任务"><a href="#3-4-Job：定时后台任务" class="headerlink" title="3.4 Job：定时后台任务"></a>3.4 Job：定时后台任务</h3><p><strong>职责</strong>：</p>
<ul>
<li>定时触发</li>
<li>批量数据处理</li>
<li>发送通知&#x2F;邮件</li>
<li>定期数据同步</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Jobs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Job</span>\<span class="title">JobDataLess</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">ORM</span>\<span class="title">EntityManager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScheduledJob</span> <span class="keyword">implements</span> <span class="title">JobDataLess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;MyScheduledJob started&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时任务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;MyScheduledJob completed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-rebuild-与-clear-cache"><a href="#4-rebuild-与-clear-cache" class="headerlink" title="4. rebuild 与 clear-cache"></a>4. rebuild 与 clear-cache</h2><h3 id="4-1-把”生效机制”当成工程事实"><a href="#4-1-把”生效机制”当成工程事实" class="headerlink" title="4.1 把”生效机制”当成工程事实"></a>4.1 把”生效机制”当成工程事实</h3><p>你在 EspoCRM 里改了元数据、前端视图映射、语言包、布局之后，最常见的错误不是”写错代码”，而是”你以为改了就生效”。</p>
<p>建议把下面清单当作工程制度，而不是”记得就做”：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">必须</th>
</tr>
</thead>
<tbody><tr>
<td align="left">改 metadata（entityDefs &#x2F; clientDefs &#x2F; scopes &#x2F; routes &#x2F; app）</td>
<td align="left">rebuild</td>
</tr>
<tr>
<td align="left">改前端视图或模板</td>
<td align="left">clear-cache + 浏览器强刷</td>
</tr>
<tr>
<td align="left">改语言包</td>
<td align="left">rebuild</td>
</tr>
</tbody></table>
<h3 id="4-2-执行方式"><a href="#4-2-执行方式" class="headerlink" title="4.2 执行方式"></a>4.2 执行方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php clear-cache</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-部署与回滚"><a href="#5-部署与回滚" class="headerlink" title="5. 部署与回滚"></a>5. 部署与回滚</h2><h3 id="5-1-容器化部署架构说明"><a href="#5-1-容器化部署架构说明" class="headerlink" title="5.1 容器化部署架构说明"></a>5.1 容器化部署架构说明</h3><pre class="mermaid">graph TD
    subgraph Client [用户客户端]
        A[Web 浏览器 / 移动端]
    end

    subgraph Docker_Environment [Docker  环境]
        direction LR
        subgraph EspoCRM_Monolith [EspoCRM 核心应用容器 Container]
            C[Web Server : Nginx] --> D[PHP-FPM / EspoCRM Code]
            D --> E[Cron Scheduler :Background Tasks]
        end

        Fsys[Filesystem Volume :持久化挂载]
    end

    subgraph External_Managed_Services [容器外公共托管服务]
        G[Database :MySQL/ RDS]
        H[Cache/Queue :Redis]
        J[Identity Provider :Azure AD / LDAP]
        K[Email Services :SMTP/IMAP]
        L[AWS S3 :用户文件存储]
    end

    A -->|HTTPS/HTTP| C

    D -->|SQL| G
    D -->|Read/Write Logs| Fsys
    D -->|S3 API / Uploaded Files| L

    D -.->|API/Protocol| H
    D -->|OIDC/SAML| J
    D -->|SMTP/IMAP| K

    E -->|Background Tasks| D
    E -->|Data Access| G

    style EspoCRM_Monolith fill:#FFF7E0,stroke:#333
    style Docker_Environment fill:#E0FFEE,stroke:#333
    style External_Managed_Services fill:#F0E6FF,stroke:#333</pre>

<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">部署位置</th>
<th align="left">运维职责</th>
<th align="left">依赖关系</th>
<th align="left">备注（起步阶段）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Web Server &#x2F; PHP-FPM &#x2F; EspoCRM Code</td>
<td align="left">Docker Container（容器内部）</td>
<td align="left">开发团队负责构建和维护单一应用镜像</td>
<td align="left">接收 Client 流量，连接外部服务（DB&#x2F;IDP&#x2F;Email）</td>
<td align="left">核心组件，包含全部定制代码</td>
</tr>
<tr>
<td align="left">Cron Scheduler</td>
<td align="left">Docker Container（容器内部）</td>
<td align="left">开发团队负责运行</td>
<td align="left">依赖 PHP（执行任务）；访问 Database（获取任务数据）</td>
<td align="left">核心组件，必须定期运行</td>
</tr>
<tr>
<td align="left">Filesystem Volume</td>
<td align="left">容器外部持久化卷（Volume）</td>
<td align="left">运维团队负责管理与备份</td>
<td align="left">供 PHP 读写代码&#x2F;配置与用户上传文件（<code>data/upload/</code>）</td>
<td align="left">关键依赖，确保 PV 备份</td>
</tr>
<tr>
<td align="left">Database（MySQL&#x2F;PostgreSQL）</td>
<td align="left">容器外公共服务（Managed Service）</td>
<td align="left">外部服务商管理（如 RDS）</td>
<td align="left">被 PHP 与 Cron 访问，存储业务数据与元数据</td>
<td align="left">必须依赖</td>
</tr>
<tr>
<td align="left">Identity Provider（Azure AD&#x2F;LDAP）</td>
<td align="left">容器外公共服务</td>
<td align="left">外部服务商管理</td>
<td align="left">被 PHP 通过 OIDC&#x2F;SAML 用于 SSO</td>
<td align="left">必须依赖</td>
</tr>
<tr>
<td align="left">Email Services（SMTP&#x2F;IMAP）</td>
<td align="left">容器外公共服务</td>
<td align="left">外部服务商管理</td>
<td align="left">被 PHP 用于邮件发送与接收</td>
<td align="left">必须依赖（实现邮件功能）</td>
</tr>
<tr>
<td align="left">AWS S3</td>
<td align="left">容器外公共服务</td>
<td align="left">外部服务商管理</td>
<td align="left">用户文件存储</td>
<td align="left">必须依赖</td>
</tr>
<tr>
<td align="left">Cache &amp; Search Engine</td>
<td align="left">暂时不用（使用内部回退机制）</td>
<td align="left">暂无独立运维职责</td>
<td align="left">内部 PHP 使用文件系统或数据库做缓存&#x2F;搜索</td>
<td align="left">现阶段可省略，用户增长后升级</td>
</tr>
</tbody></table>
<h3 id="5-2-逐文件拷贝原则"><a href="#5-2-逐文件拷贝原则" class="headerlink" title="5.2 逐文件拷贝原则"></a>5.2 逐文件拷贝原则</h3><p><strong>禁止</strong>：目录拷贝（不要把整个 <code>custom/</code> 目录一次性扔进容器）</p>
<p><strong>正确</strong>：逐文件拷贝</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ✅ 正确：逐文件拷贝，可审计</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">cp</span> Module.php <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Module.php</span><br><span class="line">docker <span class="built_in">cp</span> MyEntity.json <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json</span><br><span class="line"><span class="comment"># ... 逐个文件</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-部署检查清单"><a href="#5-3-部署检查清单" class="headerlink" title="5.3 部署检查清单"></a>5.3 部署检查清单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件部署</span><br><span class="line">├── [ ] 所有 .php 文件已拷贝</span><br><span class="line">├── [ ] 所有 .json 元数据文件已拷贝</span><br><span class="line">├── [ ] 所有 .js 前端文件已拷贝</span><br><span class="line">└── [ ] 所有 .tpl 模板文件已拷贝</span><br><span class="line"></span><br><span class="line">系统重建</span><br><span class="line">├── [ ] rebuild 已执行</span><br><span class="line">├── [ ] clear-cache 已执行</span><br><span class="line">└── [ ] 浏览器缓存已清空</span><br><span class="line"></span><br><span class="line">功能验证</span><br><span class="line">├── [ ] 新菜单项显示</span><br><span class="line">├── [ ] 新实体可创建/编辑</span><br><span class="line">├── [ ] 新 API 端点可访问</span><br><span class="line">├── [ ] ACL 权限正确</span><br><span class="line">└── [ ] 日志无错误</span><br><span class="line"></span><br><span class="line">备份确认</span><br><span class="line">├── [ ] 管理员配置已备份</span><br><span class="line">└── [ ] 数据库已备份</span><br></pre></td></tr></table></figure>

<h3 id="5-4-回滚策略"><a href="#5-4-回滚策略" class="headerlink" title="5.4 回滚策略"></a>5.4 回滚策略</h3><p><strong>代码回滚</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1) 在宿主机源码里回滚到上一个可用版本（示例：Git）</span></span><br><span class="line">git checkout &lt;last-good-tag-or-commit&gt; -- custom/Espo/Modules/MyModule/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 按“逐文件拷贝”重新部署到容器</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">cp</span> custom/Espo/Modules/MyModule/Module.php \</span><br><span class="line">  <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Module.php</span><br><span class="line">docker <span class="built_in">cp</span> custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json \</span><br><span class="line">  <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) rebuild 生效</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br></pre></td></tr></table></figure>

<p><strong>数据回滚</strong>：</p>
<p>结论：不要指望 rebuild 自动“回收”数据库结构。</p>
<ul>
<li>默认 rebuild（soft）只会创建&#x2F;变更需要的表、列、索引；不会 drop 表，也不会 drop 列</li>
<li>hard rebuild 可能会 drop 未使用的列、缩短超长列长度，但仍不会 drop 表，且有数据丢失风险</li>
</ul>
<p>推荐回滚策略：</p>
<ol>
<li>回滚前先备份数据库（至少 schema + 相关业务表数据）</li>
<li>回滚代码与元数据后执行 rebuild，让缓存与元数据状态一致</li>
<li>对“新增表&#x2F;中间表&#x2F;索引”的清理，采用显式的反向 SQL（DROP TABLE&#x2F;INDEX），并在测试库验证后再执行到生产</li>
<li>对“新增列&#x2F;字段”的回滚，优先走“弃用而非删除”：保留列与数据，仅从界面与业务逻辑中移除；确需删除时使用 hard rebuild 或反向 SQL，并明确数据保留&#x2F;迁移方案</li>
</ol>
<h3 id="5-5-管理员配置备份"><a href="#5-5-管理员配置备份" class="headerlink" title="5.5 管理员配置备份"></a>5.5 管理员配置备份</h3><p>开发者代码在 Git 中有版本控制，但管理员配置（<code>custom/Espo/Custom/</code>）不在任何版本控制系统里。<strong>系统崩溃时，管理员配置会丢失</strong>。</p>
<p><strong>问题本质</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发者代码：Git 版本控制 → 随时恢复 ✅</span><br><span class="line">管理员配置：无版本控制 → 系统崩 = 配置丢 ❌</span><br></pre></td></tr></table></figure>

<p><strong>推荐方案：定时备份脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># backup-admin-config.sh</span></span><br><span class="line"></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/backup/espocrm/admin-config&quot;</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份管理员配置（打包成单文件，只拷贝单个归档文件）</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>&quot;</span></span><br><span class="line">TMP_FILE=<span class="string">&quot;/tmp/Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> tar -czf <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> -C /var/www/html custom/Espo/Custom</span><br><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:<span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>/Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留最近 30 天的备份</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>&quot;</span> -name <span class="string">&quot;Custom_*.tar.gz&quot;</span> -mtime +30 -delete</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Admin config backed up: Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置 cron 每天自动执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 crontab</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每天凌晨 2 点执行</span></span><br><span class="line">0 2 * * * /path/to/backup-admin-config.sh &gt;&gt; /var/log/espocrm-backup.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><strong>恢复流程</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复管理员配置（选择备份日期，会覆盖现有 Custom 配置）</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">BACKUP_FILE=<span class="string">&quot;/backup/espocrm/admin-config/Custom_20251227_020000.tar.gz&quot;</span></span><br><span class="line">TMP_FILE=<span class="string">&quot;/tmp/Custom_restore.tar.gz&quot;</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$BACKUP_FILE</span>&quot;</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:<span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> tar -xzf <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> -C /var/www/html</span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><h3 id="6-1-一套可复用的工程模板"><a href="#6-1-一套可复用的工程模板" class="headerlink" title="6.1 一套可复用的工程模板"></a>6.1 一套可复用的工程模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个需求按同一模板交付：</span><br><span class="line"></span><br><span class="line">├── 需求与验收标准</span><br><span class="line">├── 扩展点选择与理由</span><br><span class="line">├── 技术设计与数据流</span><br><span class="line">├── 代码实现（模块边界内）</span><br><span class="line">├── 测试（UI + API + 边界）</span><br><span class="line">├── 部署脚本（逐文件拷贝）</span><br><span class="line">└── 回滚策略</span><br></pre></td></tr></table></figure>

<h3 id="6-2-最终建议"><a href="#6-2-最终建议" class="headerlink" title="6.2 最终建议"></a>6.2 最终建议</h3><ol>
<li><strong>能配置就不写代码</strong> —— 用好 Formula、Dynamic Logic</li>
<li><strong>能扩展就不重写</strong> —— 默认看板能扩展就别完全重写</li>
<li><strong>改动锁在模块内</strong> —— 不改 <code>application/</code> 目录</li>
<li><strong>rebuild 是纪律</strong> —— 改元数据必须 rebuild</li>
</ol>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>customization</tag>
        <tag>upgrade-safe</tag>
        <tag>module-architecture</tag>
        <tag>deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务实现</title>
    <url>/2018/05/22/distributed-transaction/</url>
    <content><![CDATA[<p>在分布式系统中，同时满足“CAP定律”中的“一致性”、“可用性”和“分区容错性”三者是不可能的。在互联网领域的绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。<span id="more"></span></p>
<h3 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h3><p>XA规范主要定义了事务管理器(Transaction Manager)和资源管理器(Resource Manager)之间的接口. XA引入事务管理器是因为在分布式系统中，从理论上讲两台机器上无法达到一致的状态，需要引入一个外部点进行协调。事务管理器控制着全局事务，管理事务生命周期，并协调资源, 资源管理器负责控制和管理实际资源 。XA是一个两阶段提交协议，该协议分为以下两个阶段：</p>
<ol>
<li>事务协调器要求每个涉及到事务的数据库预提交，并反映是否可以提交 。</li>
<li>事务协调器要求每个数据库提交数据 。</li>
</ol>
<p>如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息 。</p>
<h3 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h3><p>JTA作为JAVA平台上的事务规范，同时定义了对XA事务的支持；在JTA中，事务管理器抽象为javax.transaction.TransactionManager接口，通过底层事务服务（即JTS）实现,JTA仅仅定义了接口，具体的实现则是由供应商(如J2EE厂商)负责提供，目前JTA的实现主要由J2EE容器所提供的JTA实现(如JBOSS)和独立的JTA实现(如JOTM，Atomikos)。</p>
<blockquote>
<p>JTA本质上是两阶段提交，实现复杂，牺牲了可用性，对性能影响较大, 适合对数据强一致(<strong>其实也不能100%保证强一致</strong>)要求很高的关键领域; 大部分互联网业务都不会采用两阶段提交的方式 。</p>
</blockquote>
<h3 id="链式事务管理"><a href="#链式事务管理" class="headerlink" title="链式事务管理"></a>链式事务管理</h3><p>这种方式也Spring提供的，可以将两个或多个数据库资源的事务串联到一起，公用一个TransactionManager来实现对多个资源的事务。配置方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.data.transaction.ChainedTransactionManager&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;transactionManagers&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean</span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource1&quot; /&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">      &lt;bean</span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource2&quot; /&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> &lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>针对多个数据库实现事务。使用这种方式时，在Spring事务提交的时候，它会依次调用里面的多个dataSource的commit()方法，如果业务方法出错，就会按照相反的顺序调用rollback()方法。这种方法可能会出现先前的提交成功，之后的提交失败，所以还是会有事务失败的可能。</p>
<blockquote>
<p>实现简单，但可能会出现先前的提交成功，之后的提交失败，所以还是会有事务失败的可能</p>
</blockquote>
<h3 id="最大努力一次提交-Best-Efforts-1PC"><a href="#最大努力一次提交-Best-Efforts-1PC" class="headerlink" title="最大努力一次提交(Best Efforts 1PC)"></a>最大努力一次提交(Best Efforts 1PC)</h3><p>在一个系统中使用数据库和带事务功能的消息中间件，业务流程如下</p>
<ol>
<li>开始消息事务</li>
<li>发送消息</li>
<li>开始数据库事务</li>
<li>更新数据库</li>
<li>提交数据库事务</li>
<li>提交消息事务</li>
</ol>
<p>有两个事务，分别是DB的和JMS的事务，事务的开启和提交都是相互独立的。依次提交这两个事务，只要第二个事务顺利提交，整个方法就能够保证数据的一致性。实际上，在绝大多数情况下，只要数据库和MQ能够正常访问，这也确实能够保证。所以，这种方式就叫’最大努力’一次提交。</p>
<p>使用这种方式，事物提交的顺序是非常重要的。假设在提交messaging transaction的时候发生错误，这时数据库的事务已经提交，无法回滚，但是消息的事务被回滚，那么这一条消息会被重新放回队列中，该业务方法会被再次触发，再次在一个新的事务中处理。但是，这时数据的处理已经完成，只是最后JMS的事物提交出错，那么就需要通过防止重复提交的方式，来避免数据库的再次处理。</p>
<h3 id="事务补偿型-TCC型事务–Try-Confirm-Cancel"><a href="#事务补偿型-TCC型事务–Try-Confirm-Cancel" class="headerlink" title="事务补偿型(TCC型事务–Try&#x2F;Confirm&#x2F;Cancel)"></a>事务补偿型(TCC型事务–Try&#x2F;Confirm&#x2F;Cancel)</h3><p>其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的, 即：只要Try成功，Confirm一定成功</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放</li>
</ul>
<p>在一个长事务，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B所处理时间可能比较长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个<strong>补偿</strong>操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的事务模型，是牺牲了一定的隔离性和一致性的，但是提高了事务的可用性。</p>
<blockquote>
<p>与两阶段提交相比实现及流程相对简单，但应用层要写很多补偿代码(而且补偿也不能保证一定成功)</p>
</blockquote>
<h3 id="本地流水表实现最终一致性"><a href="#本地流水表实现最终一致性" class="headerlink" title="本地流水表实现最终一致性"></a>本地流水表实现最终一致性</h3><p>以电商下单场景为例，主要涉及到两个操作，<strong>扣减库存</strong>和<strong>生成订单</strong>,因为两个操作在不同的数据库，无法保证强一致性,可以通过本地流水表来实现最终一致性 ， 具体流程如下:</p>
<ul>
<li>生成交易操作唯一标示token</li>
<li>事务一(库存系统): <ul>
<li>冻结库存</li>
<li>根据下单流水号生成商品的库存冻结记录,冻结记录主要包括<strong>skuId</strong>,<strong>token</strong>,<strong>冻结数量</strong>,<strong>状态</strong> .状态有3种状态: <strong>已冻结</strong>，<strong>下单成功扣减</strong>，<strong>下单失败释放</strong>,初始状态为已冻结</li>
</ul>
</li>
<li>如果事务一失败，直接返回；如果成功进入事务二 </li>
<li>事务二(订单系统, 本地事务)：根据token生成订单,订单的状态主要包括：<strong>未支付</strong>,<strong>已支付</strong>,<strong>超时未支付</strong>,订单的初始状态为<strong>未支付</strong></li>
<li>事务二如果成功，则进行后续的流程,</li>
<li>事务二如果失败，调用库存系统的回滚接口，返回下单失败;</li>
<li>定时任务: 因为存在<strong>事务一成功</strong>而<strong>事务二</strong>失败的情况，这样会冻结商品的部分库存，所以可以捞取出创建超过一定时间状态为<strong>已冻结</strong>的所有冻结记录，根据每个冻结记录的token去订单表查询，若不存在对应的订单，则将冻结记录的状态更新为<strong>下单失败释放</strong>，并回滚商品库存数量</li>
</ul>
<h3 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h3><p>将一些有同步的事务操作变为异步操作，避免对数据库事务的争用；继续以以电商下单场景为例，支付成功后增加用户积分；</p>
<ul>
<li>事务一(订单系统)，订单状态修改为支付成功，发送支付成功消息</li>
<li>事务二(用户系统)，用户系统接到支付成功消息后，增加用户积分</li>
</ul>
<h3 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h3><p>一些第支持事务消息MQ，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，其思路大致为：</p>
<ul>
<li>第一阶段Prepared消息，会拿到消息的地址。</li>
<li>第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。</li>
</ul>
<p>在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，是回滚还是继续发送确认消息。这样就保证了消息发送保证与本地事务同时成功或同时失败 </p>
<h3 id="分布式事务实现的原则"><a href="#分布式事务实现的原则" class="headerlink" title="分布式事务实现的原则"></a>分布式事务实现的原则</h3><ul>
<li>大事务拆成小事务，每个小事务都是单机上的事务</li>
<li>补偿 + 重试， 业务上设计补偿机制，而且保证补偿失败后有重试机制</li>
<li>幂等, 保证每次事务操作是幂等的，保证幂等的方式可以采用：<ul>
<li>状态值，每次写操作的时候检查状态值</li>
<li>唯一标示，每次写操作都带入业务唯一标示</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
        <tag>一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>EspoCRM定制篇外部集成——Outlook双向同步实战</title>
    <url>/2025/11/22/espocrm/02-external-integration/</url>
    <content><![CDATA[<blockquote>
<p>适用版本：EspoCRM 9.2.2+</p>
</blockquote>
<p>外部集成的难点不是”调通 API”，而是”长期稳定运行”。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>OAuth 2.0 实现 EspoCRM 与外部系统的安全连接</li>
<li>增量同步用 deltaLink&#x2F;skipToken 机制，避免全量拉取</li>
<li>Token 失效有恢复策略，同步失败不中断服务</li>
<li>关键判断打英文日志，保证线上可定位</li>
</ul>
<hr>
<h2 id="1-集成场景概述"><a href="#1-集成场景概述" class="headerlink" title="1. 集成场景概述"></a>1. 集成场景概述</h2><h3 id="1-1-常见集成类型"><a href="#1-1-常见集成类型" class="headerlink" title="1.1 常见集成类型"></a>1.1 常见集成类型</h3><table>
<thead>
<tr>
<th align="left">集成类型</th>
<th align="left">典型场景</th>
<th align="left">同步方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">日历同步</td>
<td align="left">Outlook&#x2F;Google Calendar</td>
<td align="left">双向</td>
</tr>
<tr>
<td align="left">联系人同步</td>
<td align="left">Outlook&#x2F;Google Contacts</td>
<td align="left">双向</td>
</tr>
<tr>
<td align="left">邮件集成</td>
<td align="left">SMTP&#x2F;IMAP</td>
<td align="left">单向（到 EspoCRM）</td>
</tr>
<tr>
<td align="left">数据同步</td>
<td align="left">ERP&#x2F;财务系统</td>
<td align="left">双向</td>
</tr>
<tr>
<td align="left">Webhook</td>
<td align="left">第三方通知</td>
<td align="left">单向（到 EspoCRM）</td>
</tr>
</tbody></table>
<h3 id="1-2-日历同步的核心挑战"><a href="#1-2-日历同步的核心挑战" class="headerlink" title="1.2 日历同步的核心挑战"></a>1.2 日历同步的核心挑战</h3><ul>
<li><strong>增量同步</strong>：只拉取变更数据，避免全量拉取的性能开销</li>
<li><strong>Token 管理</strong>：访问令牌会过期，需要自动刷新</li>
<li><strong>错误恢复</strong>：网络中断、Token 失效后的恢复机制</li>
<li><strong>数据一致性</strong>：双向同步时的冲突处理</li>
</ul>
<hr>
<h2 id="2-OAuth-认证流程"><a href="#2-OAuth-认证流程" class="headerlink" title="2. OAuth 认证流程"></a>2. OAuth 认证流程</h2><h3 id="2-1-OAuth-2-0-基本流程"><a href="#2-1-OAuth-2-0-基本流程" class="headerlink" title="2.1 OAuth 2.0 基本流程"></a>2.1 OAuth 2.0 基本流程</h3><pre class="mermaid">flowchart LR
  A[用户点击连接] --> B[跳转到 Microsoft 授权页]
  B --> C[用户同意授权]
  C --> D[回调到 EspoCRM 带 code]
  D --> E[用 code 换 access_token]
  E --> F[保存 token 到 external_account]
  F --> G[开始同步数据]</pre>

<h3 id="2-2-EspoCRM-中的-External-Account-机制"><a href="#2-2-EspoCRM-中的-External-Account-机制" class="headerlink" title="2.2 EspoCRM 中的 External Account 机制"></a>2.2 EspoCRM 中的 External Account 机制</h3><p>EspoCRM 提供了 <code>external_account</code> 实体来存储第三方系统的认证信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;integration&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Outlook&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;accessToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;ACCESS_TOKEN&gt;&quot;</span><span class="punctuation">,</span>  <span class="comment">// 访问令牌</span></span><br><span class="line">  <span class="attr">&quot;refreshToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;REFRESH_TOKEN&gt;&quot;</span><span class="punctuation">,</span>    <span class="comment">// 刷新令牌</span></span><br><span class="line">  <span class="attr">&quot;expiresAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-08-27 10:00:00&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Token-刷新机制"><a href="#2-3-Token-刷新机制" class="headerlink" title="2.3 Token 刷新机制"></a>2.3 Token 刷新机制</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$token</span>-&gt;<span class="title function_ invoke__">isExpired</span>()) &#123;</span><br><span class="line">    <span class="variable">$newToken</span> = <span class="variable language_">$this</span>-&gt;oauthHelper-&gt;<span class="title function_ invoke__">refresh</span>(<span class="variable">$token</span>-&gt;<span class="title function_ invoke__">getRefreshToken</span>());</span><br><span class="line">    <span class="variable">$externalAccount</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;accessToken&#x27;</span>, <span class="variable">$newToken</span>-&gt;access_token);</span><br><span class="line">    <span class="variable">$externalAccount</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;refreshToken&#x27;</span>, <span class="variable">$newToken</span>-&gt;refresh_token);</span><br><span class="line">    <span class="variable">$externalAccount</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;expiresAt&#x27;</span>, <span class="variable">$newToken</span>-&gt;expires_at);</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;entityManager-&gt;<span class="title function_ invoke__">saveEntity</span>(<span class="variable">$externalAccount</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-增量同步实现"><a href="#3-增量同步实现" class="headerlink" title="3. 增量同步实现"></a>3. 增量同步实现</h2><h3 id="3-1-为什么需要增量同步"><a href="#3-1-为什么需要增量同步" class="headerlink" title="3.1 为什么需要增量同步"></a>3.1 为什么需要增量同步</h3><p>全量拉取的问题：</p>
<ul>
<li>每次拉取所有事件，数据量大时性能差</li>
<li>浪费 API 配额</li>
<li>同步时间长，用户体验差</li>
</ul>
<p><strong>增量同步</strong>：只拉取有变化的记录。</p>
<h3 id="3-2-Microsoft-Graph-API-的-Delta-机制"><a href="#3-2-Microsoft-Graph-API-的-Delta-机制" class="headerlink" title="3.2 Microsoft Graph API 的 Delta 机制"></a>3.2 Microsoft Graph API 的 Delta 机制</h3><pre class="mermaid">stateDiagram-v2
    [*] --> 初始同步
    初始同步 --> 分页中: 收到@odata.nextLink
    分页中 --> 分页中: 继续下一页
    分页中 --> 增量同步: 收到@odata.deltaLink
    增量同步 --> 增量同步: 使用deltaToken
    增量同步 --> 错误恢复: Token过期
    错误恢复 --> 初始同步: 重新开始</pre>

<h3 id="3-3-Delta-Token-管理"><a href="#3-3-Delta-Token-管理" class="headerlink" title="3.3 Delta Token 管理"></a>3.3 Delta Token 管理</h3><p><strong>响应格式</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@odata.context&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AAMkAG...&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;会议1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;@removed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;deleted&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AAMkAG...&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;会议2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@odata.nextLink&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://graph.microsoft.com/...?skipToken=xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  <span class="attr">&quot;@odata.deltaLink&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://graph.microsoft.com/...?deltaToken=xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>存储策略</strong>：</p>
<table>
<thead>
<tr>
<th align="left">Token</th>
<th align="left">存储位置</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">deltaToken</td>
<td align="left">outlook_calendar_user.delta_token</td>
<td align="left">下次增量同步的起点</td>
</tr>
<tr>
<td align="left">skipToken</td>
<td align="left">outlook_calendar_user.skip_token</td>
<td align="left">分页继续的标记</td>
</tr>
</tbody></table>
<h3 id="3-4-同步逻辑骨架"><a href="#3-4-同步逻辑骨架" class="headerlink" title="3.4 同步逻辑骨架"></a>3.4 同步逻辑骨架</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">syncCalendar</span>(<span class="params">OutlookCalendarUser <span class="variable">$calendarUser</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$deltaToken</span> = <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;deltaToken&#x27;</span>);</span><br><span class="line">    <span class="variable">$skipToken</span> = <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;skipToken&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$params</span> = [</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span> =&gt; <span class="keyword">new</span> <span class="title class_">\DateTime</span>(<span class="string">&#x27;-1 month&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;end&#x27;</span> =&gt; <span class="keyword">new</span> <span class="title class_">\DateTime</span>(<span class="string">&#x27;+3 months&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;deltaToken&#x27;</span> =&gt; <span class="variable">$deltaToken</span>,</span><br><span class="line">        <span class="string">&#x27;skipToken&#x27;</span> =&gt; <span class="variable">$skipToken</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;graphClient-&gt;<span class="title function_ invoke__">getCalendarView</span>(<span class="variable">$params</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$response</span>-&gt;value <span class="keyword">as</span> <span class="variable">$item</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$item</span>[<span class="string">&#x27;@removed&#x27;</span>])) &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">handleDeletedEvent</span>(<span class="variable">$item</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">handleEvent</span>(<span class="variable">$item</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$response</span>[<span class="string">&#x27;@odata.nextLink&#x27;</span>])) &#123;</span><br><span class="line">            <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;skipToken&#x27;</span>, <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">extractSkipToken</span>(<span class="variable">$response</span>));</span><br><span class="line">            <span class="variable">$params</span>[<span class="string">&#x27;skipToken&#x27;</span>] = <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;skipToken&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>(<span class="variable">$response</span>[<span class="string">&#x27;@odata.deltaLink&#x27;</span>])) &#123;</span><br><span class="line">            <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;deltaToken&#x27;</span>, <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">extractDeltaToken</span>(<span class="variable">$response</span>));</span><br><span class="line">            <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;skipToken&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 同步完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">isset</span>(<span class="variable">$response</span>[<span class="string">&#x27;@odata.nextLink&#x27;</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;entityManager-&gt;<span class="title function_ invoke__">saveEntity</span>(<span class="variable">$calendarUser</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-错误处理与恢复"><a href="#4-错误处理与恢复" class="headerlink" title="4. 错误处理与恢复"></a>4. 错误处理与恢复</h2><h3 id="4-1-常见错误类型"><a href="#4-1-常见错误类型" class="headerlink" title="4.1 常见错误类型"></a>4.1 常见错误类型</h3><table>
<thead>
<tr>
<th align="left">错误</th>
<th align="left">原因</th>
<th align="left">恢复策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">401 Unauthorized</td>
<td align="left">Token 过期</td>
<td align="left">用 refreshToken 刷新</td>
</tr>
<tr>
<td align="left">410 Gone</td>
<td align="left">deltaToken 过期</td>
<td align="left">重新开始全量同步</td>
</tr>
<tr>
<td align="left">429 TooManyRequests</td>
<td align="left">API 限流</td>
<td align="left">延迟重试</td>
</tr>
<tr>
<td align="left">500+ 服务器错误</td>
<td align="left">临时故障</td>
<td align="left">延迟重试</td>
</tr>
</tbody></table>
<h3 id="4-2-错误处理流程"><a href="#4-2-错误处理流程" class="headerlink" title="4.2 错误处理流程"></a>4.2 错误处理流程</h3><pre class="mermaid">flowchart TD
    A[API 请求] --> B{响应状态}
    B -->|成功| C[处理事件数据]
    B -->|401| D[刷新 Token]
    B -->|410| E[清除 Token]

    D --> F[重试请求]
    E --> G[重新开始全量同步]
    B -->|429/500| H[延迟后重试]</pre>

<h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$response</span> = <span class="variable language_">$this</span>-&gt;graphClient-&gt;<span class="title function_ invoke__">request</span>(<span class="variable">$url</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$response</span>-&gt;<span class="title function_ invoke__">getStatusCode</span>() === <span class="number">401</span>) &#123;</span><br><span class="line">    <span class="comment">// Token 过期，尝试刷新</span></span><br><span class="line">    <span class="variable">$newToken</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">refreshAccessToken</span>(<span class="variable">$calendarUser</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$newToken</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Token refresh failed&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$response</span>-&gt;<span class="title function_ invoke__">getStatusCode</span>() === <span class="number">410</span>) &#123;</span><br><span class="line">    <span class="comment">// Delta token 过期，重新开始</span></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">warning</span>(<span class="string">&#x27;Delta token expired, restarting sync&#x27;</span>);</span><br><span class="line">    <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;deltaToken&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="variable">$calendarUser</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;skipToken&#x27;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">syncCalendar</span>(<span class="variable">$calendarUser</span>); <span class="comment">// 递归调用，使用无 token 开始</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-监控与排障"><a href="#5-监控与排障" class="headerlink" title="5. 监控与排障"></a>5. 监控与排障</h2><h3 id="5-1-关键日志"><a href="#5-1-关键日志" class="headerlink" title="5.1 关键日志"></a>5.1 关键日志</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[INFO] Outlook sync: Processing calendar &#123;calendarName&#125;.</span><br><span class="line">[INFO] Outlook sync: Received deltaToken. Sync completed.</span><br><span class="line">[INFO] Outlook sync: 3 events created, 1 updated, 2 deleted.</span><br><span class="line">[WARNING] Outlook sync: Sync state generation expired, restarting.</span><br><span class="line">[ERROR] Outlook sync: Failed to refresh token for user &#123;userId&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="5-2-数据库验证"><a href="#5-2-数据库验证" class="headerlink" title="5.2 数据库验证"></a>5.2 数据库验证</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看同步状态</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    u.name,</span><br><span class="line">    cu.last_synced_at,</span><br><span class="line">    cu.delta_token <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">as</span> has_delta</span><br><span class="line"><span class="keyword">FROM</span> outlook_calendar_user cu</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">user</span> u <span class="keyword">ON</span> cu.user_id <span class="operator">=</span> u.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看同步统计</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_events,</span><br><span class="line">    <span class="built_in">MAX</span>(synced_at) <span class="keyword">as</span> last_sync</span><br><span class="line"><span class="keyword">FROM</span> outlook_calendar_event</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-同步配置参数"><a href="#5-3-同步配置参数" class="headerlink" title="5.3 同步配置参数"></a>5.3 同步配置参数</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;outlookCalendarSyncPeriod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1 year&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outlookCalendarSyncEndPeriod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3 months&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;outlookCalendarSyncMaxPortionSize&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">syncPeriod</td>
<td align="left">向前拉取多长时间的数据</td>
</tr>
<tr>
<td align="left">syncEndPeriod</td>
<td align="left">向后拉取多长时间的数据</td>
</tr>
<tr>
<td align="left">maxPortionSize</td>
<td align="left">每页返回多少条记录</td>
</tr>
</tbody></table>
<hr>
<h2 id="本篇总结"><a href="#本篇总结" class="headerlink" title="本篇总结"></a>本篇总结</h2><ul>
<li>OAuth 2.0 实现 EspoCRM 与外部系统的安全连接</li>
<li>增量同步用 deltaLink&#x2F;skipToken 机制，避免全量拉取</li>
<li>Token 失效有恢复策略，同步失败不中断服务</li>
<li>关键节点打英文日志，保证线上可定位</li>
</ul>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>integration</tag>
        <tag>outlook</tag>
        <tag>oauth</tag>
        <tag>sync</tag>
      </tags>
  </entry>
  <entry>
    <title>EspoCRM定制篇Dynamic Logic + BeforeSave Hook ——前后端双保险</title>
    <url>/2025/12/21/espocrm/04-validation-dynamic-logic-hook/</url>
    <content><![CDATA[<blockquote>
<p>适用版本：EspoCRM 9.2.2+</p>
</blockquote>
<p>只做前端 required 的团队，迟早会被”脏数据”反噬。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>Dynamic Logic 负责体验：用户当场知道”必须填”</li>
<li>BeforeSave Hook 负责底线：任何入口都无法绕过</li>
<li>错误消息用可翻译 key 管理，默认英文输出便于排障</li>
<li>测试必须覆盖 UI + API + 边界切换</li>
</ul>
<hr>
<h2 id="1-场景：为什么”只做前端必填”是自欺欺人"><a href="#1-场景：为什么”只做前端必填”是自欺欺人" class="headerlink" title="1. 场景：为什么”只做前端必填”是自欺欺人"></a>1. 场景：为什么”只做前端必填”是自欺欺人</h2><p>当业务规定”阶段 &#x3D; Final Rejected 时必须填写拒绝原因”，很多人第一反应是：在前端把字段设成 required。</p>
<p>问题在于：前端不是唯一入口。</p>
<ul>
<li>API PATCH&#x2F;POST</li>
<li>批量更新</li>
<li>导入</li>
<li>自动化脚本</li>
</ul>
<p>这些路径都可能绕过前端。你最终会得到一堆”Final Rejected 但无拒绝原因”的脏数据，报表和复盘完全失真。</p>
<p>结论：<strong>体验靠前端，底线靠后端</strong>。</p>
<h2 id="2-架构：双层校验"><a href="#2-架构：双层校验" class="headerlink" title="2. 架构：双层校验"></a>2. 架构：双层校验</h2><pre class="mermaid">flowchart TD
  A[用户在UI切换 stage] --> B[Dynamic Logic: required]
  B -->|实时提示| C[用户填写字段]
  C --> D[保存]
  D --> E[BeforeSave Hook]
  E -->|ok| F[写入数据库]
  E -->|invalid| G[HTTP 400 Bad Request]</pre>

<h2 id="3-前端：Dynamic-Logic（实时必填）"><a href="#3-前端：Dynamic-Logic（实时必填）" class="headerlink" title="3. 前端：Dynamic Logic（实时必填）"></a>3. 前端：Dynamic Logic（实时必填）</h2><p>Dynamic Logic 的价值：让用户”当场知道要填什么”，而不是保存时才被打回。</p>
<p><strong>配置示例</strong>（公开版占位字段名）：</p>
<ul>
<li>字段：<code>rejectionReason</code></li>
<li>条件：<code>stage == &quot;Final Rejected&quot;</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dynamicLogic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;rejectionReason&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;conditionGroup&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equals&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stage&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Final Rejected&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-后端：BeforeSave-Hook（强制校验，防绕过）"><a href="#4-后端：BeforeSave-Hook（强制校验，防绕过）" class="headerlink" title="4. 后端：BeforeSave Hook（强制校验，防绕过）"></a>4. 后端：BeforeSave Hook（强制校验，防绕过）</h2><p>Hook 的价值：无论从哪里保存，规则都必须成立。</p>
<p><strong>原则</strong>：</p>
<ul>
<li>只做轻逻辑判断</li>
<li>抛出明确错误</li>
<li>不做 HTTP、邮件、复杂计算</li>
</ul>
<p><strong>行为定义</strong>（伪代码）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if stage == &quot;Final Rejected&quot; and rejectionReason is empty:</span><br><span class="line">  throw BadRequest(&quot;Rejection reason is required when stage is set to Final Rejected&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>代码骨架</strong>（公开版）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">YourModule</span>\<span class="title class_">Hooks</span>\<span class="title class_">Opportunity</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">ORM</span>\<span class="title">Entity</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">BadRequest</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeforeSave</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeSave</span>(<span class="params">Entity <span class="variable">$entity</span>, <span class="keyword">array</span> <span class="variable">$options</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;stage&#x27;</span>) === <span class="string">&#x27;Final Rejected&#x27;</span></span><br><span class="line">            &amp;&amp; !<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;rejectionReason&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequest</span>(</span><br><span class="line">                <span class="string">&quot;Rejection reason is required when stage is set to Final Rejected&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-测试矩阵（别只点-UI）"><a href="#5-测试矩阵（别只点-UI）" class="headerlink" title="5. 测试矩阵（别只点 UI）"></a>5. 测试矩阵（别只点 UI）</h2><p>最少要覆盖 3 类入口：</p>
<table>
<thead>
<tr>
<th align="left">入口</th>
<th align="left">测试内容</th>
<th align="left">期望结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UI</td>
<td align="left">切换 stage → 保存</td>
<td align="left">实时提示 + 拒绝保存</td>
</tr>
<tr>
<td align="left">API</td>
<td align="left"><code>PATCH /api/v1/Opportunity/{id}</code></td>
<td align="left">HTTP 400 + 错误信息</td>
</tr>
<tr>
<td align="left">边界</td>
<td align="left">从 Final Rejected 切回其它 stage</td>
<td align="left">允许清空原因</td>
</tr>
</tbody></table>
<p><strong>API 测试示例</strong>（公开版占位符）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PATCH <span class="string">&quot;https://crm.example.com/api/v1/Opportunity/OPP_ID&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;stage&quot;:&quot;Final Rejected&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 期望: HTTP 400</span></span><br><span class="line"><span class="comment"># 响应: &#123;&quot;error&quot;:&quot;Rejection reason is required...&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul>
<li>不要相信前端输入：这是安全和数据完整性的第一原则。</li>
<li>Dynamic Logic 是“防呆”，BeforeSave Hook 是“防漏”。</li>
<li>随着系统复杂度增加（引入 API 集成、数据导入），这种“双层校验”模式将成为维护数据质量的基石。</li>
<li>建议：从今天开始，检查你所有的 required 字段，看看它们是否在后端也有同样的守护。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>validation</tag>
        <tag>dynamic-logic</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>EspoCRM定制篇自定义Job开发——到期提醒通用模板（批量 + 去重 + 发信）</title>
    <url>/2025/12/28/espocrm/05-custom-job-development/</url>
    <content><![CDATA[<blockquote>
<p>适用版本：EspoCRM 9.2.2+</p>
</blockquote>
<p>很多 CRM 需求需要“定时触发”：到期提醒、日报生成、数据同步、数据质量巡检。自定义 Job 是正确姿势。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>实现 <code>JobDataLess</code> 接口用于无参数定时任务</li>
<li>用依赖注入获取 EntityManager、EmailSender、Log 等服务</li>
<li>批量查询（BATCH_SIZE）避免内存溢出</li>
<li>去重机制防止重复发送提醒</li>
<li>Admin 界面配置 Cron 表达式</li>
</ul>
<hr>
<h2 id="1-场景：定时任务的业务价值"><a href="#1-场景：定时任务的业务价值" class="headerlink" title="1. 场景：定时任务的业务价值"></a>1. 场景：定时任务的业务价值</h2><p>很多 CRM 需求需要”定时触发”：</p>
<ul>
<li>记录到期前 N 天发送提醒</li>
<li>每日生成销售报表</li>
<li>定期同步外部数据</li>
<li>清理过期数据</li>
</ul>
<p>这类需求不适合用 Hook，因为 Hook 是同步的、响应式的。正确的做法是<strong>自定义 Job</strong>。</p>
<h2 id="2-JobDataLess-接口与依赖注入"><a href="#2-JobDataLess-接口与依赖注入" class="headerlink" title="2. JobDataLess 接口与依赖注入"></a>2. JobDataLess 接口与依赖注入</h2><p>EspoCRM 提供了 <code>JobDataLess</code> 接口用于无参数的定时任务：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Jobs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Job</span>\<span class="title">JobDataLess</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">ORM</span>\<span class="title">EntityManager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpirationReminder</span> <span class="keyword">implements</span> <span class="title">JobDataLess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;ExpirationReminder started&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询即将到期的记录</span></span><br><span class="line">        <span class="comment">// 发送提醒邮件</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;ExpirationReminder completed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-通用案例：到期提醒（不绑定具体项目）"><a href="#3-通用案例：到期提醒（不绑定具体项目）" class="headerlink" title="3. 通用案例：到期提醒（不绑定具体项目）"></a>3. 通用案例：到期提醒（不绑定具体项目）</h2><h3 id="3-1-业务需求（抽象化）"><a href="#3-1-业务需求（抽象化）" class="headerlink" title="3.1 业务需求（抽象化）"></a>3.1 业务需求（抽象化）</h3><ul>
<li>记录到期前 90&#x2F;60&#x2F;30&#x2F;10&#x2F;3&#x2F;1 天发送提醒</li>
<li>提醒发送给负责人 + 相关用户</li>
<li>避免重复发送（去重机制）</li>
</ul>
<h3 id="3-2-批量查询（避免内存溢出）"><a href="#3-2-批量查询（避免内存溢出）" class="headerlink" title="3.2 批量查询（避免内存溢出）"></a>3.2 批量查询（避免内存溢出）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="variable constant_">BATCH_SIZE</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 ORM 查询，避免手写 SQL 绑死表结构/字段名。</span></span><br><span class="line"><span class="comment"> * 这里假设你的自定义实体类型是 CExpiringItem，字段 endDate 是 date 类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Espo\ORM\Entity[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">findItemsExpiringOnDate</span>(<span class="params">\DateTimeInterface <span class="variable">$targetDate</span>, <span class="keyword">int</span> <span class="variable">$offset</span> = <span class="number">0</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;entityManager</span><br><span class="line">        -&gt;<span class="title function_ invoke__">getRDBRepository</span>(<span class="string">&#x27;CExpiringItem&#x27;</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">where</span>([</span><br><span class="line">            <span class="string">&#x27;endDate&#x27;</span> =&gt; <span class="variable">$targetDate</span>-&gt;<span class="title function_ invoke__">format</span>(<span class="string">&#x27;Y-m-d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">        ])</span><br><span class="line">        -&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;ASC&#x27;</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">limit</span>(<span class="variable">$offset</span>, <span class="built_in">self</span>::<span class="variable constant_">BATCH_SIZE</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-去重机制（防止重复提醒）"><a href="#3-3-去重机制（防止重复提醒）" class="headerlink" title="3.3 去重机制（防止重复提醒）"></a>3.3 去重机制（防止重复提醒）</h3><p>原则：不要直接手写 <code>CREATE TABLE</code>。用元数据定义一个“提醒发送日志实体”，让系统在 rebuild 时创建表结构与索引。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去重的本质：同一记录 + 同一接收人 + 同一提醒类型 + 同一天，只允许写入一次日志。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">isReminderAlreadySent</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$itemId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$userId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$reminderType</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    \DateTimeInterface <span class="variable">$reminderDate</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;entityManager</span><br><span class="line">        -&gt;<span class="title function_ invoke__">getRDBRepository</span>(<span class="string">&#x27;CExpirationReminderLog&#x27;</span>)</span><br><span class="line">        -&gt;<span class="title function_ invoke__">where</span>([</span><br><span class="line">            <span class="string">&#x27;itemId&#x27;</span> =&gt; <span class="variable">$itemId</span>,</span><br><span class="line">            <span class="string">&#x27;userId&#x27;</span> =&gt; <span class="variable">$userId</span>,</span><br><span class="line">            <span class="string">&#x27;reminderType&#x27;</span> =&gt; <span class="variable">$reminderType</span>,</span><br><span class="line">            <span class="string">&#x27;reminderDate&#x27;</span> =&gt; <span class="variable">$reminderDate</span>-&gt;<span class="title function_ invoke__">format</span>(<span class="string">&#x27;Y-m-d&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;deleted&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">        ])</span><br><span class="line">        -&gt;<span class="title function_ invoke__">count</span>() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 entityDefs（示意，公开版）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;varchar&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;len&quot;</span><span class="punctuation">:</span> <span class="number">36</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;varchar&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;len&quot;</span><span class="punctuation">:</span> <span class="number">36</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reminderType&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;varchar&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;len&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reminderDate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;checkUnique&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;unique&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;itemId&quot;</span><span class="punctuation">,</span> <span class="string">&quot;userId&quot;</span><span class="punctuation">,</span> <span class="string">&quot;reminderType&quot;</span><span class="punctuation">,</span> <span class="string">&quot;reminderDate&quot;</span><span class="punctuation">,</span> <span class="string">&quot;deleted&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reminderDate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;reminderDate&quot;</span><span class="punctuation">,</span> <span class="string">&quot;deleted&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>写入发送日志（成功发送后立刻写）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">writeReminderLog</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$itemId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$userId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">string</span> <span class="variable">$reminderType</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    \DateTimeInterface <span class="variable">$reminderDate</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="variable">$logEntity</span> = <span class="variable language_">$this</span>-&gt;entityManager-&gt;<span class="title function_ invoke__">getNewEntity</span>(<span class="string">&#x27;CExpirationReminderLog&#x27;</span>);</span><br><span class="line">    <span class="variable">$logEntity</span>-&gt;<span class="title function_ invoke__">set</span>([</span><br><span class="line">        <span class="string">&#x27;itemId&#x27;</span> =&gt; <span class="variable">$itemId</span>,</span><br><span class="line">        <span class="string">&#x27;userId&#x27;</span> =&gt; <span class="variable">$userId</span>,</span><br><span class="line">        <span class="string">&#x27;reminderType&#x27;</span> =&gt; <span class="variable">$reminderType</span>,</span><br><span class="line">        <span class="string">&#x27;reminderDate&#x27;</span> =&gt; <span class="variable">$reminderDate</span>-&gt;<span class="title function_ invoke__">format</span>(<span class="string">&#x27;Y-m-d&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">$this</span>-&gt;entityManager-&gt;<span class="title function_ invoke__">saveEntity</span>(<span class="variable">$logEntity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-邮件发送"><a href="#3-4-邮件发送" class="headerlink" title="3.4 邮件发送"></a>3.4 邮件发送</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Mail</span>\<span class="title">EmailSender</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Entities</span>\<span class="title">Email</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数注入 EmailSender</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> EmailSender <span class="variable">$emailSender</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="variable">$emailEntity</span> = <span class="variable language_">$this</span>-&gt;entityManager-&gt;<span class="title function_ invoke__">getNewEntity</span>(<span class="title class_">Email</span>::<span class="variable constant_">ENTITY_TYPE</span>);</span><br><span class="line"><span class="variable">$emailEntity</span>-&gt;<span class="title function_ invoke__">setSubject</span>(<span class="string">&#x27;Item Expiring Soon&#x27;</span>);</span><br><span class="line"><span class="variable">$emailEntity</span>-&gt;<span class="title function_ invoke__">setBody</span>(<span class="variable">$body</span>);</span><br><span class="line"><span class="variable">$emailEntity</span>-&gt;<span class="title function_ invoke__">addToAddress</span>(<span class="variable">$userEmail</span>);</span><br><span class="line"><span class="variable language_">$this</span>-&gt;emailSender-&gt;<span class="title function_ invoke__">create</span>()-&gt;<span class="title function_ invoke__">send</span>(<span class="variable">$emailEntity</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-Job-的注册与调度"><a href="#4-Job-的注册与调度" class="headerlink" title="4. Job 的注册与调度"></a>4. Job 的注册与调度</h2><p><strong>方式一：ClassFinder 自动发现</strong></p>
<p>将 Job 类放在 <code>custom/Espo/Custom/Jobs/</code> 或 <code>custom/Espo/Modules/{Module}/Jobs/</code> 目录下，系统会自动发现。</p>
<p><strong>方式二：metadata 配置</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ExpirationReminder&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;isSystem&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scheduling&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0 9,15 * * *&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>在 Admin 界面配置</strong>：</p>
<ol>
<li>进入 Admin → Scheduled Jobs</li>
<li>创建新任务，选择 Job：Expiration Reminder</li>
<li>设置 Cron 表达式：<code>0 9,15 * * *</code>（每天 9:00 和 15:00 执行）</li>
<li>设置为 Active</li>
</ol>
<h2 id="5-监控与排障"><a href="#5-监控与排障" class="headerlink" title="5. 监控与排障"></a>5. 监控与排障</h2><p><strong>关键日志</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[INFO] ExpirationReminder started with reminder days: [90,60,30,10,3,1]</span><br><span class="line">[INFO] Processing item: ITEM-123 (ID: xxx) expiring on 2025-03-15</span><br><span class="line">[INFO] Sending reminder to recipient@example.com</span><br><span class="line">[SUCCESS] Successfully sent reminder email</span><br><span class="line">[ERROR] Failed to send email - SMTP timeout</span><br></pre></td></tr></table></figure>

<p><strong>验证建议</strong>：</p>
<ul>
<li>在后台给 Job 做一个列表视图，按 createdAt 最近 7 天过滤</li>
<li>用日志定位“开始&#x2F;处理&#x2F;发送成功&#x2F;发送失败”的链路是否完整</li>
</ul>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul>
<li><strong>JobDataLess</strong> 是实现自定义定时任务的标准接口。</li>
<li><strong>依赖注入</strong> 让代码更干净、易测试。</li>
<li><strong>批量处理</strong> (BATCH_SIZE) 是处理大量数据的必修课，防止内存溢出。</li>
<li><strong>去重机制</strong> (Idempotency) 是定时任务稳定性的核心，防止用户被骚扰。</li>
<li><strong>可观测性</strong> (Logging) 是生产环境的救命稻草，没有日志的任务是“黑盒”。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>job</tag>
        <tag>automation</tag>
        <tag>scheduled-task</tag>
      </tags>
  </entry>
  <entry>
    <title>EspoCRM定制篇纯配置多对多——不写 SQL，让 rebuild 自动建表</title>
    <url>/2025/12/06/espocrm/03-metadata-driven-many-to-many/</url>
    <content><![CDATA[<blockquote>
<p>适用版本：EspoCRM 9.2.2+</p>
</blockquote>
<p>你以为多对多必须建中间表？在 EspoCRM 里，手写 SQL 往往是你自己给自己埋雷。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li><code>entityDefs.links</code> + <code>relationName</code> 决定关系与中间表</li>
<li><code>scopes</code> 决定实体能不能被管理与配置</li>
<li><code>clientDefs + layouts</code> 决定用户界面”看不看得到、用不用得起来”</li>
<li><code>rebuild</code> 是让系统把元数据变成真实结构的开关</li>
</ul>
<hr>
<h2 id="1-场景：什么时候需要多对多"><a href="#1-场景：什么时候需要多对多" class="headerlink" title="1. 场景：什么时候需要多对多"></a>1. 场景：什么时候需要多对多</h2><p>很多 CRM 场景都需要多对多关系：</p>
<ul>
<li>一个记录关联多个标签、多个分类</li>
<li>一个项目关联多个联系人、多个资源</li>
<li>一个工单关联多个参与人、多个附件</li>
</ul>
<p>很多人第一反应是：建中间表、写迁移 SQL。这在 EspoCRM 里往往是<strong>最差</strong>的选择——你会绕过系统的元数据机制，升级时痛苦指数爆炸。</p>
<p>我们推荐的路线：<strong>只写配置</strong> → <code>rebuild</code> → EspoCRM 自动创建表结构。</p>
<h2 id="2-目标：用一套最小配置打通”能看见、能选择、能保存”"><a href="#2-目标：用一套最小配置打通”能看见、能选择、能保存”" class="headerlink" title="2. 目标：用一套最小配置打通”能看见、能选择、能保存”"></a>2. 目标：用一套最小配置打通”能看见、能选择、能保存”</h2><p>多对多不是”数据能存进去”就完事了。真正能交付给业务用，至少要满足：</p>
<ul>
<li>关系在实体定义里存在（后端能存）</li>
<li>关系在界面上可见（前端能选）</li>
<li>权限与作用域可控（ACL 不出事）</li>
<li>rebuild 后自动生成&#x2F;更新结构（可升级）</li>
</ul>
<h2 id="3-关键机制：relationName-决定中间表"><a href="#3-关键机制：relationName-决定中间表" class="headerlink" title="3. 关键机制：relationName 决定中间表"></a>3. 关键机制：relationName 决定中间表</h2><p>你可以把 EspoCRM 的自动建表理解为：<br><strong>entityDefs 里声明了关系 → rebuild 生成实际表结构</strong>。</p>
<pre class="mermaid">flowchart TD
  A[entityDefs: fields + links] --> B[rebuild]
  B --> C[(主表自动创建/更新)]
  B --> D[(中间表按 relationName 自动创建)]
  B --> E[前端元数据缓存更新]</pre>

<p>在 links 中给同一段关系设置同一个 <code>relationName</code>，就是告诉系统：</p>
<ul>
<li>这是同一个关联（正反两侧一致）</li>
<li>中间表应按这个名字生成（内部映射）</li>
</ul>
<h2 id="4-配置最小闭环（示例：EntityA-↔-EntityB）"><a href="#4-配置最小闭环（示例：EntityA-↔-EntityB）" class="headerlink" title="4. 配置最小闭环（示例：EntityA ↔ EntityB）"></a>4. 配置最小闭环（示例：EntityA ↔ EntityB）</h2><p>用中性实体名演示：</p>
<ul>
<li><code>CItem</code>：条目</li>
<li><code>CTag</code>：标签</li>
</ul>
<h3 id="4-1-定义实体（entityDefs）"><a href="#4-1-定义实体（entityDefs）" class="headerlink" title="4.1 定义实体（entityDefs）"></a>4.1 定义实体（entityDefs）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;varchar&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hasMany&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;entity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CTag&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;foreign&quot;</span><span class="punctuation">:</span> <span class="string">&quot;items&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cItemTag&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另一侧：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;varchar&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hasMany&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;entity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CItem&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;foreign&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tags&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relationName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cItemTag&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-定义作用域（scopes）"><a href="#4-2-定义作用域（scopes）" class="headerlink" title="4.2 定义作用域（scopes）"></a>4.2 定义作用域（scopes）</h3><p>如果 scopes 不完整，菜单不显示、权限无法配置、布局无法编辑。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;entity&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;layouts&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tab&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;acl&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;customizable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;importable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stream&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Base&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isCustom&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-让关系在-UI-可见（clientDefs-layouts）"><a href="#4-3-让关系在-UI-可见（clientDefs-layouts）" class="headerlink" title="4.3 让关系在 UI 可见（clientDefs + layouts）"></a>4.3 让关系在 UI 可见（clientDefs + layouts）</h3><p>只写 entityDefs，用户会说”加了关系，但页面上看不到”。需要两层：</p>
<ul>
<li><code>clientDefs</code>：关系面板声明（relationshipPanels）</li>
<li><code>layouts</code>：字段&#x2F;面板落位（edit&#x2F;detail）</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;relationships&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;layout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>布局示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tags&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Overview&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h2 id="5-rebuild-之后会发生什么"><a href="#5-rebuild-之后会发生什么" class="headerlink" title="5. rebuild 之后会发生什么"></a>5. rebuild 之后会发生什么</h2><ul>
<li>系统为 <code>cItemTag</code> 自动生成中间表</li>
<li>两侧实体的关联可在 UI 面板中维护</li>
<li>ACL 生效：不同角色看到的范围可控</li>
</ul>
<h2 id="6-部署与验证"><a href="#6-部署与验证" class="headerlink" title="6. 部署与验证"></a>6. 部署与验证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逐文件复制</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">cp</span> CItem.json <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/CItem.json</span><br><span class="line">docker <span class="built_in">cp</span> CTag.json <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/CTag.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># rebuild</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br></pre></td></tr></table></figure>

<p>验证清单：</p>
<ul>
<li><input disabled type="checkbox"> 后台能看到两个实体的菜单入口</li>
<li><input disabled type="checkbox"> 编辑页面能选择关联记录</li>
<li><input disabled type="checkbox"> 保存后关系面板能看到关联列表</li>
<li><input disabled type="checkbox"> 不同角色下 ACL 表现符合预期</li>
</ul>
<h2 id="7-常见坑"><a href="#7-常见坑" class="headerlink" title="7. 常见坑"></a>7. 常见坑</h2><ul>
<li>scopes 配置缺失导致”菜单不显示&#x2F;权限不可配”</li>
<li>layouts 没放字段导致”后端有关系，前端看不到”</li>
<li>忘记 rebuild 导致”改了配置不生效”</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>EspoCRM</category>
      </categories>
      <tags>
        <tag>EspoCRM</tag>
        <tag>metadata</tag>
        <tag>many-to-many</tag>
        <tag>rebuild</tag>
      </tags>
  </entry>
</search>
