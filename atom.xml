<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yhzhu的随手记</title>
  
  
  <link href="https://www.yzhu.name/atom.xml" rel="self"/>
  
  <link href="https://www.yzhu.name/"/>
  <updated>2025-11-16T01:00:00.000Z</updated>
  <id>https://www.yzhu.name/</id>
  
  <author>
    <name>yhzhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EspoCRM定制篇总纲——扩展点选择、模块架构与工程化</title>
    <link href="https://www.yzhu.name/2025/11/16/espocrm/01-upgrade-safe-customization-redlines/"/>
    <id>https://www.yzhu.name/2025/11/16/espocrm/01-upgrade-safe-customization-redlines/</id>
    <published>2025-11-16T01:00:00.000Z</published>
    <updated>2025-11-16T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适用版本：EspoCRM 9.2.2+（开源版）</p></blockquote><p>你以为”能跑起来”就完了？真正的难点从你第一次升级开始。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>用”扩展点金字塔”选择最小侵入方案，能配置就不写代码</li><li>用”目录分区”隔离管理员配置与开发者代码，避免不可审计混乱</li><li>用”模块化架构”把改动锁在可控边界内</li><li>用”清单化部署+回滚”把风险降到可控</li></ul><hr><h2 id="1-扩展点金字塔"><a href="#1-扩展点金字塔" class="headerlink" title="1. 扩展点金字塔"></a>1. 扩展点金字塔</h2><h3 id="1-1-我们解决的不是”能不能改”，而是”能不能长期维护”"><a href="#1-1-我们解决的不是”能不能改”，而是”能不能长期维护”" class="headerlink" title="1.1 我们解决的不是”能不能改”，而是”能不能长期维护”"></a>1.1 我们解决的不是”能不能改”，而是”能不能长期维护”</h3><p>很多团队做 EspoCRM 定制，第一阶段靠”改得快”赢；第二阶段会被”不可升级、不可回滚、不可定位问题”拖垮。</p><p>这套系列文章的目标很明确：</p><ul><li>不讨论”改核心文件最快”的玩法，只讨论”升级后仍可活”的做法</li><li>不是展示技巧堆叠，而是给一套可复用的工程模板</li></ul><h3 id="1-2-选择扩展点的优先级（金字塔）"><a href="#1-2-选择扩展点的优先级（金字塔）" class="headerlink" title="1.2 选择扩展点的优先级（金字塔）"></a>1.2 选择扩展点的优先级（金字塔）</h3><p>我们的默认策略：<strong>能不写代码就不写代码</strong>，能用系统机制就不用自造轮子。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Formula (优先)      - 简单计算和条件逻辑</span><br><span class="line">2. Dynamic Logic        - 界面显示与字段依赖</span><br><span class="line">3. Workflow / BPM       - 复杂业务流程（谨慎）</span><br><span class="line">4. Hook                 - 数据一致性保障（禁止复杂计算/HTTP/发信）</span><br><span class="line">5. Service / Controller - API 与复杂逻辑（最后手段）</span><br></pre></td></tr></table></figure><p>你会在后面几篇里看到同一个套路反复出现：<br>先用 Dynamic Logic 解决体验，再用 Hook&#x2F;Service 解决”绕过与一致性”。</p><h3 id="1-3-红线（违反就注定不可维护）"><a href="#1-3-红线（违反就注定不可维护）" class="headerlink" title="1.3 红线（违反就注定不可维护）"></a>1.3 红线（违反就注定不可维护）</h3><ul><li>不修改 <code>application/</code> 目录下任何文件（除非你准备永久自己维护一个 fork）</li><li>不在代码里硬编码环境信息（域名、容器名、数据库连接、密钥）</li><li>不把管理员配置和开发者代码混在同一套元数据文件里</li><li>不在 Hook 里做重逻辑（尤其是发邮件、复杂计算、HTTP 请求）</li><li>不绕过 ACL（任何”方便调试的后门”最终都会变成安全事故）</li></ul><hr><h2 id="2-模块化架构"><a href="#2-模块化架构" class="headerlink" title="2. 模块化架构"></a>2. 模块化架构</h2><h3 id="2-1-目录分区：开发者模块-vs-管理员配置区"><a href="#2-1-目录分区：开发者模块-vs-管理员配置区" class="headerlink" title="2.1 目录分区：开发者模块 vs 管理员配置区"></a>2.1 目录分区：开发者模块 vs 管理员配置区</h3><p>我们把”可升级”落到物理结构上：</p><ul><li>管理员（GUI）产生的配置：<code>custom/Espo/Custom/</code></li><li>开发者（代码）交付的模块：<code>custom/Espo/Modules/{ModuleName}/</code></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">custom/</span><br><span class="line">├── Espo/Custom/                    # 管理员配置区（GUI）</span><br><span class="line">│   └── Resources/metadata/</span><br><span class="line">└── Espo/Modules/&#123;ModuleName&#125;/      # 开发者模块区（代码）</span><br><span class="line">    ├── Controllers/</span><br><span class="line">    ├── Services/</span><br><span class="line">    ├── Hooks/</span><br><span class="line">    ├── Jobs/</span><br><span class="line">    └── Resources/</span><br><span class="line">        ├── metadata/</span><br><span class="line">        ├── routes.json</span><br><span class="line">        └── i18n/</span><br></pre></td></tr></table></figure><p><strong>为什么这么苛刻？</strong><br>因为管理员配置可变、不可审计，而开发者代码必须可审计、可回滚、可复现。混在一起，等于把两种生命周期掺成一锅粥。</p><h3 id="2-2-完整后端模块结构"><a href="#2-2-完整后端模块结构" class="headerlink" title="2.2 完整后端模块结构"></a>2.2 完整后端模块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">custom/Espo/Modules/MyModule/</span><br><span class="line">├── Module.php                          # 模块定义类</span><br><span class="line">├── composer.json                       # 第三方依赖（可选）</span><br><span class="line">│</span><br><span class="line">├── Controllers/                        # API 控制器</span><br><span class="line">│   └── MyEntity.php</span><br><span class="line">│</span><br><span class="line">├── Services/                           # 业务逻辑服务层</span><br><span class="line">│   └── MyService.php</span><br><span class="line">│</span><br><span class="line">├── Hooks/                              # 数据钩子</span><br><span class="line">│   ├── MyEntity/</span><br><span class="line">│   │   └── BeforeSave.php</span><br><span class="line">│   └── AnotherEntity/</span><br><span class="line">│       └── AfterSave.php</span><br><span class="line">│</span><br><span class="line">├── Jobs/                               # 定时任务</span><br><span class="line">│   └── MyScheduledJob.php</span><br><span class="line">│</span><br><span class="line">├── Entities/                           # 实体类（可选）</span><br><span class="line">│   └── MyEntity.php</span><br><span class="line">│</span><br><span class="line">├── Repositories/                       # 数据仓库（可选）</span><br><span class="line">│   └── MyEntityRepository.php</span><br><span class="line">│</span><br><span class="line">└── Resources/                          # 元数据与配置</span><br><span class="line">    ├── metadata/</span><br><span class="line">    │   ├── entityDefs/                 # 实体定义</span><br><span class="line">    │   ├── clientDefs/                 # 前端定义</span><br><span class="line">    │   ├── scopes/                     # 权限作用域</span><br><span class="line">    │   ├── app/</span><br><span class="line">    │   │   ├── adminPanel.json        # 管理面板菜单</span><br><span class="line">    │   │   └── config.json            # 系统配置</span><br><span class="line">    │   └── routes.json                 # API 路由</span><br><span class="line">    │</span><br><span class="line">    ├── layouts/                         # 界面布局</span><br><span class="line">    │   └── MyEntity/</span><br><span class="line">    │       ├── list.json</span><br><span class="line">    │       ├── detail.json</span><br><span class="line">    │       ├── edit.json</span><br><span class="line">    │       └── create.json</span><br><span class="line">    │</span><br><span class="line">    └── i18n/                            # 语言包</span><br><span class="line">        └── en_US/</span><br><span class="line">            ├── Global.json</span><br><span class="line">            └── MyEntity.json</span><br></pre></td></tr></table></figure><h3 id="2-3-前端模块结构"><a href="#2-3-前端模块结构" class="headerlink" title="2.3 前端模块结构"></a>2.3 前端模块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client/modules/my-module/</span><br><span class="line">└── src/</span><br><span class="line">    ├── views/                           # 自定义视图</span><br><span class="line">    │   └── my-entity/</span><br><span class="line">    │       ├── detail.js</span><br><span class="line">    │       ├── edit.js</span><br><span class="line">    │       └── list.js</span><br><span class="line">    ├── fields/                          # 自定义字段类型</span><br><span class="line">    │   └── my-field-type.js</span><br><span class="line">    └── templates/                       # Handlebars 模板（可选）</span><br><span class="line">        └── my-template.tpl</span><br></pre></td></tr></table></figure><h3 id="2-4-管理员配置区（开发者不要动）"><a href="#2-4-管理员配置区（开发者不要动）" class="headerlink" title="2.4 管理员配置区（开发者不要动）"></a>2.4 管理员配置区（开发者不要动）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">custom/Espo/Custom/</span><br><span class="line">└── Resources/</span><br><span class="line">    └── metadata/                        # 管理员通过 GUI 添加的配置</span><br><span class="line">        ├── entityDefs/</span><br><span class="line">        ├── clientDefs/</span><br><span class="line">        └── scopes/</span><br></pre></td></tr></table></figure><hr><h2 id="3-各层职责分工"><a href="#3-各层职责分工" class="headerlink" title="3. 各层职责分工"></a>3. 各层职责分工</h2><h3 id="3-1-Controller：API-入口"><a href="#3-1-Controller：API-入口" class="headerlink" title="3.1 Controller：API 入口"></a>3.1 Controller：API 入口</h3><p><strong>职责</strong>：</p><ul><li>处理 HTTP 请求</li><li>权限检查（ACL）</li><li>调用 Service 处理业务逻辑</li><li>返回 JSON 响应</li></ul><p><strong>示例骨架</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Controllers</span>\<span class="title">Record</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">BadRequest</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">Forbidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> <span class="keyword">extends</span> <span class="title">Record</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionMyAction</span>(<span class="params"><span class="variable">$params</span>, <span class="variable">$data</span>, <span class="variable">$request</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 权限检查</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getUser</span>()-&gt;<span class="title function_ invoke__">isAdmin</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Forbidden</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数验证</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>-&gt;param)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequest</span>(<span class="string">&quot;param is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Service</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getContainer</span>()-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;MyService&#x27;</span>)-&gt;<span class="title function_ invoke__">doSomething</span>(<span class="variable">$data</span>-&gt;param);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Service：业务逻辑层"><a href="#3-2-Service：业务逻辑层" class="headerlink" title="3.2 Service：业务逻辑层"></a>3.2 Service：业务逻辑层</h3><p><strong>职责</strong>：</p><ul><li>复杂业务逻辑</li><li>跨实体操作</li><li>数据计算与转换</li><li>调用外部 API</li></ul><p><strong>示例骨架</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Services</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">ORM</span>\<span class="title">EntityManager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Config</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Config <span class="variable">$config</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$param</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&quot;MyService::doSomething started with param: <span class="subst">&#123;$param&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">processData</span>(<span class="variable">$param</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&quot;MyService::doSomething completed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$param</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Hook：数据一致性保障"><a href="#3-3-Hook：数据一致性保障" class="headerlink" title="3.3 Hook：数据一致性保障"></a>3.3 Hook：数据一致性保障</h3><p><strong>职责</strong>：</p><ul><li>数据保存前的校验&#x2F;补充（BeforeSave）</li><li>数据保存后的联动（AfterSave）</li><li>数据删除前的检查（BeforeDelete）</li></ul><p><strong>原则</strong>：</p><ul><li>只做轻逻辑判断</li><li>不发邮件、不做 HTTP 请求</li><li>不做复杂计算</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Hooks</span>\<span class="title class_">MyEntity</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">ORM</span>\<span class="title">Entity</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Exceptions</span>\<span class="title">BadRequest</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeforeSave</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beforeSave</span>(<span class="params">Entity <span class="variable">$entity</span>, <span class="keyword">array</span> <span class="variable">$options</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;status&#x27;</span>) === <span class="string">&#x27;Closed&#x27;</span> &amp;&amp; !<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;closedReason&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequest</span>(<span class="string">&quot;closedReason is required&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据补充</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">isNew</span>()) &#123;</span><br><span class="line">            <span class="variable">$entity</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;assignedUserId&#x27;</span>, <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">getUser</span>()-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-Job：定时后台任务"><a href="#3-4-Job：定时后台任务" class="headerlink" title="3.4 Job：定时后台任务"></a>3.4 Job：定时后台任务</h3><p><strong>职责</strong>：</p><ul><li>定时触发</li><li>批量数据处理</li><li>发送通知&#x2F;邮件</li><li>定期数据同步</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Espo</span>\<span class="title class_">Modules</span>\<span class="title class_">MyModule</span>\<span class="title class_">Jobs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Job</span>\<span class="title">JobDataLess</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">ORM</span>\<span class="title">EntityManager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Espo</span>\<span class="title">Core</span>\<span class="title">Utils</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyScheduledJob</span> <span class="keyword">implements</span> <span class="title">JobDataLess</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> EntityManager <span class="variable">$entityManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">private</span> Log <span class="variable">$log</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;MyScheduledJob started&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时任务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;log-&gt;<span class="title function_ invoke__">info</span>(<span class="string">&#x27;MyScheduledJob completed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-rebuild-与-clear-cache"><a href="#4-rebuild-与-clear-cache" class="headerlink" title="4. rebuild 与 clear-cache"></a>4. rebuild 与 clear-cache</h2><h3 id="4-1-把”生效机制”当成工程事实"><a href="#4-1-把”生效机制”当成工程事实" class="headerlink" title="4.1 把”生效机制”当成工程事实"></a>4.1 把”生效机制”当成工程事实</h3><p>你在 EspoCRM 里改了元数据、前端视图映射、语言包、布局之后，最常见的错误不是”写错代码”，而是”你以为改了就生效”。</p><p>建议把下面清单当作工程制度，而不是”记得就做”：</p><table><thead><tr><th align="left">操作</th><th align="left">必须</th></tr></thead><tbody><tr><td align="left">改 metadata（entityDefs &#x2F; clientDefs &#x2F; scopes &#x2F; routes &#x2F; app）</td><td align="left">rebuild</td></tr><tr><td align="left">改前端视图或模板</td><td align="left">clear-cache + 浏览器强刷</td></tr><tr><td align="left">改语言包</td><td align="left">rebuild</td></tr></tbody></table><h3 id="4-2-执行方式"><a href="#4-2-执行方式" class="headerlink" title="4.2 执行方式"></a>4.2 执行方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php clear-cache</span><br></pre></td></tr></table></figure><hr><h2 id="5-部署与回滚"><a href="#5-部署与回滚" class="headerlink" title="5. 部署与回滚"></a>5. 部署与回滚</h2><h3 id="5-1-容器化部署架构说明"><a href="#5-1-容器化部署架构说明" class="headerlink" title="5.1 容器化部署架构说明"></a>5.1 容器化部署架构说明</h3><pre class="mermaid">graph TD    subgraph Client [用户客户端]        A[Web 浏览器 / 移动端]    end    subgraph Docker_Environment [Docker  环境]        direction LR        subgraph EspoCRM_Monolith [EspoCRM 核心应用容器 Container]            C[Web Server : Nginx] --> D[PHP-FPM / EspoCRM Code]            D --> E[Cron Scheduler :Background Tasks]        end        Fsys[Filesystem Volume :持久化挂载]    end    subgraph External_Managed_Services [容器外公共托管服务]        G[Database :MySQL/ RDS]        H[Cache/Queue :Redis]        J[Identity Provider :Azure AD / LDAP]        K[Email Services :SMTP/IMAP]        L[AWS S3 :用户文件存储]    end    A -->|HTTPS/HTTP| C    D -->|SQL| G    D -->|Read/Write Logs| Fsys    D -->|S3 API / Uploaded Files| L    D -.->|API/Protocol| H    D -->|OIDC/SAML| J    D -->|SMTP/IMAP| K    E -->|Background Tasks| D    E -->|Data Access| G    style EspoCRM_Monolith fill:#FFF7E0,stroke:#333    style Docker_Environment fill:#E0FFEE,stroke:#333    style External_Managed_Services fill:#F0E6FF,stroke:#333</pre><table><thead><tr><th align="left">组件</th><th align="left">部署位置</th><th align="left">运维职责</th><th align="left">依赖关系</th><th align="left">备注（起步阶段）</th></tr></thead><tbody><tr><td align="left">Web Server &#x2F; PHP-FPM &#x2F; EspoCRM Code</td><td align="left">Docker Container（容器内部）</td><td align="left">开发团队负责构建和维护单一应用镜像</td><td align="left">接收 Client 流量，连接外部服务（DB&#x2F;IDP&#x2F;Email）</td><td align="left">核心组件，包含全部定制代码</td></tr><tr><td align="left">Cron Scheduler</td><td align="left">Docker Container（容器内部）</td><td align="left">开发团队负责运行</td><td align="left">依赖 PHP（执行任务）；访问 Database（获取任务数据）</td><td align="left">核心组件，必须定期运行</td></tr><tr><td align="left">Filesystem Volume</td><td align="left">容器外部持久化卷（Volume）</td><td align="left">运维团队负责管理与备份</td><td align="left">供 PHP 读写代码&#x2F;配置与用户上传文件（<code>data/upload/</code>）</td><td align="left">关键依赖，确保 PV 备份</td></tr><tr><td align="left">Database（MySQL&#x2F;PostgreSQL）</td><td align="left">容器外公共服务（Managed Service）</td><td align="left">外部服务商管理（如 RDS）</td><td align="left">被 PHP 与 Cron 访问，存储业务数据与元数据</td><td align="left">必须依赖</td></tr><tr><td align="left">Identity Provider（Azure AD&#x2F;LDAP）</td><td align="left">容器外公共服务</td><td align="left">外部服务商管理</td><td align="left">被 PHP 通过 OIDC&#x2F;SAML 用于 SSO</td><td align="left">必须依赖</td></tr><tr><td align="left">Email Services（SMTP&#x2F;IMAP）</td><td align="left">容器外公共服务</td><td align="left">外部服务商管理</td><td align="left">被 PHP 用于邮件发送与接收</td><td align="left">必须依赖（实现邮件功能）</td></tr><tr><td align="left">AWS S3</td><td align="left">容器外公共服务</td><td align="left">外部服务商管理</td><td align="left">用户文件存储</td><td align="left">必须依赖</td></tr><tr><td align="left">Cache &amp; Search Engine</td><td align="left">暂时不用（使用内部回退机制）</td><td align="left">暂无独立运维职责</td><td align="left">内部 PHP 使用文件系统或数据库做缓存&#x2F;搜索</td><td align="left">现阶段可省略，用户增长后升级</td></tr></tbody></table><h3 id="5-2-逐文件拷贝原则"><a href="#5-2-逐文件拷贝原则" class="headerlink" title="5.2 逐文件拷贝原则"></a>5.2 逐文件拷贝原则</h3><p><strong>禁止</strong>：目录拷贝（不要把整个 <code>custom/</code> 目录一次性扔进容器）</p><p><strong>正确</strong>：逐文件拷贝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 正确：逐文件拷贝，可审计</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">cp</span> Module.php <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Module.php</span><br><span class="line">docker <span class="built_in">cp</span> MyEntity.json <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json</span><br><span class="line"><span class="comment"># ... 逐个文件</span></span><br></pre></td></tr></table></figure><h3 id="5-3-部署检查清单"><a href="#5-3-部署检查清单" class="headerlink" title="5.3 部署检查清单"></a>5.3 部署检查清单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">文件部署</span><br><span class="line">├── [ ] 所有 .php 文件已拷贝</span><br><span class="line">├── [ ] 所有 .json 元数据文件已拷贝</span><br><span class="line">├── [ ] 所有 .js 前端文件已拷贝</span><br><span class="line">└── [ ] 所有 .tpl 模板文件已拷贝</span><br><span class="line"></span><br><span class="line">系统重建</span><br><span class="line">├── [ ] rebuild 已执行</span><br><span class="line">├── [ ] clear-cache 已执行</span><br><span class="line">└── [ ] 浏览器缓存已清空</span><br><span class="line"></span><br><span class="line">功能验证</span><br><span class="line">├── [ ] 新菜单项显示</span><br><span class="line">├── [ ] 新实体可创建/编辑</span><br><span class="line">├── [ ] 新 API 端点可访问</span><br><span class="line">├── [ ] ACL 权限正确</span><br><span class="line">└── [ ] 日志无错误</span><br><span class="line"></span><br><span class="line">备份确认</span><br><span class="line">├── [ ] 管理员配置已备份</span><br><span class="line">└── [ ] 数据库已备份</span><br></pre></td></tr></table></figure><h3 id="5-4-回滚策略"><a href="#5-4-回滚策略" class="headerlink" title="5.4 回滚策略"></a>5.4 回滚策略</h3><p><strong>代码回滚</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 在宿主机源码里回滚到上一个可用版本（示例：Git）</span></span><br><span class="line">git checkout &lt;last-good-tag-or-commit&gt; -- custom/Espo/Modules/MyModule/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 按“逐文件拷贝”重新部署到容器</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">docker <span class="built_in">cp</span> custom/Espo/Modules/MyModule/Module.php \</span><br><span class="line">  <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Module.php</span><br><span class="line">docker <span class="built_in">cp</span> custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json \</span><br><span class="line">  <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:/var/www/html/custom/Espo/Modules/MyModule/Resources/metadata/entityDefs/MyEntity.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) rebuild 生效</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br></pre></td></tr></table></figure><p><strong>数据回滚</strong>：</p><p>结论：不要指望 rebuild 自动“回收”数据库结构。</p><ul><li>默认 rebuild（soft）只会创建&#x2F;变更需要的表、列、索引；不会 drop 表，也不会 drop 列</li><li>hard rebuild 可能会 drop 未使用的列、缩短超长列长度，但仍不会 drop 表，且有数据丢失风险</li></ul><p>推荐回滚策略：</p><ol><li>回滚前先备份数据库（至少 schema + 相关业务表数据）</li><li>回滚代码与元数据后执行 rebuild，让缓存与元数据状态一致</li><li>对“新增表&#x2F;中间表&#x2F;索引”的清理，采用显式的反向 SQL（DROP TABLE&#x2F;INDEX），并在测试库验证后再执行到生产</li><li>对“新增列&#x2F;字段”的回滚，优先走“弃用而非删除”：保留列与数据，仅从界面与业务逻辑中移除；确需删除时使用 hard rebuild 或反向 SQL，并明确数据保留&#x2F;迁移方案</li></ol><h3 id="5-5-管理员配置备份"><a href="#5-5-管理员配置备份" class="headerlink" title="5.5 管理员配置备份"></a>5.5 管理员配置备份</h3><p>开发者代码在 Git 中有版本控制，但管理员配置（<code>custom/Espo/Custom/</code>）不在任何版本控制系统里。<strong>系统崩溃时，管理员配置会丢失</strong>。</p><p><strong>问题本质</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开发者代码：Git 版本控制 → 随时恢复 ✅</span><br><span class="line">管理员配置：无版本控制 → 系统崩 = 配置丢 ❌</span><br></pre></td></tr></table></figure><p><strong>推荐方案：定时备份脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># backup-admin-config.sh</span></span><br><span class="line"></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/backup/espocrm/admin-config&quot;</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份管理员配置（打包成单文件，只拷贝单个归档文件）</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>&quot;</span></span><br><span class="line">TMP_FILE=<span class="string">&quot;/tmp/Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> tar -czf <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> -C /var/www/html custom/Espo/Custom</span><br><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:<span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>/Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留最近 30 天的备份</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$BACKUP_DIR</span>&quot;</span> -name <span class="string">&quot;Custom_*.tar.gz&quot;</span> -mtime +30 -delete</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Admin config backed up: Custom_<span class="variable">$DATE</span>.tar.gz&quot;</span></span><br></pre></td></tr></table></figure><p>设置 cron 每天自动执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 crontab</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每天凌晨 2 点执行</span></span><br><span class="line">0 2 * * * /path/to/backup-admin-config.sh &gt;&gt; /var/log/espocrm-backup.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>恢复流程</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复管理员配置（选择备份日期，会覆盖现有 Custom 配置）</span></span><br><span class="line">CONTAINER_NAME=<span class="string">&quot;&lt;your-espocrm-container&gt;&quot;</span></span><br><span class="line">BACKUP_FILE=<span class="string">&quot;/backup/espocrm/admin-config/Custom_20251227_020000.tar.gz&quot;</span></span><br><span class="line">TMP_FILE=<span class="string">&quot;/tmp/Custom_restore.tar.gz&quot;</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$BACKUP_FILE</span>&quot;</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span>:<span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> tar -xzf <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span> -C /var/www/html</span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$TMP_FILE</span>&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> php /var/www/html/command.php rebuild</span><br></pre></td></tr></table></figure><hr><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><h3 id="6-1-一套可复用的工程模板"><a href="#6-1-一套可复用的工程模板" class="headerlink" title="6.1 一套可复用的工程模板"></a>6.1 一套可复用的工程模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">每个需求按同一模板交付：</span><br><span class="line"></span><br><span class="line">├── 需求与验收标准</span><br><span class="line">├── 扩展点选择与理由</span><br><span class="line">├── 技术设计与数据流</span><br><span class="line">├── 代码实现（模块边界内）</span><br><span class="line">├── 测试（UI + API + 边界）</span><br><span class="line">├── 部署脚本（逐文件拷贝）</span><br><span class="line">└── 回滚策略</span><br></pre></td></tr></table></figure><h3 id="6-2-最终建议"><a href="#6-2-最终建议" class="headerlink" title="6.2 最终建议"></a>6.2 最终建议</h3><ol><li><strong>能配置就不写代码</strong> —— 用好 Formula、Dynamic Logic</li><li><strong>能扩展就不重写</strong> —— 默认看板能扩展就别完全重写</li><li><strong>改动锁在模块内</strong> —— 不改 <code>application/</code> 目录</li><li><strong>rebuild 是纪律</strong> —— 改元数据必须 rebuild</li></ol>]]></content>
    
    
    <summary type="html">EspoCRM 定制的第一课不是“怎么写代码”，而是“怎么写出可升级的代码”。本文给出扩展点金字塔（Formula → Dynamic Logic → Workflow → Hook → Service），帮助选择最小侵入方案。同时梳理模块架构、目录分区、rebuild 纪律、逐文件部署、回滚与配置备份，确保长期可维护。</summary>
    
    
    
    <category term="EspoCRM" scheme="https://www.yzhu.name/categories/EspoCRM/"/>
    
    
    <category term="EspoCRM" scheme="https://www.yzhu.name/tags/EspoCRM/"/>
    
    <category term="customization" scheme="https://www.yzhu.name/tags/customization/"/>
    
    <category term="upgrade-safe" scheme="https://www.yzhu.name/tags/upgrade-safe/"/>
    
    <category term="module-architecture" scheme="https://www.yzhu.name/tags/module-architecture/"/>
    
    <category term="deployment" scheme="https://www.yzhu.name/tags/deployment/"/>
    
  </entry>
  
  <entry>
    <title>OIDC &quot;Need Admin Approval&quot; 故障排除与分析</title>
    <link href="https://www.yzhu.name/2025/11/12/OIDC-OAuth2-Need-Admin-Approval/"/>
    <id>https://www.yzhu.name/2025/11/12/OIDC-OAuth2-Need-Admin-Approval/</id>
    <published>2025-11-12T13:12:32.000Z</published>
    <updated>2025-11-12T14:50:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细记录了一次OIDC认证系统中遇到的”Need admin approval”问题。用户在登录时持续收到错误提示，但使用相同令牌的独立工具却能正常工作。经过深入分析，发现问题根源在于OIDC配置中的<code>Authorization Prompt</code>参数设置不当<span id="more"></span>。本文不仅提供了完整的故障排除过程，还包含了OIDC&#x2F;OAuth2.0的基础知识，以帮助不同技术水平的同事理解和解决类似问题。虽然案例基于EspoCRM，但此问题在任何使用OIDC&#x2F;OAuth2.0的系统中都可能遇到。</p><h2 id="1-OIDC-OAuth2-0-基础知识"><a href="#1-OIDC-OAuth2-0-基础知识" class="headerlink" title="1. OIDC&#x2F;OAuth2.0 基础知识"></a>1. OIDC&#x2F;OAuth2.0 基础知识</h2><h3 id="1-1-什么是OIDC？"><a href="#1-1-什么是OIDC？" class="headerlink" title="1.1 什么是OIDC？"></a>1.1 什么是OIDC？</h3><p>OpenID Connect (OIDC) 是建立在OAuth 2.0协议之上的身份验证层，它允许客户端应用程序验证终端用户的身份，并获取基本的用户配置信息。OIDC的主要目标是提供一种简单的方式让应用程序能够验证用户身份。</p><h3 id="1-2-OAuth-2-0-与-OIDC-的关系"><a href="#1-2-OAuth-2-0-与-OIDC-的关系" class="headerlink" title="1.2 OAuth 2.0 与 OIDC 的关系"></a>1.2 OAuth 2.0 与 OIDC 的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐    1.请求访问      ┌──────────────┐</span><br><span class="line">│   客户端应用  │ ────────────────→ │  资源所有者(用户) │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br><span class="line">       │                               │</span><br><span class="line">       │ 2.授权请求                    │</span><br><span class="line">       ▼                               ▼</span><br><span class="line">┌─────────────┐                  ┌──────────────┐</span><br><span class="line">│ 授权服务器  │ ←───────────────→ │  资源服务器   │</span><br><span class="line">│ (如Azure AD) │                  │ (如Graph API) │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br><span class="line">       │                               │</span><br><span class="line">       │ 3.返回访问令牌                │</span><br><span class="line">       ▼                               ▼</span><br><span class="line">┌─────────────┐    4.访问资源      ┌──────────────┐</span><br><span class="line">│   客户端应用  │ ────────────────→ │  资源服务器   │</span><br><span class="line">└─────────────┘                  └──────────────┘</span><br></pre></td></tr></table></figure><h3 id="1-3-OIDC-认证流程时序图"><a href="#1-3-OIDC-认证流程时序图" class="headerlink" title="1.3 OIDC 认证流程时序图"></a>1.3 OIDC 认证流程时序图</h3><pre class="mermaid">sequenceDiagram    participant U as 用户    participant C as 客户端应用    participant AS as 授权服务器    participant RS as 资源服务器    U->>C: 1. 访问应用    C->>U: 2. 重定向到授权服务器    U->>AS: 3. 用户认证    AS->>U: 4. 用户授权同意    U->>C: 5. 重定向回客户端(授权码)    C->>AS: 6. 交换访问令牌    AS->>C: 7. 返回访问令牌    C->>RS: 8. 访问受保护资源    RS->>C: 9. 返回资源数据</pre><p>OIDC认证流程的详细步骤：</p><ol><li>用户访问客户端应用</li><li>客户端应用重定向到授权服务器</li><li>用户在授权服务器进行身份验证</li><li>授权服务器向用户请求授权同意</li><li>用户授权后，重定向回客户端应用（携带授权码）</li><li>客户端应用使用授权码向授权服务器请求访问令牌</li><li>授权服务器返回访问令牌给客户端应用</li><li>客户端应用使用访问令牌访问资源服务器</li><li>资源服务器返回请求的资源数据</li></ol><h3 id="1-4-关键概念"><a href="#1-4-关键概念" class="headerlink" title="1.4 关键概念"></a>1.4 关键概念</h3><h4 id="1-4-1-Scope（权限范围）"><a href="#1-4-1-Scope（权限范围）" class="headerlink" title="1.4.1 Scope（权限范围）"></a>1.4.1 Scope（权限范围）</h4><p>Scope定义了客户端应用请求访问的权限范围：</p><ul><li><code>openid</code>：必需，表示使用OIDC</li><li><code>profile</code>：访问用户基本信息</li><li><code>email</code>：访问用户邮箱</li><li><code>User.Read</code>：读取用户信息（Microsoft Graph）</li><li><code>Group.Read.All</code>：读取所有组信息（需要管理员同意）</li></ul><h4 id="1-4-2-Prompt-参数"><a href="#1-4-2-Prompt-参数" class="headerlink" title="1.4.2 Prompt 参数"></a>1.4.2 Prompt 参数</h4><p>Prompt参数控制授权服务器如何与用户交互：</p><ul><li><code>none</code>：不显示任何UI界面</li><li><code>login</code>：强制用户重新认证</li><li><code>consent</code>：强制显示同意界面</li><li><code>select_account</code>：显示账户选择界面</li></ul><h2 id="2-问题现象"><a href="#2-问题现象" class="headerlink" title="2. 问题现象"></a>2. 问题现象</h2><h3 id="2-1-故障描述"><a href="#2-1-故障描述" class="headerlink" title="2.1 故障描述"></a>2.1 故障描述</h3><p>在任何使用OIDC与身份提供商（如Azure AD、Google、Okta等）集成的系统中，用户通过OIDC登录时遇到以下问题：</p><ul><li>用户尝试登录时，身份提供商显示”Need admin approval”错误</li><li>登录流程中断，用户无法访问系统</li></ul><h3 id="2-2-矛盾现象"><a href="#2-2-矛盾现象" class="headerlink" title="2.2 矛盾现象"></a>2.2 矛盾现象</h3><p>然而，使用相同的访问令牌在独立工具中：</p><ul><li>所有API功能正常工作</li><li>可以成功访问需要高级权限的资源</li><li>权限验证完全通过</li></ul><h2 id="3-故障排查过程"><a href="#3-故障排查过程" class="headerlink" title="3. 故障排查过程"></a>3. 故障排查过程</h2><h3 id="3-1-初步分析（错误方向）"><a href="#3-1-初步分析（错误方向）" class="headerlink" title="3.1 初步分析（错误方向）"></a>3.1 初步分析（错误方向）</h3><p>基于表面现象，我们最初的假设是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OIDC流程失败 → 权限不足 → 需要管理员同意</span><br></pre></td></tr></table></figure><p>尝试的解决方案：</p><ol><li>检查身份提供商中的API权限配置</li><li>移除需要管理员同意的权限范围（如<code>Group.Read.All</code>）</li><li>验证令牌内容和权限范围</li></ol><h3 id="3-2-关键信息澄清"><a href="#3-2-关键信息澄清" class="headerlink" title="3.2 关键信息澄清"></a>3.2 关键信息澄清</h3><p>经过深入沟通，发现了关键事实：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OIDC认证流程中移除需要管理员同意的scope → 认证成功</span><br><span class="line">使用成功获取的令牌 → 能访问高级权限资源（本不应有此权限）</span><br></pre></td></tr></table></figure><p>这让我们意识到问题不在权限范围本身，而在于认证流程的控制机制。</p><h3 id="3-3-突破性发现"><a href="#3-3-突破性发现" class="headerlink" title="3.3 突破性发现"></a>3.3 突破性发现</h3><p>最终发现问题根源在于客户端应用的OIDC配置中的<code>Authorization Prompt</code>参数。</p><h2 id="4-根本原因分析"><a href="#4-根本原因分析" class="headerlink" title="4. 根本原因分析"></a>4. 根本原因分析</h2><h3 id="4-1-问题本质"><a href="#4-1-问题本质" class="headerlink" title="4.1 问题本质"></a>4.1 问题本质</h3><p>问题并非权限缺失，而是OIDC流程控制参数配置不当导致的流程冲突。</p><h3 id="4-2-技术细节"><a href="#4-2-技术细节" class="headerlink" title="4.2 技术细节"></a>4.2 技术细节</h3><h4 id="4-2-1-错误配置：prompt-consent"><a href="#4-2-1-错误配置：prompt-consent" class="headerlink" title="4.2.1 错误配置：prompt=consent"></a>4.2.1 错误配置：<code>prompt=consent</code></h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET https://login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?</span><br><span class="line">  client_id=&#123;client_id&#125;&amp;</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  redirect_uri=&#123;redirect_uri&#125;&amp;</span><br><span class="line">  scope=openid profile email User.Read Group.Read.All&amp;</span><br><span class="line">  prompt=consent  // 问题根源</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：强制显示权限同意界面<br><strong>冲突</strong>：租户策略禁止普通用户执行同意操作</p><h4 id="4-2-2-正确配置：prompt-select-account"><a href="#4-2-2-正确配置：prompt-select-account" class="headerlink" title="4.2.2 正确配置：prompt=select_account"></a>4.2.2 正确配置：<code>prompt=select_account</code></h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET https://login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?</span><br><span class="line">  client_id=&#123;client_id&#125;&amp;</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  redirect_uri=&#123;redirect_uri&#125;&amp;</span><br><span class="line">  scope=openid profile email User.Read Group.Read.All&amp;</span><br><span class="line">  prompt=select_account  // 正确配置</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：智能检查权限状态，已满足则跳过同意界面</p><h3 id="4-3-流程对比"><a href="#4-3-流程对比" class="headerlink" title="4.3 流程对比"></a>4.3 流程对比</h3><h4 id="4-3-1-错误流程"><a href="#4-3-1-错误流程" class="headerlink" title="4.3.1 错误流程"></a>4.3.1 错误流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 → 客户端应用 → 身份提供商 (prompt=consent) → 显示同意界面 → 用户无法操作 → 失败</span><br></pre></td></tr></table></figure><h4 id="4-3-2-正确流程"><a href="#4-3-2-正确流程" class="headerlink" title="4.3.2 正确流程"></a>4.3.2 正确流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 → 客户端应用 → 身份提供商 (prompt=select_account) → 检查权限 → 已满足 → 颁发令牌 → 成功</span><br></pre></td></tr></table></figure><h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. 解决方案</h2><h3 id="5-1-通用解决步骤"><a href="#5-1-通用解决步骤" class="headerlink" title="5.1 通用解决步骤"></a>5.1 通用解决步骤</h3><h4 id="步骤1：检查应用配置"><a href="#步骤1：检查应用配置" class="headerlink" title="步骤1：检查应用配置"></a>步骤1：检查应用配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录客户端应用管理后台</span><br></pre></td></tr></table></figure><h4 id="步骤2：找到OIDC配置"><a href="#步骤2：找到OIDC配置" class="headerlink" title="步骤2：找到OIDC配置"></a>步骤2：找到OIDC配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导航到身份验证或认证设置</span><br><span class="line">找到OIDC相关配置</span><br></pre></td></tr></table></figure><h4 id="步骤3：修改Authorization-Prompt参数"><a href="#步骤3：修改Authorization-Prompt参数" class="headerlink" title="步骤3：修改Authorization Prompt参数"></a>步骤3：修改Authorization Prompt参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到&quot;Authorization Prompt&quot;字段</span><br><span class="line">将值从&quot;consent&quot;修改为&quot;select_account&quot;</span><br></pre></td></tr></table></figure><h4 id="步骤4：保存配置"><a href="#步骤4：保存配置" class="headerlink" title="步骤4：保存配置"></a>步骤4：保存配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">点击保存按钮</span><br><span class="line">配置立即生效</span><br></pre></td></tr></table></figure><h3 id="5-2-验证结果"><a href="#5-2-验证结果" class="headerlink" title="5.2 验证结果"></a>5.2 验证结果</h3><p>修改后，OIDC登录流程恢复正常：</p><ul><li>用户可以正常登录系统</li><li>不再显示”Need admin approval”错误</li><li>系统可以正常访问受保护的API资源</li></ul><h2 id="6-技术深度解析"><a href="#6-技术深度解析" class="headerlink" title="6. 技术深度解析"></a>6. 技术深度解析</h2><h3 id="6-1-Prompt参数详解"><a href="#6-1-Prompt参数详解" class="headerlink" title="6.1 Prompt参数详解"></a>6.1 Prompt参数详解</h3><h4 id="6-1-1-prompt-none"><a href="#6-1-1-prompt-none" class="headerlink" title="6.1.1 prompt=none"></a>6.1.1 <code>prompt=none</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于后台静默认证</span></span><br><span class="line"><span class="comment">// 如果需要用户交互，立即返回错误</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-1-2-prompt-login"><a href="#6-1-2-prompt-login" class="headerlink" title="6.1.2 prompt=login"></a>6.1.2 <code>prompt=login</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制用户重新输入凭据</span></span><br><span class="line"><span class="comment">// 适用于高安全要求场景</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;login&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-1-3-prompt-consent"><a href="#6-1-3-prompt-consent" class="headerlink" title="6.1.3 prompt=consent"></a>6.1.3 <code>prompt=consent</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制显示同意界面</span></span><br><span class="line"><span class="comment">// 适用于需要用户明确授权的场景</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;consent&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-1-4-prompt-select-account"><a href="#6-1-4-prompt-select-account" class="headerlink" title="6.1.4 prompt=select_account"></a>6.1.4 <code>prompt=select_account</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示账户选择界面，智能处理权限</span></span><br><span class="line"><span class="comment">// 最佳实践配置</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://login.microsoftonline.com/tenant/oauth2/v2.0/authorize&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;select_account&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2-权限同意机制"><a href="#6-2-权限同意机制" class="headerlink" title="6.2 权限同意机制"></a>6.2 权限同意机制</h3><h4 id="6-2-1-管理员同意"><a href="#6-2-1-管理员同意" class="headerlink" title="6.2.1 管理员同意"></a>6.2.1 管理员同意</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理员在身份提供商管理门户中为应用授予权限</span></span><br><span class="line"><span class="comment">// 适用于需要高权限的scope</span></span><br><span class="line"><span class="comment">// 一次设置，全局生效</span></span><br></pre></td></tr></table></figure><h4 id="6-2-2-用户同意"><a href="#6-2-2-用户同意" class="headerlink" title="6.2.2 用户同意"></a>6.2.2 用户同意</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通用户在认证时同意权限请求</span></span><br><span class="line"><span class="comment">// 适用于基本权限</span></span><br><span class="line"><span class="comment">// 受租户策略限制</span></span><br></pre></td></tr></table></figure><h3 id="6-3-不同平台的配置示例"><a href="#6-3-不同平台的配置示例" class="headerlink" title="6.3 不同平台的配置示例"></a>6.3 不同平台的配置示例</h3><h4 id="6-3-1-EspoCRM"><a href="#6-3-1-EspoCRM" class="headerlink" title="6.3.1 EspoCRM"></a>6.3.1 EspoCRM</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Administration &gt; Authentication &gt; OIDC</span></span><br><span class="line"><span class="comment">// Authorization Prompt: select_account</span></span><br></pre></td></tr></table></figure><h4 id="6-3-2-Django应用"><a href="#6-3-2-Django应用" class="headerlink" title="6.3.2 Django应用"></a>6.3.2 Django应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_REDIRECT_URL = <span class="string">&#x27;/dashboard/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_ERROR_URL = <span class="string">&#x27;/login/error/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_LOGIN_URL = <span class="string">&#x27;/login/&#x27;</span></span><br><span class="line">SOCIAL_AUTH_OAUTH2_SCOPE = [<span class="string">&#x27;openid&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;email&#x27;</span>]</span><br><span class="line">SOCIAL_AUTH_OAUTH2_PROMPT = <span class="string">&#x27;select_account&#x27;</span>  <span class="comment"># 关键配置</span></span><br></pre></td></tr></table></figure><h4 id="6-3-3-Node-js应用-Passport-js"><a href="#6-3-3-Node-js应用-Passport-js" class="headerlink" title="6.3.3 Node.js应用 (Passport.js)"></a>6.3.3 Node.js应用 (Passport.js)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">&#x27;passport&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OIDCStrategy</span> = <span class="built_in">require</span>(<span class="string">&#x27;passport-azure-ad&#x27;</span>).<span class="property">OIDCStrategy</span>;</span><br><span class="line"></span><br><span class="line">passport.<span class="title function_">use</span>(<span class="keyword">new</span> <span class="title class_">OIDCStrategy</span>(&#123;</span><br><span class="line">  <span class="attr">identityMetadata</span>: config.<span class="property">creds</span>.<span class="property">identityMetadata</span>,</span><br><span class="line">  <span class="attr">clientID</span>: config.<span class="property">creds</span>.<span class="property">clientID</span>,</span><br><span class="line">  <span class="attr">redirectUrl</span>: config.<span class="property">creds</span>.<span class="property">redirectUrl</span>,</span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;code&#x27;</span>,</span><br><span class="line">  <span class="attr">responseMode</span>: <span class="string">&#x27;form_post&#x27;</span>,</span><br><span class="line">  <span class="attr">scope</span>: [<span class="string">&#x27;openid&#x27;</span>, <span class="string">&#x27;profile&#x27;</span>, <span class="string">&#x27;email&#x27;</span>],</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;select_account&#x27;</span>,  <span class="comment">// 关键配置</span></span><br><span class="line">  <span class="attr">loggingLevel</span>: <span class="string">&#x27;info&#x27;</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">iss, sub, profile, accessToken, refreshToken, done</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理认证成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">done</span>(<span class="literal">null</span>, profile);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="6-3-4-Spring-Boot应用"><a href="#6-3-4-Spring-Boot应用" class="headerlink" title="6.3.4 Spring Boot应用"></a>6.3.4 Spring Boot应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.yml</span></span><br><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      client:</span><br><span class="line">        registration:</span><br><span class="line">          azure:</span><br><span class="line">            client-id: $&#123;AZURE_CLIENT_ID&#125;</span><br><span class="line">            client-secret: $&#123;AZURE_CLIENT_SECRET&#125;</span><br><span class="line">            provider: azure</span><br><span class="line">            scope: openid,profile,email</span><br><span class="line">            authorization-uri: https:<span class="comment">//login.microsoftonline.com/&#123;tenant&#125;/oauth2/v2.0/authorize?prompt=select_account  // 关键配置</span></span><br><span class="line">        provider:</span><br><span class="line">          azure:</span><br><span class="line">            issuer-uri: https:<span class="comment">//login.microsoftonline.com/&#123;tenant&#125;/v2.0</span></span><br></pre></td></tr></table></figure><h2 id="7-经验教训"><a href="#7-经验教训" class="headerlink" title="7. 经验教训"></a>7. 经验教训</h2><h3 id="7-1-技术层面"><a href="#7-1-技术层面" class="headerlink" title="7.1 技术层面"></a>7.1 技术层面</h3><ol><li><strong>Prompt参数的重要性</strong>：在OIDC&#x2F;OAuth2.0问题排查中，prompt参数应作为首要检查点</li><li><strong>权限的多层次性</strong>：理解管理员同意、用户同意和应用注册之间的区别</li><li><strong>流程控制vs权限范围</strong>：区分流程控制参数和权限范围参数的作用</li></ol><h3 id="7-2-诊断方法"><a href="#7-2-诊断方法" class="headerlink" title="7.2 诊断方法"></a>7.2 诊断方法</h3><ol><li><strong>准确描述问题</strong>：问题的准确描述对诊断至关重要</li><li><strong>逐步排除假设</strong>：从表象到本质，逐步排除错误假设</li><li><strong>关注IdP策略</strong>：同时考虑应用端配置和IdP端策略</li></ol><h3 id="7-3-最佳实践"><a href="#7-3-最佳实践" class="headerlink" title="7.3 最佳实践"></a>7.3 最佳实践</h3><ol><li><strong>默认使用<code>select_account</code></strong>：除非有特殊需求，否则推荐使用<code>select_account</code></li><li><strong>权限最小化原则</strong>：只请求必需的权限范围</li><li><strong>定期审查配置</strong>：定期检查OIDC配置参数的合理性</li></ol><h2 id="8-预防措施"><a href="#8-预防措施" class="headerlink" title="8. 预防措施"></a>8. 预防措施</h2><h3 id="8-1-配置检查清单"><a href="#8-1-配置检查清单" class="headerlink" title="8.1 配置检查清单"></a>8.1 配置检查清单</h3><ul><li><input disabled type="checkbox"> Authorization Prompt参数设置为<code>select_account</code></li><li><input disabled type="checkbox"> Scope只包含必需的权限范围</li><li><input disabled type="checkbox"> 管理员同意已正确授予</li><li><input disabled type="checkbox"> 重定向URI配置正确</li><li><input disabled type="checkbox"> 客户端密钥安全存储</li></ul><h3 id="8-2-监控建议"><a href="#8-2-监控建议" class="headerlink" title="8.2 监控建议"></a>8.2 监控建议</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控OIDC登录失败日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/application/oidc.log | grep <span class="string">&quot;admin approval&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查身份提供商审计日志</span></span><br><span class="line"><span class="comment"># 具体命令根据不同的IdP而异</span></span><br></pre></td></tr></table></figure><h3 id="8-3-故障恢复预案"><a href="#8-3-故障恢复预案" class="headerlink" title="8.3 故障恢复预案"></a>8.3 故障恢复预案</h3><ol><li><strong>快速回滚</strong>：准备配置回滚方案</li><li><strong>备用登录</strong>：确保有备用登录方式</li><li><strong>用户通知</strong>：及时通知用户故障状态</li></ol><h2 id="9-不同身份提供商的特殊考虑"><a href="#9-不同身份提供商的特殊考虑" class="headerlink" title="9. 不同身份提供商的特殊考虑"></a>9. 不同身份提供商的特殊考虑</h2><h3 id="9-1-Azure-AD"><a href="#9-1-Azure-AD" class="headerlink" title="9.1 Azure AD"></a>9.1 Azure AD</h3><ul><li>管理员同意通过Azure门户配置</li><li>支持<code>prompt</code>参数</li><li>需要正确配置API权限</li></ul><h3 id="9-2-Google-Identity"><a href="#9-2-Google-Identity" class="headerlink" title="9.2 Google Identity"></a>9.2 Google Identity</h3><ul><li>通过Google Cloud Console管理</li><li>同样涉及管理员同意流程</li><li>配置方式略有不同</li></ul><h3 id="9-3-Okta"><a href="#9-3-Okta" class="headerlink" title="9.3 Okta"></a>9.3 Okta</h3><ul><li>通过Admin Console配置</li><li>支持类似的prompt机制</li><li>需要配置应用权限</li></ul><h3 id="9-4-Keycloak"><a href="#9-4-Keycloak" class="headerlink" title="9.4 Keycloak"></a>9.4 Keycloak</h3><ul><li>通过管理控制台配置</li><li>支持自定义认证流程</li><li>需要配置客户端范围</li></ul><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>这次故障排除过程展示了复杂认证问题的典型特征：</p><ol><li><strong>表象与本质的差异</strong>：表面看似权限问题，实际是流程控制问题</li><li><strong>多层因素影响</strong>：涉及应用配置、IdP策略、用户权限等多个层面</li><li><strong>诊断的重要性</strong>：准确的问题描述和逐步排查是解决问题的关键</li></ol><p>这个问题在任何使用OIDC&#x2F;OAuth2.0的系统中都可能遇到，特别是在以下场景：</p><ul><li>企业环境中，租户策略较为严格</li><li>应用需要访问需要管理员同意的高级权限</li><li>配置参数设置不当</li></ul><p>通过这次经验，我们不仅解决了具体问题，还加深了对OIDC&#x2F;OAuth2.0协议的理解，为未来处理类似问题积累了宝贵经验。</p><h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11. 参考资料"></a>11. 参考资料</h2><ol><li><a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Specification</a></li><li><a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 Authorization Framework</a></li><li><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/">Microsoft Identity Platform Documentation</a></li><li><a href="https://developers.google.com/identity/">Google Identity Platform Documentation</a></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详细记录了一次OIDC认证系统中遇到的”Need admin approval”问题。用户在登录时持续收到错误提示，但使用相同令牌的独立工具却能正常工作。经过深入分析，发现问题根源在于OIDC配置中的&lt;code&gt;Authorization Prompt&lt;/code&gt;参数设置不当&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>EspoCRM 选型记录：约束、PoC 与总成本核算</title>
    <link href="https://www.yzhu.name/2025/10/26/espocrm/00-why-espocrm/"/>
    <id>https://www.yzhu.name/2025/10/26/espocrm/00-why-espocrm/</id>
    <published>2025-10-26T00:00:00.000Z</published>
    <updated>2025-10-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>适用场景：中小团队、需要定制开发、偏好自托管&#x2F;私有部署</p></blockquote><p>选择 CRM 不是选“功能最强的”，而是选“在你约束下长期最省心的”。很多团队选型翻车，不是因为功能不够，而是因为忽略了三件事：<strong>定制成本、运维成本、合规成本</strong>。本文给出一套可复用的选型方法，并用 EspoCRM 做一次完整落地。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li><strong>选型核心</strong>：先锁定“非妥协需求”，再做 PoC（概念验证）与成本核算</li><li><strong>最终选择</strong>：EspoCRM 9.2.2+ 开源版（自托管）</li><li><strong>关键理由</strong>：元数据驱动、升级可控、扩展点清晰、社区活跃</li><li><strong>提前警告</strong>：AGPLv3 合规 + 中文本地化 + 报表&#x2F;移动端短板要提前设计兜底</li></ul><hr><h2 id="1-选型核心维度"><a href="#1-选型核心维度" class="headerlink" title="1. 选型核心维度"></a>1. 选型核心维度</h2><p>选择 CRM 前，先明确你的“非妥协需求”（不满足就直接淘汰），避免陷入“看功能列表越看越爽”的幻觉。</p><table><thead><tr><th align="left">维度</th><th align="left">说明</th><th align="left">推荐取向</th></tr></thead><tbody><tr><td align="left"><strong>功能覆盖</strong></td><td align="left">客户管理、商机、销售漏斗、日历、任务</td><td align="left">✅ 基础 CRM 功能</td></tr><tr><td align="left"><strong>定制能力</strong></td><td align="left">能否二次开发、扩展性如何</td><td align="left">✅ 必须支持深度定制</td></tr><tr><td align="left"><strong>部署方式</strong></td><td align="left">SaaS vs 自托管</td><td align="left">✅ 必须支持私有部署</td></tr><tr><td align="left"><strong>成本</strong></td><td align="left">许可费、服务器成本、开发成本</td><td align="left">✅ 开源免费为主</td></tr><tr><td align="left"><strong>技术栈</strong></td><td align="left">开发语言、框架、数据库</td><td align="left">⚠️ 不做硬性限制</td></tr><tr><td align="left"><strong>社区活跃度</strong></td><td align="left">更新频率、问题解决速度</td><td align="left">✅ 活跃维护</td></tr></tbody></table><p>很多团队漏掉但“后期一定会咬你”的维度：</p><table><thead><tr><th align="left">维度</th><th align="left">为什么关键</th></tr></thead><tbody><tr><td align="left"><strong>权限模型</strong></td><td align="left">组织架构、数据隔离、字段级&#x2F;记录级权限决定能否落地</td></tr><tr><td align="left"><strong>审计与合规</strong></td><td align="left">操作日志、数据导出控制、留存策略影响风控与合规</td></tr><tr><td align="left"><strong>数据迁移</strong></td><td align="left">Excel&#x2F;旧系统导入、字段映射、去重策略常常是项目的主战场</td></tr><tr><td align="left"><strong>集成能力</strong></td><td align="left">邮件、日历、IM、呼叫中心、财务系统对接决定“是不是工具孤岛”</td></tr></tbody></table><h3 id="1-1-选型流程（可复用模板）"><a href="#1-1-选型流程（可复用模板）" class="headerlink" title="1.1 选型流程（可复用模板）"></a>1.1 选型流程（可复用模板）</h3><p>把“选型”当一个小项目做，效率反而更高：</p><ol><li><strong>列清单</strong>：写下 10 条非妥协需求 + 10 条可妥协需求</li><li><strong>拉候选</strong>：3-5 个产品即可（太多只会把精力浪费在表格上）</li><li><strong>做 PoC</strong>：用真实业务跑通 3 条关键流程（线索→商机→成交；客户→活动→跟进；导入→分配→权限）</li><li><strong>算总成本</strong>：一年内人力（开发&#x2F;运维&#x2F;培训）+ 服务器 + 机会成本</li><li><strong>做合规评估</strong>：尤其是许可证（如 AGPL）与数据安全边界</li></ol><h3 id="1-2-技术栈：为什么-Java-背景也可能选择-PHP"><a href="#1-2-技术栈：为什么-Java-背景也可能选择-PHP" class="headerlink" title="1.2 技术栈：为什么 Java 背景也可能选择 PHP"></a>1.2 技术栈：为什么 Java 背景也可能选择 PHP</h3><p>如果你的团队偏 <strong>Java 背景</strong>，起初可能也会优先看 Java 技术栈的 CRM（例如 Apache OFBiz 等）。但在 CRM 这类”产品复杂度极高”的系统里，<strong>技术栈匹配往往不是第一优先级</strong>。</p><p>AI 编程助手的普及进一步降低了语言切换成本，但它解决的是“语法与样板”，不是“架构理解与可维护性”。真正应该优先关心的，是产品本身是否成熟、扩展点是否清晰、升级是否可控，而不是“我团队会不会写 PHP”。</p><p><strong>为什么不把语言当硬门槛</strong>：</p><table><thead><tr><th align="left">评估项</th><th align="left">Java CRM</th><th align="center">EspoCRM (PHP)</th></tr></thead><tbody><tr><td align="left"><strong>学习曲线</strong></td><td align="left">Java 开发者上手快，但 CRM 本身复杂</td><td align="center">PHP 语法简单，通常数天内可完成基本上手</td></tr><tr><td align="left"><strong>部署成本</strong></td><td align="left">JVM + 应用服务器，资源占用高</td><td align="center">传统 LAMP 堆栈，资源占用相对可控</td></tr><tr><td align="left"><strong>定制友好</strong></td><td align="left">框架厚重，改一行代码可能牵一发动全身</td><td align="center">元数据驱动，大部分定制只需改配置</td></tr><tr><td align="left"><strong>维护成本</strong></td><td align="left">依赖多，升级复杂</td><td align="center">依赖少，升级友好</td></tr></tbody></table><p><strong>核心决策</strong>：</p><blockquote><p><strong>“选产品本质，不是选语言。”</strong> 一个优秀的 PHP CRM，往往胜过一个不成熟的同类产品。</p></blockquote><p>实践中更稳妥的策略是：优先选成熟产品，再解决语言与工程体系的适配问题。</p><hr><h2 id="2-对比样本：Twenty-CRM-vs-EspoCRM-vs-OFBiz"><a href="#2-对比样本：Twenty-CRM-vs-EspoCRM-vs-OFBiz" class="headerlink" title="2. 对比样本：Twenty CRM vs EspoCRM vs OFBiz"></a>2. 对比样本：Twenty CRM vs EspoCRM vs OFBiz</h2><p>这里用三款代表性产品做样本：<strong>Twenty CRM</strong>（新兴现代）、<strong>EspoCRM</strong>（成熟稳定）、<strong>Apache OFBiz</strong>（企业级 Java 框架）。</p><h3 id="2-1-对比总览"><a href="#2-1-对比总览" class="headerlink" title="2.1 对比总览"></a>2.1 对比总览</h3><table><thead><tr><th align="left">产品</th><th align="left">技术栈</th><th align="center">成熟度</th><th align="left">定制难度</th><th align="left">部署复杂度</th><th align="center">最终选择</th></tr></thead><tbody><tr><td align="left"><strong>EspoCRM</strong></td><td align="left">PHP + MySQL + JS</td><td align="center">⭐⭐⭐⭐⭐</td><td align="left">⭐⭐ 容易</td><td align="left">⭐⭐ 简单</td><td align="center">✅</td></tr><tr><td align="left">Twenty CRM</td><td align="left">React + NestJS + PG</td><td align="center">⭐⭐⭐</td><td align="left">⭐⭐ 容易</td><td align="left">⭐⭐⭐⭐ 复杂</td><td align="center">❌</td></tr><tr><td align="left">Apache OFBiz</td><td align="left">Java + PostgreSQL</td><td align="center">⭐⭐⭐⭐</td><td align="left">⭐⭐⭐⭐ 困难</td><td align="left">⭐⭐⭐⭐⭐ 复杂</td><td align="center">❌</td></tr></tbody></table><h3 id="2-2-Twenty-CRM：看起来很美，但太新"><a href="#2-2-Twenty-CRM：看起来很美，但太新" class="headerlink" title="2.2 Twenty CRM：看起来很美，但太新"></a>2.2 Twenty CRM：看起来很美，但太新</h3><p>Twenty CRM 是 2022 年启动的新项目，技术栈非常现代（React + NestJS + TypeScript），界面精美，架构设计优秀。</p><table><thead><tr><th align="left">对比项</th><th align="left">Twenty CRM</th><th align="left">问题</th></tr></thead><tbody><tr><td align="left"><strong>技术栈</strong></td><td align="left">React + NestJS + PostgreSQL</td><td align="left">需要全栈 JS&#x2F;TS 能力</td></tr><tr><td align="left"><strong>成熟度</strong></td><td align="left">快速迭代中</td><td align="left">版本演进快，兼容性需要自己验证</td></tr><tr><td align="left"><strong>文档</strong></td><td align="left">英文为主，覆盖有限</td><td align="left">遇到问题难以找到答案</td></tr><tr><td align="left"><strong>社区</strong></td><td align="left">GitHub 活跃</td><td align="left">实际用户少</td></tr><tr><td align="left"><strong>功能完整性</strong></td><td align="left">核心功能齐全</td><td align="left">高级功能（报表、工作流）尚在开发</td></tr></tbody></table><p><strong>结论</strong>：Twenty CRM 代表未来方向，值得持续关注。但当前阶段作为生产系统使用风险较大 —— 你不希望成为早期踩坑的用户。</p><h3 id="2-3-Apache-OFBiz：强大但笨重"><a href="#2-3-Apache-OFBiz：强大但笨重" class="headerlink" title="2.3 Apache OFBiz：强大但笨重"></a>2.3 Apache OFBiz：强大但笨重</h3><p>Apache OFBiz 是 Apache 基金会的企业级 ERP&#x2F;CRM 框架，功能极其强大，但学习曲线陡峭。</p><table><thead><tr><th align="left">对比项</th><th align="left">Apache OFBiz</th><th align="left">问题</th></tr></thead><tbody><tr><td align="left"><strong>技术栈</strong></td><td align="left">Java + PostgreSQL</td><td align="left">技术栈匹配 ✅</td></tr><tr><td align="left"><strong>功能</strong></td><td align="left">ERP + CRM + 电商全都有</td><td align="left">功能过于庞大，用不上</td></tr><tr><td align="left"><strong>架构</strong></td><td align="left">组件化，高度可配置</td><td align="left">概念复杂，学习成本极高</td></tr><tr><td align="left"><strong>界面</strong></td><td align="left">传统企业风，可定制</td><td align="left">UI 现代化需要大量投入</td></tr><tr><td align="left"><strong>文档</strong></td><td align="left">官方文档详细</td><td align="left">文档组织混乱，新手迷失</td></tr><tr><td align="left"><strong>部署</strong></td><td align="left">JVM + Tomcat + 数据库</td><td align="left">资源占用高，运维复杂</td></tr></tbody></table><p><strong>结论</strong>：OFBiz 适合大型企业的复杂 ERP 需求。对于只需要 CRM 的团队，杀鸡用牛刀，维护成本过高。</p><h3 id="2-4-EspoCRM：成熟稳定，定制友好"><a href="#2-4-EspoCRM：成熟稳定，定制友好" class="headerlink" title="2.4 EspoCRM：成熟稳定，定制友好"></a>2.4 EspoCRM：成熟稳定，定制友好</h3><p>EspoCRM 发布于 2014 年，经过 10+ 年发展，已经非常成熟。</p><table><thead><tr><th align="left">对比项</th><th align="left">EspoCRM</th><th align="left">优势</th></tr></thead><tbody><tr><td align="left"><strong>技术栈</strong></td><td align="left">PHP + MySQL + JS</td><td align="left">PHP 简单，跨语言上手成本可控</td></tr><tr><td align="left"><strong>成熟度</strong></td><td align="left">10+ 年历史</td><td align="left">稳定可靠，破坏性更新少</td></tr><tr><td align="left"><strong>架构</strong></td><td align="left">元数据驱动 + 模块化</td><td align="left">大部分定制只需改配置文件</td></tr><tr><td align="left"><strong>文档</strong></td><td align="left">官方文档完善</td><td align="left">社区贡献多，问题能找到答案</td></tr><tr><td align="left"><strong>社区</strong></td><td align="left">GitHub 活跃，全球用户</td><td align="left">商业支持可选，社区免费支持也够用</td></tr><tr><td align="left"><strong>部署</strong></td><td align="left">传统 LAMP 堆栈</td><td align="left">部署路径清晰，运维成本可控</td></tr></tbody></table><p><strong>结论</strong>：EspoCRM 在成熟度、定制友好性、运维成本之间达到了最佳平衡。</p><blockquote><p><strong>关于语言</strong>：EspoCRM 官方以英语为主，中文本地化相对弱。如果你的用户需要强中文支持，可能需要额外投入做本地化或维护语言包覆盖。</p></blockquote><h3 id="2-5-决策矩阵"><a href="#2-5-决策矩阵" class="headerlink" title="2.5 决策矩阵"></a>2.5 决策矩阵</h3><p>说明：下面的打分是基于本文开头的“非妥协需求”（可自托管、可深度定制、成本可控、可维护）以及我对三款产品的试用与资料调研做的主观评分。你在自己的 PoC 阶段，建议按业务关键流程重新打分，别照抄星星。</p><table><thead><tr><th align="left">评估维度</th><th align="center">Twenty CRM</th><th align="center">EspoCRM</th><th align="center">OFBiz</th></tr></thead><tbody><tr><td align="left"><strong>短期上线</strong></td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐</td></tr><tr><td align="left"><strong>长期维护</strong></td><td align="center">⭐⭐</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐⭐</td></tr><tr><td align="left"><strong>定制效率</strong></td><td align="center">⭐⭐</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐</td></tr><tr><td align="left"><strong>团队适应</strong></td><td align="center">⭐⭐⭐</td><td align="center">⭐⭐⭐</td><td align="center">⭐⭐⭐</td></tr><tr><td align="left"><strong>运维成本</strong></td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐</td></tr><tr><td align="left"><strong>风险可控</strong></td><td align="center">⭐⭐</td><td align="center">⭐⭐⭐⭐⭐</td><td align="center">⭐⭐⭐</td></tr></tbody></table><p><strong>最终选择：EspoCRM</strong></p><h3 id="2-6-其他常见开源-CRM（快速扫一眼）"><a href="#2-6-其他常见开源-CRM（快速扫一眼）" class="headerlink" title="2.6 其他常见开源 CRM（快速扫一眼）"></a>2.6 其他常见开源 CRM（快速扫一眼）</h3><p>如果你想把候选池拉大，下面这些名字几乎绕不开。这里不做结论，只给你“适合什么&#x2F;要注意什么”，方便你快速决定要不要纳入 PoC。</p><table><thead><tr><th align="left">产品</th><th align="left">适合什么</th><th align="left">要注意什么</th></tr></thead><tbody><tr><td align="left"><strong>SuiteCRM</strong></td><td align="left">偏传统 CRM 形态、对“开源老牌生态”有偏好、能接受较传统的 UI</td><td align="left">定制与升级成本需要提前评估，别只看功能列表</td></tr><tr><td align="left"><strong>Vtiger</strong></td><td align="left">需要更“产品化”的现成能力、愿意考虑商业支持&#x2F;付费版路线</td><td align="left">开源版与商业版边界要看清楚，避免选到后期被能力卡死</td></tr><tr><td align="left"><strong>Dolibarr</strong></td><td align="left">更偏“轻量 ERP&#x2F;进销存 + CRM”的场景，小团队想一套系统覆盖更多模块</td><td align="left">CRM 深度可能不如专门 CRM，复杂销售流程要先做 PoC 验证</td></tr></tbody></table><hr><h2 id="3-最终选择-EspoCRM-的关键理由"><a href="#3-最终选择-EspoCRM-的关键理由" class="headerlink" title="3. 最终选择 EspoCRM 的关键理由"></a>3. 最终选择 EspoCRM 的关键理由</h2><h3 id="3-1-代码质量与架构"><a href="#3-1-代码质量与架构" class="headerlink" title="3.1 代码质量与架构"></a>3.1 代码质量与架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">├── 元数据驱动：大部分定制只需改配置，不改代码</span><br><span class="line">├── 模块化架构：custom/ 目录隔离，可升级</span><br><span class="line">├── 清晰的扩展点：Formula → Dynamic Logic → Hook → Service</span><br><span class="line">├── RESTful API：完善的 API 设计，易于集成</span><br><span class="line">└── 前端技术栈稳定：Backbone.js + Handlebars，二次开发路径清晰</span><br></pre></td></tr></table></figure><h3 id="3-2-定制友好性"><a href="#3-2-定制友好性" class="headerlink" title="3.2 定制友好性"></a>3.2 定制友好性</h3><p>EspoCRM 对开发者非常友好：</p><ul><li><strong>元数据驱动</strong>：entityDefs、clientDefs、scopes 等配置文件控制大部分行为</li><li><strong>rebuild 机制</strong>：修改元数据后执行 rebuild，系统自动生成&#x2F;更新表结构</li><li><strong>模块隔离</strong>：<code>custom/Espo/Modules/</code> 下的改动不影响核心升级</li><li><strong>丰富的 Hook</strong>：BeforeSave、AfterSave、BeforeDelete 等拦截数据操作</li></ul><h3 id="3-3-社区与文档"><a href="#3-3-社区与文档" class="headerlink" title="3.3 社区与文档"></a>3.3 社区与文档</h3><ul><li><strong>GitHub 活跃</strong>：持续更新，issue 响应及时</li><li><strong>官方文档</strong>：涵盖开发、定制、API</li><li><strong>社区论坛</strong>：全球用户分享经验</li><li><strong>中文资源</strong>：国内有少量实践案例（正在增长）</li></ul><h3 id="3-4-部署与运维"><a href="#3-4-部署与运维" class="headerlink" title="3.4 部署与运维"></a>3.4 部署与运维</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  -e ESPOCRM_DATABASE_HOST=<span class="string">&quot;&lt;DB_HOST&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_DATABASE_USER=<span class="string">&quot;&lt;DB_USER&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_DATABASE_PASSWORD=<span class="string">&quot;&lt;DB_PASSWORD&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_ADMIN_USER=<span class="string">&quot;&lt;ADMIN_USER&gt;&quot;</span> \</span><br><span class="line">  -e ESPOCRM_ADMIN_PASSWORD=<span class="string">&quot;&lt;ADMIN_PASSWORD&gt;&quot;</span> \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  espocrm/espocrm</span><br></pre></td></tr></table></figure><ul><li>支持 Docker 部署</li><li>支持 PHP 8.2 - 8.4</li><li>支持 MySQL 8.0+ 或 MariaDB 10.3+（也支持 PostgreSQL 15+）</li><li>资源占用相对可控，小规模可从低配起步，按并发与数据量扩容</li></ul><hr><h2 id="4-EspoCRM-的局限与规避"><a href="#4-EspoCRM-的局限与规避" class="headerlink" title="4. EspoCRM 的局限与规避"></a>4. EspoCRM 的局限与规避</h2><h3 id="4-1-已知局限"><a href="#4-1-已知局限" class="headerlink" title="4.1 已知局限"></a>4.1 已知局限</h3><table><thead><tr><th align="left">局限</th><th align="left">说明</th><th align="left">影响</th></tr></thead><tbody><tr><td align="left"><strong>移动端较弱</strong></td><td align="left">移动版功能有限</td><td align="left">外勤多需要额外适配</td></tr><tr><td align="left"><strong>报表功能基础</strong></td><td align="left">内置报表较简单</td><td align="left">复杂报表需要二次开发</td></tr><tr><td align="left"><strong>中文本地化</strong></td><td align="left">官方中文支持有限</td><td align="left">需要自己翻译语言包</td></tr><tr><td align="left"><strong>高级功能付费</strong></td><td align="left">高级功能在付费版中</td><td align="left">如需某些功能需购买</td></tr><tr><td align="left"><strong>许可约束（AGPL）</strong></td><td align="left">以 AGPLv3 发布</td><td align="left">修改后供用户通过网络使用时需履行源码提供义务</td></tr></tbody></table><h3 id="4-2-规避方式"><a href="#4-2-规避方式" class="headerlink" title="4.2 规避方式"></a>4.2 规避方式</h3><p><strong>移动端弱</strong> → 使用响应式布局 + PWA，或对接移动端入口（企业 IM&#x2F;门户等）</p><p><strong>报表功能基础</strong> →：</p><ul><li>使用 BI 工具（Metabase、Superset）直连数据库</li><li>自定义 API 导出数据到 Excel&#x2F;BI 系统</li></ul><p><strong>高级功能付费</strong> →：</p><ul><li>大部分功能可以通过定制开发实现</li><li>本系列文章给出一套“开源版可落地”的扩展路径</li></ul><p><strong>许可约束（AGPL）</strong> →：</p><ul><li>在立项&#x2F;PoC 阶段明确：是否会修改源码（或形成衍生作品）、哪些用户会通过网络访问系统</li><li>若触发 AGPL 义务，预留源码提供与法律声明的交付路径；必要时评估商业许可或官方付费方案</li></ul><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h3 id="5-1-选择-EspoCRM-的核心原因"><a href="#5-1-选择-EspoCRM-的核心原因" class="headerlink" title="5.1 选择 EspoCRM 的核心原因"></a>5.1 选择 EspoCRM 的核心原因</h3><ol><li><strong>架构现代</strong>：元数据驱动 + 模块化，长期可维护</li><li><strong>定制友好</strong>：丰富的扩展点，开发效率高</li><li><strong>成本可控</strong>：开源免费，自托管无许可费</li><li><strong>社区活跃</strong>：持续更新，问题能找到答案</li><li><strong>部署简单</strong>：Docker 一键启动，运维成本低</li></ol><h3 id="5-2-适合人群"><a href="#5-2-适合人群" class="headerlink" title="5.2 适合人群"></a>5.2 适合人群</h3><p>EspoCRM 特别适合：</p><ul><li>✅ 有开发能力的团队（或可外包）</li><li>✅ 需要深度定制的业务场景</li><li>✅ 注重数据隐私，必须私有部署</li><li>✅ 预算有限，不想付高昂 SaaS 费用</li></ul><h3 id="5-3-不适合的情况"><a href="#5-3-不适合的情况" class="headerlink" title="5.3 不适合的情况"></a>5.3 不适合的情况</h3><ul><li>❌ 完全没有技术能力，也不想外包</li><li>❌ 需要开箱即用的复杂报表</li><li>❌ 对 UI&#x2F;UX 有极高要求（需要二次开发）</li></ul><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.espocrm.com/">EspoCRM</a></li><li><a href="https://twenty.com/">Twenty CRM</a></li><li><a href="https://ofbiz.apache.org/">Apache OFBiz</a></li></ul>]]></content>
    
    
    <summary type="html">给出可复用的 CRM 选型方法：先锁定非妥协需求，再做 PoC（概念验证）与总成本核算。以 Twenty CRM、EspoCRM、Apache OFBiz 为样本，说明为何不把技术栈当硬门槛，并补上权限、审计、迁移、集成与 AGPL 合规等“后期一定会咬你”的维度。最后梳理 EspoCRM 的优势、局限与规避方式。</summary>
    
    
    
    <category term="EspoCRM" scheme="https://www.yzhu.name/categories/EspoCRM/"/>
    
    
    <category term="EspoCRM" scheme="https://www.yzhu.name/tags/EspoCRM/"/>
    
    <category term="CRM" scheme="https://www.yzhu.name/tags/CRM/"/>
    
    <category term="selection" scheme="https://www.yzhu.name/tags/selection/"/>
    
    <category term="comparison" scheme="https://www.yzhu.name/tags/comparison/"/>
    
    <category term="open-source" scheme="https://www.yzhu.name/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>Dify 源码改造：自定义品牌实践</title>
    <link href="https://www.yzhu.name/2025/09/20/dify-custom-brand/"/>
    <id>https://www.yzhu.name/2025/09/20/dify-custom-brand/</id>
    <published>2025-09-20T14:56:55.000Z</published>
    <updated>2025-11-11T03:53:15.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Dify 是一款开源的大语言模型（LLM）应用开发平台，凭借其灵活的插件机制和可视化编排能力，成为企业构建 AI 应用的热门选择。我们希望通过品牌(以品牌 <code>YZHU</code> 为例)定制让 Dify 平台融入其企业形象，强化用户对品牌的认知。<span id="more"></span></p><p>本次变更聚焦于品牌定制，覆盖前端界面（标题、Logo）和嵌入式脚本（交互图标），形成了一套完整的品牌替换流程。这种场景在开源项目二次开发中非常常见：企业需要通过品牌替换和配置调整，让工具更贴合业务需求。本文记录了此次变更的实践细节，希望为其他开发者提供可复用的参考模板。</p><h2 id="核心变更的技术细节"><a href="#核心变更的技术细节" class="headerlink" title="核心变更的技术细节"></a>核心变更的技术细节</h2><p>本次变更涉及 <strong>前端资源</strong> 和 <strong>嵌入式脚本</strong> 两个模块，围绕品牌定制目标展开。以下从技术视角逐一解析关键修改点。</p><h3 id="前端资源"><a href="#前端资源" class="headerlink" title="前端资源"></a>前端资源</h3><p>前端资源是品牌定制的核心，目标是将 “Dify” 品牌替换为 “YZHU”，并优化视觉和无障碍体验。</p><h4 id="1-页面标题"><a href="#1-页面标题" class="headerlink" title="1. 页面标题"></a>1. 页面标题</h4><p>修改 <code>web/hooks/use-document-title.ts</code> 中的标题拼接逻辑，将 <code>${prefix}Dify</code> 替换为 <code>${prefix}YZHU</code>，确保所有页面标题（如 “Home - Dify”）显示为 “Home - YZHU”：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// web/hooks/use-document-title.ts</span><br><span class="line"><span class="deletion">- const title = `$&#123;prefix&#125;Dify`;</span></span><br><span class="line"><span class="addition">+ const title = `$&#123;prefix&#125;YZHU`;</span></span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：运行 <code>npm run dev</code>，打开浏览器检查页面标题后缀是否正确更新为 “ - YZHU” 。</p><h4 id="2-Logo-描述"><a href="#2-Logo-描述" class="headerlink" title="2. Logo 描述"></a>2. Logo 描述</h4><p>更新以下文件中 Logo 图片的 <code>alt</code> 属性，从 “Dify logo” 改为 “YZHU logo”，提升搜索引擎优化（SEO）和无障碍访问体验（屏幕阅读器会读取 <code>alt</code> 文本）：</p><ul><li><code>web/app/account/(commonLayout)/header.tsx</code></li><li><code>web/app/components/base/logo/dify-logo.tsx</code></li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// web/app/components/base/logo/dify-logo.tsx</span><br><span class="line"><span class="deletion">- &lt;img src=&quot;logo.svg&quot; alt=&quot;Dify logo&quot; /&gt;</span></span><br><span class="line"><span class="addition">+ &lt;img src=&quot;logo.svg&quot; alt=&quot;YZHU logo&quot; /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>alt</code> 属性的修改需确保描述准确，反映品牌名称，有助于搜索引擎抓取和无障碍工具识别。</p><h4 id="3-Logo-图片更新"><a href="#3-Logo-图片更新" class="headerlink" title="3. Logo 图片更新"></a>3. Logo 图片更新</h4><p>将 <code>web/app/components/base/logo/logo.svg</code> 替换为自定义的 YZHU Logo。确保新 SVG 文件的尺寸与原文件一致，以避免界面布局错乱。示例 SVG 结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web/app/components/base/logo/logo.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 200 50&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;35&quot;</span> <span class="attr">font-size</span>=<span class="string">&quot;24&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000&quot;</span>&gt;</span>YZHU<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：在开发环境中检查 Logo 在不同页面和屏幕尺寸下的显示效果，确保无拉伸或模糊。</p><h3 id="嵌入式脚本"><a href="#嵌入式脚本" class="headerlink" title="嵌入式脚本"></a>嵌入式脚本</h3><p>嵌入式脚本 <code>embed.js</code> 用于在网页中嵌入 Dify 的交互组件（如聊天窗口）。本次变更更新了脚本中使用的图标文件 <code>closeIcon.svg</code> 和 <code>openIcon.svg</code>，用于 “展开&#x2F;关闭” 交互按钮。</p><h4 id="图标文件更新"><a href="#图标文件更新" class="headerlink" title="图标文件更新"></a>图标文件更新</h4><p>在<code>embed.js</code>将 <code>closeIcon.svg</code> 和 <code>openIcon.svg</code> 替换为自定义 SVG 图标。SVG 格式支持矢量缩放，适合高清屏幕，且可通过代码调整样式（例如颜色、大小）。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- closeIcon.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#FF0000&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M10 10L14 14M14 10L10 14&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- openIcon.svg --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">fill</span>=<span class="string">&quot;#0000FF&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M12 5V19M5 12H19&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优势</strong>：SVG 图标支持动态修改 <code>fill</code> 属性（例如，切换为暗模式时更改颜色），比字体图标更灵活。</p><p><strong>测试方法</strong>：在网页中嵌入 <code>embed.js</code>，检查交互按钮的图标是否正确显示，点击时是否触发展开&#x2F;关闭功能。</p><h3 id="后续优化建议"><a href="#后续优化建议" class="headerlink" title="后续优化建议"></a>后续优化建议</h3><p>新增品牌配置文件：当前品牌标识（如 “YZHU”）硬编码在代码中，后续修改需逐文件替换。建议新增 brand.config.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// web/brand.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> brand = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;YZHU&#x27;</span>,</span><br><span class="line">  <span class="attr">logoPath</span>: <span class="string">&#x27;/path/to/logo.svg&#x27;</span>,</span><br><span class="line">  <span class="attr">altText</span>: <span class="string">&#x27;YZHU logo&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在代码中引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; brand &#125; from &#x27;./brand.config.js&#x27;;</span><br><span class="line">const title = `$&#123;prefix&#125;$&#123;brand.name&#125;`;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开源项目的二次开发不一定需要改动核心功能，像本次 Dify 品牌定制这样，通过精细化的文本替换、视觉更新和部署优化，同样能让工具无缝融入企业业务场景。本文提供了一套可复用的品牌替换流程，涵盖前端资源和嵌入式脚本，适合中小型企业或初次接触 Dify 的开发者。</p><p>如果你也在进行 Dify 的二次开发，欢迎分享你的经验！希望本文能为你的项目提供参考。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Dify 是一款开源的大语言模型（LLM）应用开发平台，凭借其灵活的插件机制和可视化编排能力，成为企业构建 AI 应用的热门选择。我们希望通过品牌(以品牌 &lt;code&gt;YZHU&lt;/code&gt; 为例)定制让 Dify 平台融入其企业形象，强化用户对品牌的认知。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式系统核心组件对比：Nacos、Consul、ZooKeeper与etcd</title>
    <link href="https://www.yzhu.name/2025/07/08/Nacos-Consul-Zk-Etcd/"/>
    <id>https://www.yzhu.name/2025/07/08/Nacos-Consul-Zk-Etcd/</id>
    <published>2025-07-08T08:01:07.000Z</published>
    <updated>2025-11-11T03:53:15.771Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统架构中，服务发现、配置管理和分布式协调是三大核心挑战。目前业界主流的解决方案包括 Nacos、Consul、ZooKeeper 和 etcd，它们各自基于不同的设计理念，适用于不同的业务场景。本文将从核心功能、特性细节、适用场景等多个维度进行深入对比，帮助技术团队在实际项目中做出合适的选择。<span id="more"></span></p><h2 id="核心功能对比概览"><a href="#核心功能对比概览" class="headerlink" title="核心功能对比概览"></a>核心功能对比概览</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>ZooKeeper</strong></th><th><strong>etcd</strong></th><th><strong>Consul</strong></th><th><strong>Nacos</strong></th></tr></thead><tbody><tr><td><strong>诞生时间</strong></td><td>最早 (2006)</td><td>较新 (2013)</td><td>较新 (2014)</td><td>最新 (2018)</td></tr><tr><td><strong>主要定位</strong></td><td>分布式协调服务</td><td>分布式键值存储，K8s 核心组件</td><td>服务网格与服务发现平台</td><td>微服务一站式服务治理平台</td></tr><tr><td><strong>一致性协议</strong></td><td>ZAB (ZooKeeper Atomic Broadcast)</td><td>Raft</td><td>Raft（单数据中心强一致，跨中心最终一致）</td><td>CP (Raft) &amp; AP (Distro) 双模</td></tr><tr><td><strong>数据模型</strong></td><td>层次化的 ZNode 节点 (类似文件系统)</td><td>扁平的键值对 (支持范围查询)</td><td>扁平的键值对 (支持目录和前缀查询)</td><td>扁平的键值对 (支持分组和命名空间)</td></tr><tr><td><strong>API&#x2F;协议</strong></td><td>自定义 TCP 协议，Java&#x2F;C 客户端</td><td>HTTP&#x2F;JSON, gRPC</td><td>HTTP&#x2F;JSON, DNS 接口</td><td>HTTP&#x2F;JSON, gRPC 接口</td></tr><tr><td><strong>性能特点</strong></td><td>读多写少场景性能优异</td><td>读写性能均高，写入线性一致</td><td>读写性能高，支持健康检查优化</td><td>支持大规模实例注册，读写性能优越</td></tr><tr><td><strong>开发语言</strong></td><td>Java</td><td>Go</td><td>Go</td><td>Java</td></tr><tr><td><strong>高可用与扩展性</strong></td><td>需奇数节点，扩容复杂，强一致性</td><td>动态扩容，强一致性</td><td>多数据中心支持，动态扩缩容</td><td>AP&#x2F;CP 复合模型，服务注册高可用，配置需关注 Raft</td></tr><tr><td><strong>运维与监控</strong></td><td>无原生 UI，依赖第三方工具</td><td>提供 CLI 和 API，支持 Prometheus</td><td>自带 Web UI，监控集成友好</td><td>自带 Web 控制台，Prometheus 集成</td></tr><tr><td><strong>安全性</strong></td><td>支持 SASL、ACL、TLS，配置复杂</td><td>支持 TLS、RBAC、认证机制完善</td><td>支持 TLS、ACL，企业版更强</td><td>支持 TLS、认证，需关注 JVM 相关安全配置</td></tr></tbody></table><blockquote><p><strong>注：Nacos 2.x 采用复合一致性模型。Raft 协议用于所有持久化数据（包括配置管理和服务的持久化实例），保证 CP 强一致性；而服务注册中的临时实例则采用自研的 Distro 协议，实现高可用但弱一致性。</strong></p></blockquote><hr><h2 id="组件详细分析"><a href="#组件详细分析" class="headerlink" title="组件详细分析"></a>组件详细分析</h2><h3 id="1-ZooKeeper：分布式协调的元老"><a href="#1-ZooKeeper：分布式协调的元老" class="headerlink" title="1. ZooKeeper：分布式协调的元老"></a>1. ZooKeeper：分布式协调的元老</h3><p><strong>核心特点</strong>：</p><ul><li>Apache 顶级项目，诞生于 2006 年，是分布式协调领域的标杆，被 Kafka、Hadoop、HBase 等广泛采用。</li><li>提供分布式锁、领导者选举、集群成员管理等分布式原语，是许多底层系统的“神经中枢”。</li><li>使用树状结构（ZNode），支持 Watch 机制，实现事件驱动的数据订阅。</li><li>生态成熟，配合 Curator 框架可简化开发复杂度。</li></ul><p><strong>适用场景</strong>：</p><ul><li>分布式协调为核心诉求的系统</li><li>与 Hadoop&#x2F;Kafka 等大数据生态深度集成</li><li>需要分布式锁、选举、元数据管理的场景</li></ul><p><strong>局限性</strong>：</p><ul><li>原生 API 设计底层，开发复杂</li><li>服务发现能力弱，无内置健康检查</li><li>集群扩容需重启，维护复杂，对网络抖动敏感</li></ul><hr><h3 id="2-etcd：云原生时代的强一致存储基石"><a href="#2-etcd：云原生时代的强一致存储基石" class="headerlink" title="2. etcd：云原生时代的强一致存储基石"></a>2. etcd：云原生时代的强一致存储基石</h3><p><strong>核心特点</strong>：</p><ul><li>Kubernetes 默认数据存储，专为云原生架构设计</li><li>使用 Raft 算法，保证写入线性一致性</li><li>支持 gRPC 和 REST API，跨语言友好</li><li>Watch 机制支持事件监听，便于配置推送</li></ul><p><strong>适用场景</strong>：</p><ul><li>Kubernetes 环境中的配置与元数据存储</li><li>高可用、强一致性键值存储需求</li><li>轻量级服务注册中心</li></ul><p><strong>局限性</strong>：</p><ul><li>默认单键值大小不超过 1.5MB（可通过参数调整）</li><li>不提供服务网格、健康检查等治理功能</li><li>更偏向平台组件，缺乏一站式管理体验</li></ul><hr><h3 id="3-Consul：服务治理的全能选手"><a href="#3-Consul：服务治理的全能选手" class="headerlink" title="3. Consul：服务治理的全能选手"></a>3. Consul：服务治理的全能选手</h3><p><strong>核心特点</strong>：</p><ul><li>集服务发现、KV 存储、健康检查、服务网格于一体</li><li>支持 DNS 和 HTTP 两种服务发现方式</li><li>内建多数据中心支持，跨地域部署方便</li><li>Consul Connect 支持 mTLS、服务代理、ACL 等网格能力</li><li>自带 Web UI，状态管理直观</li></ul><p><strong>适用场景</strong>：</p><ul><li>微服务架构中的服务注册与健康检查</li><li>构建跨区域服务网络</li><li>对服务网格、安全加密通信有要求的系统</li></ul><p><strong>局限性</strong>：</p><ul><li>多中心间仅提供最终一致性</li><li>服务网格功能需额外部署 Envoy 等代理组件</li><li>企业版功能更丰富，开源版略显不足</li></ul><hr><h3 id="4-Nacos：为微服务而生的一站式平台"><a href="#4-Nacos：为微服务而生的一站式平台" class="headerlink" title="4. Nacos：为微服务而生的一站式平台"></a>4. Nacos：为微服务而生的一站式平台</h3><p><strong>核心特点</strong>：</p><ul><li>集服务注册、配置管理、服务治理为一体，降低集成成本</li><li>支持双模一致性模型（Raft + Distro）：<ul><li><strong>Raft（CP 模式）</strong>：持久化数据，如配置与持久实例</li><li><strong>Distro（AP 模式）</strong>：临时实例注册，保障高可用</li></ul></li><li>与 Spring Cloud、Dubbo 等主流框架深度集成</li><li>提供服务分组、命名空间、灰度发布、流量调度等高级能力</li></ul><p><strong>适用场景</strong>：</p><ul><li>Java 技术栈微服务项目</li><li>同时需要配置中心与注册中心的系统</li><li>需要灵活服务治理能力的中大型项目</li></ul><p><strong>局限性</strong>：</p><ul><li>国际社区活跃度不如 Consul、etcd</li><li>JVM 运维调优要求高，大规模场景下需关注数据库与线程资源配置</li></ul><hr><h2 id="高可用性与扩展性对比"><a href="#高可用性与扩展性对比" class="headerlink" title="高可用性与扩展性对比"></a>高可用性与扩展性对比</h2><ul><li><strong>ZooKeeper</strong>：需奇数节点，扩容需重启，稳定性依赖网络状况</li><li><strong>etcd</strong>：支持动态扩容，Raft 保障强一致，适合云原生部署</li><li><strong>Consul</strong>：支持多数据中心同步，本地强一致，远端最终一致</li><li><strong>Nacos</strong>：服务注册基于 AP 模型具备扩展弹性，配置管理依赖 CP 模式的 Raft 集群</li></ul><hr><h2 id="运维与监控对比"><a href="#运维与监控对比" class="headerlink" title="运维与监控对比"></a>运维与监控对比</h2><ul><li><strong>ZooKeeper</strong>：需第三方工具如 zkui、Exhibitor，监控配置复杂</li><li><strong>etcd</strong>：CLI&#x2F;API 直观，支持 Prometheus 集成，自动化程度高</li><li><strong>Consul</strong>：自带 UI，支持 Prometheus、Grafana，易于观测与故障排查</li><li><strong>Nacos</strong>：内建控制台，支持 Prometheus，界面友好，易于入门</li></ul><hr><h2 id="安全性对比"><a href="#安全性对比" class="headerlink" title="安全性对比"></a>安全性对比</h2><ul><li><strong>ZooKeeper</strong>：支持 SASL、ACL、TLS，但配置繁琐</li><li><strong>etcd</strong>：支持 TLS 加密、客户端认证、RBAC 权限控制，安全性强</li><li><strong>Consul</strong>：支持 TLS 和 ACL，企业版安全能力更强</li><li><strong>Nacos</strong>：支持 TLS 和认证机制，需关注 JVM 及配置安全</li></ul><hr><h2 id="生态与集成对比"><a href="#生态与集成对比" class="headerlink" title="生态与集成对比"></a>生态与集成对比</h2><table><thead><tr><th>组件</th><th>集成生态</th></tr></thead><tbody><tr><td><strong>ZooKeeper</strong></td><td>Kafka、Hadoop、HBase、Java 系统</td></tr><tr><td><strong>etcd</strong></td><td>Kubernetes、CoreOS、Go 微服务框架</td></tr><tr><td><strong>Consul</strong></td><td>HashiCorp 工具链（Terraform、Nomad）、云原生生态</td></tr><tr><td><strong>Nacos</strong></td><td>Spring Cloud、Dubbo、阿里云微服务生态，中国社区活跃</td></tr></tbody></table><hr><h2 id="组件选择指南"><a href="#组件选择指南" class="headerlink" title="组件选择指南"></a>组件选择指南</h2><h3 id="按核心需求选型"><a href="#按核心需求选型" class="headerlink" title="按核心需求选型"></a>按核心需求选型</h3><ul><li><strong>分布式协调需求高</strong>：ZooKeeper（配 Curator）或 etcd</li><li><strong>注册中心 + 健康检查</strong>：Consul 或 Nacos 更适合</li><li><strong>配置中心为主</strong>：Nacos（功能齐全）、etcd（一致性强）、Consul（KV存储稳健）</li><li><strong>服务网格需求强</strong>：首选 Consul Connect（或考虑 Istio）</li><li><strong>Java 技术栈</strong>：Nacos 与 Spring Cloud 集成最顺畅</li></ul><h3 id="按团队技术栈选型"><a href="#按团队技术栈选型" class="headerlink" title="按团队技术栈选型"></a>按团队技术栈选型</h3><ul><li><strong>偏向 Java</strong>：ZooKeeper 或 Nacos</li><li><strong>Go&#x2F;K8s 环境</strong>：etcd 或 Consul</li><li><strong>大数据系统</strong>：ZooKeeper 为首选</li></ul><h3 id="按规模与运维能力选型"><a href="#按规模与运维能力选型" class="headerlink" title="按规模与运维能力选型"></a>按规模与运维能力选型</h3><ul><li><strong>小团队初创项目</strong>：Nacos 上手快，维护简单</li><li><strong>大规模微服务体系</strong>：Consul&#x2F;Nacos 可应对大并发</li><li><strong>极简架构偏好者</strong>：etcd 功能聚焦，部署简便</li></ul><hr><h2 id="典型场景推荐方案"><a href="#典型场景推荐方案" class="headerlink" title="典型场景推荐方案"></a>典型场景推荐方案</h2><ol><li><p><strong>传统 Java 微服务（非 K8s）</strong>：</p><ul><li>服务治理：Nacos（Spring Cloud 深度集成）</li><li>分布式协调：etcd 或 ZooKeeper + Curator</li><li>一体化方案：Nacos 支持服务注册 + 配置管理</li></ul></li><li><p><strong>Kubernetes 容器平台</strong>：</p><ul><li>核心数据存储：etcd（K8s 标配）</li><li>服务注册：K8s Service + CoreDNS</li><li>高级配置中心：etcd 或 Nacos</li></ul></li><li><p><strong>跨地域部署系统</strong>：</p><ul><li>服务网络管理：Consul（内建多数据中心）</li><li>配置中心：Consul KV 或 Nacos（命名空间隔离）</li></ul></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式基础设施组件没有一劳永逸的选择，只有契合业务场景的最优解。ZooKeeper 是协调领域的经典基石，etcd 成为云原生中的强一致核心，Consul 在服务网格和网络治理中独具优势，而 Nacos 提供了微服务体系下的一体化解决方案。</p><p>实际项目中建议根据业务需求、技术生态、团队能力三方面综合评估，灵活选型。通常微服务体系下，<strong>Nacos 和 Consul</strong> 是兼顾功能与复杂度的优选；而在 K8s 环境中，<strong>etcd</strong> 是不可替代的基础设施核心。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://nacos.io/">Nacos</a></li><li><a href="https://www.consul.io/">Consul</a></li><li><a href="https://zookeeper.apache.org/">ZooKeeper</a></li><li><a href="https://etcd.io/">etcd</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分布式系统架构中，服务发现、配置管理和分布式协调是三大核心挑战。目前业界主流的解决方案包括 Nacos、Consul、ZooKeeper 和 etcd，它们各自基于不同的设计理念，适用于不同的业务场景。本文将从核心功能、特性细节、适用场景等多个维度进行深入对比，帮助技术团队在实际项目中做出合适的选择。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Biometric-Based Payment Product</title>
    <link href="https://www.yzhu.name/2025/04/26/Biometric-Based-Payment-Product/"/>
    <id>https://www.yzhu.name/2025/04/26/Biometric-Based-Payment-Product/</id>
    <published>2025-04-26T11:55:19.000Z</published>
    <updated>2025-11-11T03:53:15.766Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间完成了一个基于生物识别技术的支付产品方案设计。该方案旨在通过生物特征识别（如掌静脉扫描）实现无需手机的便捷支付体验，为用户和商户提供更加安全、高效的支付解决方案。经过对敏感信息的脱敏处理，我将这个方案的核心设计理念、系统架构和关键流程记录下来，希望能为对类似技术感兴趣的读者提供一些参考和启发。本文将详细介绍该支付产品的目标、核心功能、系统架构以及交互流程，展示如何将生物识别技术与支付系统有机结合，打造一个既安全又便捷的支付生态系统。<span id="more"></span></p><p>在技术快速迭代的今天，生物识别支付代表了未来支付方式的重要发展方向之一。通过这篇文章，我希望能分享这一领域的一些思考和实践经验。</p><h1 id="Biometric-Based-Payment-Product"><a href="#Biometric-Based-Payment-Product" class="headerlink" title="Biometric-Based Payment Product"></a>Biometric-Based Payment Product</h1><h2 id="1-Project-Overview"><a href="#1-Project-Overview" class="headerlink" title="1. Project Overview"></a>1. Project Overview</h2><p>This project aims to provide an innovative, convenient, and secure payment solution for users, allowing them to make payments without a phone using biometric features (such as palm vein scanning). The product will integrate payment API and biometric capture technology from a partner vendor to deliver a new payment experience for users and an efficient and secure method of receiving payments for merchants. </p><h2 id="2-Project-Goals"><a href="#2-Project-Goals" class="headerlink" title="2. Project Goals"></a>2. Project Goals</h2><ul><li>To provide users with a convenient way to make payments without a phone</li><li>To enhance payment security and reduce the risk of fraud through multi-factor authentication</li><li>To simplify the payment process and improve transaction efficiency</li><li>To offer merchants a modern method of receiving payments with real-time settlement</li><li>To comply with local payment regulatory requirements and data protection standards</li><li>To ensure system scalability and high availability</li></ul><h2 id="3-Product-Core-Feature-List"><a href="#3-Product-Core-Feature-List" class="headerlink" title="3. Product Core Feature List"></a>3. Product Core Feature List</h2><h4 id="3-1-User-Features"><a href="#3-1-User-Features" class="headerlink" title="3.1 User Features:"></a>3.1 User Features:</h4><ul><li>User account registration with multi-factor authentication</li><li>Biometric feature (e.g., palm vein) capture and secure encryption</li><li>Initiating payments by scanning biometric features at participating merchants</li><li>Real-time payment notifications (via biometric capture device, APP, SMS, Email, WhatsApp Message)</li><li>Detailed transaction history with advanced filtering (via App)</li><li>Comprehensive user account management (card binding, password change, security settings)</li><li>Emergency account freeze functionality</li></ul><h4 id="3-2-Merchant-Features"><a href="#3-2-Merchant-Features" class="headerlink" title="3.2 Merchant Features:"></a>3.2 Merchant Features:</h4><ul><li>Real-time payment processing and confirmation</li><li>Automated refund processing with approval workflow</li><li>Flexible settlement cycles (T+0, T+1) with detailed reporting</li><li>Advanced transaction search and export capabilities</li><li>Detailed settlement reports and reconciliation tools</li><li>Merchant profile and branch management</li><li>Custom payment limit settings</li><li>Integration with existing POS systems</li></ul><h4 id="3-3-System-Management-Features"><a href="#3-3-System-Management-Features" class="headerlink" title="3.3 System Management Features:"></a>3.3 System Management Features:</h4><ul><li>Centralized user account management with audit trails</li><li>Real-time transaction monitoring and fraud detection</li><li>Device health monitoring and remote management</li><li>Configurable system parameters and business rules</li><li>Comprehensive reporting with data visualization</li><li>System performance monitoring and alerts</li><li>Audit logging for all critical operations</li><li>Automated backup and disaster recovery</li></ul><h2 id="4-System-Architecture"><a href="#4-System-Architecture" class="headerlink" title="4 System Architecture"></a>4 System Architecture</h2><p>To serve 500k users with room for growth, this system involves the following enhanced components:</p><ul><li><strong>Biometric Capture Device:</strong> Secure biometric capture with encryption and matching capabilities</li><li><strong>User App:</strong> The main entry point for user registration, account management, transaction viewing, etc.</li><li><strong>User Backend System:</strong> core business logic processing center, responsible for user management, biometric data management, interaction with Tap API, transaction processing, security control, etc.</li><li><strong>Payment API:</strong> Used to process actual payment transactions, including fund deduction and settlement.</li><li><strong>Merchant Backend (Web):</strong> The main entry point for merchants to receive payments, view transaction records, etc.</li><li><strong>Admin Backend (Web):</strong> Used by system administrators to manage system, generate reports, etc.</li><li><strong>Job Service:</strong> Used for scheduled tasks, such as payment reconciliation，data compensation, etc.</li><li><strong>Database:</strong> Used to store user information, transaction records, etc.(maybe master-slave architecture)</li><li><strong>Message Queue:</strong> Used for asynchronous message processing, such as payment notification, etc.</li><li><strong>Cache Layer:</strong> Distributed caching for performance optimization</li><li><strong>Monitoring System:</strong> Real-time system monitoring and alerting</li></ul><p>In order to ensure the system’s scalability and high availability, the system deployment is implemented as described below:</p><pre class="mermaid">flowchart TB    subgraph payment gateway        Payment-Gateway[third-payment-gateway]     end    subgraph Storage        MySQL[RDS-MySQL]         Redis[Redis]    end        subgraph MessageQueue        MQ[RabbitMQ]    end    subgraph backend        BackendService[backend-service] -->|JDBC| MySQL        BackendService -->|Redis API| Redis        BackendService -->|API| Payment-Gateway        BackendService -->|send| MQ        Payment-Gateway -.->|async| BackendService    end    subgraph user        App[App] -->|REST API| BackendService        BiometricDevice[biometric-device] --> BackendService    end    subgraph merchant        WebMerchant[Merchant-UI] -->Merchant-Service        Merchant-Service-->|JDBC| MySQL        Merchant-Service-->|Redis API| Redis    end    subgraph operation admin        WebAdmin[Admin-UI] -->Admin-Service        Admin-Service-->|JDBC| MySQL        Admin-Service-->|Redis API| Redis    end        subgraph job        Job-Service -->|JDBC| MySQL        Job-Service -->|Redis API| Redis        Job-Service -.->|consume| MQ    end</pre><h2 id="5-Core-Interactive-Process"><a href="#5-Core-Interactive-Process" class="headerlink" title="5. Core Interactive Process"></a>5. Core Interactive Process</h2><h4 id="5-1-Registration"><a href="#5-1-Registration" class="headerlink" title="5.1 Registration"></a>5.1 Registration</h4><pre class="mermaid">sequenceDiagram    participant User    participant App    participant BackendService    participant BiometricDevice    User->>App: Initiate Registration Request    App->>BackendService: Send Registration Request (User Information)    BackendService->>BiometricDevice: Request Biometric Capture    BiometricDevice->>User: Prompt User for Biometric Capture    User->>BiometricDevice: Complete Biometric Capture    BiometricDevice->>BackendService: Send Biometric Data    BackendService->>Database: Store User Information and Biometric Information    Database-->>BackendService: Return Storage Result    BackendService-->>App: Return Registration Success Information    App->>User: Display Registration Success</pre><h4 id="5-2-Link-Bank-Card"><a href="#5-2-Link-Bank-Card" class="headerlink" title="5.2 Link Bank Card"></a>5.2 Link Bank Card</h4><pre class="mermaid">sequenceDiagram    participant User    participant App    participant BackendService    participant Tap as Payment API    User->>App: Initiate Card Linking    App->>BackendService: Request Card Linking Initiation (User ID)    BackendService->>App: Instruct App to Present Payment's Secure Form    App->>User: Display Payment's Secure Card Input Form    User->>App: Enter Bank Card Details    App->>Tap: Send Card Details Securely (via SDK or Payment Page)    Tap-->>App: Return Card Token    App->>BackendService: Send Card Token and User ID    BackendService->>Database: Associate Card Token with User Account    Database-->>BackendService: Return Association Result    BackendService-->>App: Return Card Linking Success Confirmation    App->>User: Display "Card Linked Successfully"</pre><h4 id="5-3-Payment"><a href="#5-3-Payment" class="headerlink" title="5.3 Payment"></a>5.3 Payment</h4><pre class="mermaid">sequenceDiagram    participant User    participant BiometricDevice    participant BackendService    participant Tap as Payment API    User->>BiometricDevice: Initiate Payment Request    BiometricDevice->>BackendService: Send Payment Request (Device ID, May Contain Initial User Identification)    BackendService->>BiometricDevice: Request Biometric Verification    BiometricDevice->>User: Prompt User for Biometric Verification    User->>BiometricDevice: Complete Biometric Verification    BiometricDevice->>BackendService: Send Biometric Data    BackendService->>Database: Query User Biometric Information    Database-->>BackendService: Return User Biometric Information    alt Verification Successful        BackendService->>Database: Retrieve User's Card Token        Database-->>BackendService: Return Card Token        BackendService->>Tap: Initiate Payment Request (Amount, Card Token, Merchant ID, etc.)        Tap-->>BackendService: Return Payment Result        BackendService->>BiometricDevice: Return Payment Success Information        BiometricDevice->>User: Display Payment Success    else Verification Failed        BackendService->>BiometricDevice: Return Payment Failure Information        BiometricDevice->>User: Display Payment Failure    end</pre><h2 id="6-Security-and-Compliance-Considerations"><a href="#6-Security-and-Compliance-Considerations" class="headerlink" title="6. Security and Compliance Considerations"></a>6. Security and Compliance Considerations</h2><h4 id="6-1-Data-Security"><a href="#6-1-Data-Security" class="headerlink" title="6.1 Data Security"></a>6.1 Data Security</h4><ul><li>End-to-end encryption for biometric data storage and transmission</li><li>Strict access control mechanisms for sensitive data</li><li>Separation of biometric data from user identity information</li><li>Regular security audits and penetration testing</li><li>Multi-layered security architecture with defense-in-depth approach</li></ul><h4 id="6-2-Compliance"><a href="#6-2-Compliance" class="headerlink" title="6.2 Compliance"></a>6.2 Compliance</h4><ul><li>Adherence to payment industry regulations and standards (PCI DSS)</li><li>Compliance with data protection regulations (GDPR or local equivalents)</li><li>Implementation of comprehensive user privacy protection mechanisms</li><li>Complete compliance audit trail to meet regulatory requirements</li><li>Regular compliance reviews and updates</li></ul><h2 id="7-Performance-and-Scalability"><a href="#7-Performance-and-Scalability" class="headerlink" title="7. Performance and Scalability"></a>7. Performance and Scalability</h2><h4 id="7-1-Performance-Metrics"><a href="#7-1-Performance-Metrics" class="headerlink" title="7.1 Performance Metrics"></a>7.1 Performance Metrics</h4><ul><li>Transaction response time: Average &lt;1 second, 99% of transactions &lt;3 seconds</li><li>System throughput: Peak capacity of 100+ transaction requests per second</li><li>System availability: 99.99% uptime (less than 1 hour of unplanned downtime annually)</li><li>Data consistency: Ensuring integrity and consistency of all transaction data</li><li>Biometric matching accuracy: False acceptance rate &lt;0.001%, false rejection rate &lt;1%</li></ul><h4 id="7-2-Scalability-Strategy"><a href="#7-2-Scalability-Strategy" class="headerlink" title="7.2 Scalability Strategy"></a>7.2 Scalability Strategy</h4><ul><li>Automated elastic scaling based on load patterns</li><li>Capacity planning for 300% growth over the next 2 years</li></ul><h2 id="8-Implementation-and-Operations"><a href="#8-Implementation-and-Operations" class="headerlink" title="8. Implementation and Operations"></a>8. Implementation and Operations</h2><h4 id="8-1-Implementation-Roadmap"><a href="#8-1-Implementation-Roadmap" class="headerlink" title="8.1 Implementation Roadmap"></a>8.1 Implementation Roadmap</h4><ul><li>Phase 1: Core payment functionality development and testing (2 months)</li><li>Phase 2: Merchant management system and settlement functionality (1 months)</li><li>Phase 3: Pilot deployment and optimization (1 months)</li><li>Phase 4: Full-scale rollout and continuous improvement (ongoing)</li></ul><h4 id="8-2-Operational-Strategy"><a href="#8-2-Operational-Strategy" class="headerlink" title="8.2 Operational Strategy"></a>8.2 Operational Strategy</h4><ul><li>24&#x2F;7 monitoring system with real-time alerts</li><li>Automated deployment and rollback mechanisms</li><li>Comprehensive logging and analytics system</li><li>Detailed disaster recovery plan with regular testing</li><li>Continuous performance optimization and capacity planning</li></ul><h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><p>以上是这个项目的完整方案，该方案通过整合生物识别技术与支付API，为用户提供了一种无需手机即可完成支付的便捷方式。系统架构设计充分考虑了安全性、可扩展性和高可用性，能够支持大规模用户群体的使用需求。</p><p>通过实施这一支付解决方案，我们期望能够：</p><ul><li>为用户提供更加便捷、安全的支付体验</li><li>为商户提供更加高效、可靠的收款方式</li></ul><p>未来，我们计划进一步优化系统性能，扩展更多场景应用，如将生物识别支付技术应用于多个领域。同时，我们也将持续关注生物识别技术的发展，探索更多创新的支付解决方案，为用户和商户创造更大的价值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前一段时间完成了一个基于生物识别技术的支付产品方案设计。该方案旨在通过生物特征识别（如掌静脉扫描）实现无需手机的便捷支付体验，为用户和商户提供更加安全、高效的支付解决方案。经过对敏感信息的脱敏处理，我将这个方案的核心设计理念、系统架构和关键流程记录下来，希望能为对类似技术感兴趣的读者提供一些参考和启发。本文将详细介绍该支付产品的目标、核心功能、系统架构以及交互流程，展示如何将生物识别技术与支付系统有机结合，打造一个既安全又便捷的支付生态系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在线工具集合网站</title>
    <link href="https://www.yzhu.name/2024/11/15/First-Efficiency-Lab/"/>
    <id>https://www.yzhu.name/2024/11/15/First-Efficiency-Lab/</id>
    <published>2024-11-15T14:16:33.000Z</published>
    <updated>2025-11-11T03:53:15.768Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发项目中，我们经常需要处理格式转换、日期计算、编码解码等基础操作。这些任务要么需要在开发环境中编写代码实现，要么需要在网上搜索对应的在线工具。为了提高工作效率，我整合了一系列常用工具，并将它们集成到这个网站中：<a href="https://labs.yzhu.name/">https://labs.yzhu.name</a> <span id="more"></span></p><p>该网站目前提供了以下几个工具:</p><h3 id="日期计算器"><a href="#日期计算器" class="headerlink" title="日期计算器"></a><a href="https://labs.yzhu.name/date-calc.html">日期计算器</a></h3><p>计算日期天数差、增减天数以及查找特定日期,常用于处理与日期相关的业务需求。</p><h3 id="单位转换器"><a href="#单位转换器" class="headerlink" title="单位转换器"></a><a href="https://labs.yzhu.name/unit-conv.html">单位转换器</a></h3><p>帮助进行英制和公制单位之间的自由转换,如常用的长度、重量、体积、温度等维度。</p><h3 id="JSON格式化"><a href="#JSON格式化" class="headerlink" title="JSON格式化"></a><a href="https://labs.yzhu.name/json-format.html">JSON格式化</a></h3><p>将JSON数据格式化成有层级缩进的样式,或将格式化后的JSON转成单行,方便发现JSON语法错误。</p><h3 id="编-解码工具"><a href="#编-解码工具" class="headerlink" title="编&#x2F;解码工具"></a><a href="https://labs.yzhu.name/encode.html">编&#x2F;解码工具</a></h3><p>使用常见的Base64、MD5、SHA等多种编码解码算法对文本进行转换,适用于加解密、哈希处理等需求。</p><h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a><a href="https://labs.yzhu.name/timestamp.html">Unix时间戳转换</a></h3><p>将Unix时间戳转成可读的时间格式,或通过年月日等输入获取对应的时间戳。</p><h3 id="YAML-JSON转换"><a href="#YAML-JSON转换" class="headerlink" title="YAML&#x2F;JSON转换"></a><a href="https://labs.yzhu.name/yaml-json.html">YAML&#x2F;JSON转换</a></h3><p>在YAML和JSON两种格式之间双向转换,并同时支持格式化和语法验证。</p><h3 id="转换图片为白地图"><a href="#转换图片为白地图" class="headerlink" title="转换图片为白地图"></a><a href="https://labs.yzhu.name/image-segment.html">转换图片为白地图</a></h3><p>快速扣除商品背景，将证件照换为白地图，等场景，能够对图片进行一键抠图，快速处理。</p><p>这些工具的灵感大多来源于我们日常工作中的一些高频基本需求。核心目的是集中常用的小工具,提高这部分操作的效率。</p><p>工具地址: <a href="https://labs.yzhu.name/">https://labs.yzhu.name</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日常开发项目中，我们经常需要处理格式转换、日期计算、编码解码等基础操作。这些任务要么需要在开发环境中编写代码实现，要么需要在网上搜索对应的在线工具。为了提高工作效率，我整合了一系列常用工具，并将它们集成到这个网站中：&lt;a href=&quot;https://labs.yzhu.name/&quot;&gt;https://labs.yzhu.name&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>跨境电商用户标签系统架构设计</title>
    <link href="https://www.yzhu.name/2023/12/10/User-Tag/"/>
    <id>https://www.yzhu.name/2023/12/10/User-Tag/</id>
    <published>2023-12-10T10:25:21.000Z</published>
    <updated>2025-11-11T03:53:15.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、项目背景与业务价值"><a href="#一、项目背景与业务价值" class="headerlink" title="一、项目背景与业务价值"></a>一、项目背景与业务价值</h3><p>在竞争激烈的跨境电商领域，用户体验和精细化运营至关重要。为了实现<strong>精准营销、动态定价和运营分析</strong>等关键业务场景，我们需要更及时、更准确地理解用户行为<span id="more"></span>。</p><p>然而，传统用户标签系统依赖离线计算，数据更新频率为<strong>每日一次</strong>，实时性不足，无法满足业务快速响应用户行为变化的需求。例如，<strong>新用户下单后无法立即享受老用户折扣</strong>，<strong>个性化推荐也存在滞后性</strong>。</p><p>为了解决这些痛点，我们启动了<strong>实时用户标签系统</strong>项目，旨在构建一套<strong>高性能、低延迟、可扩展</strong>的用户标签基础设施，实现用户行为的<strong>实时采集、计算和应用</strong>，为业务增长提供有力的数据支撑。</p><p>系统上线后，成功支撑<strong>日均三千万级</strong>用户行为数据处理，<strong>标签更新延迟控制在500ms内</strong>，为以下关键业务场景提供了有力支持：</p><ul><li><strong>精准营销</strong>：基于用户标签实现<strong>千人千面</strong>的商品推荐，提升点击率和转化率。</li><li><strong>动态定价</strong>：根据用户标签（如新老用户）实施<strong>差异化价格策略</strong>，提升用户粘性和复购率。</li><li><strong>运营分析</strong>：通过用户行为标签进行<strong>用户行为洞察和转化率优化</strong>，指导运营策略调整。</li></ul><h3 id="二、架构设计全景图"><a href="#二、架构设计全景图" class="headerlink" title="二、架构设计全景图"></a>二、架构设计全景图</h3><h4 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h4><pre class="mermaid">graph TD    AAW[App/Web] -->|HTTP上报| A[区域A数据采集系统]    ABK[后端系统] -->|SDK上报| A    BAW[App/Web] -->|HTT上报| B[区域B数据采集系统]    BBK[后端系统] -->|SDK上报| B    A -->|MQ| C[标签计算系统]    B -->|MQ| C    C --> Da[区域A数据库集群: MongoDB+MySQL+Redis]    C --> Db[区域B数据库集群: MySQL+Redis]    Ea[标签查询] --> Da    Fa[用户系统]-->Ea    Ga[订单系统]-->Ea    Ia[营销系统]-->Ea    Ha[其它...系统]-->Ea    Eb[标签查询] --> Db    Fb[用户系统]-->Eb    Gb[订单系统]-->Eb    Ib[营销系统]-->Eb    Hb[其它...系统]-->Eb</pre><p><strong>数据流:</strong>  <code>App/Web/后端系统</code> → <code>HTTP/SDK上报</code> → <code>区域采集系统</code> → <code>RabbitMQ</code> → <code>标签计算系统</code> → <code>MongoDB/MySQL/Redis</code></p><p><strong>分层架构:</strong></p><ul><li><strong>数据采集层</strong>：采用 <strong>Nginx+SpringCloud</strong> 技术栈，<strong>双区域独立部署</strong> (区域A和区域B数据采集系统)，支持 <strong>App&#x2F;Web&#x2F;API 多端统一接入</strong>。具备 <strong>高并发 HTTP 接入</strong> 能力和 <strong>区域路由</strong> 功能，确保数据就近接入，降低网络延迟。</li><li><strong>消息中间件</strong>：复用现有 <strong>RabbitMQ 集群</strong>，降低运维成本。RabbitMQ 承担 <strong>数据缓冲和异步解耦</strong> 的作用，保障数据采集层和计算层之间的稳定通信。</li><li><strong>计算存储层</strong>：<ul><li><strong>标签计算系统</strong>：基于 <strong>Spring</strong> 构建，采用 <strong>轻量级规则引擎</strong> 框架，易于扩展和维护。</li><li><strong>规则管理</strong>：<strong>MySQL</strong> 存储标签规则，实现 <strong>规则版本控制和回滚</strong>，方便规则迭代和管理。</li><li><strong>标签存储</strong>：采用 <strong>MySQL+Redis</strong> 组合，<strong>MySQL</strong> 持久化存储标签规则与计算结果，<strong>Redis</strong> 提供 <strong>实时查询能力</strong>，支撑高并发的标签查询请求。</li></ul></li></ul><h4 id="2-核心组件设计"><a href="#2-核心组件设计" class="headerlink" title="2. 核心组件设计"></a>2. 核心组件设计</h4><table><thead><tr><th>模块</th><th>技术选型</th><th>设计要点</th></tr></thead><tbody><tr><td>数据采集</td><td>Nginx+SpringCloud</td><td>高并发HTTP接入，区域路由</td></tr><tr><td>消息队列</td><td>RabbitMQ集群</td><td>消息持久化，自动故障转移</td></tr><tr><td>标签计算</td><td>Spring</td><td>轻量级规则引擎，易于扩展</td></tr><tr><td>规则管理</td><td>MySQL</td><td>规则版本控制，支持回滚</td></tr><tr><td>标签存储</td><td>MySQL+Redis</td><td>冷热数据分离存储策略</td></tr><tr><td>用户行为存储</td><td>MongoDB</td><td>用户行为持久化</td></tr></tbody></table><h3 id="三、核心设计决策"><a href="#三、核心设计决策" class="headerlink" title="三、核心设计决策"></a>三、核心设计决策</h3><h4 id="1-数据采集方案"><a href="#1-数据采集方案" class="headerlink" title="1. 数据采集方案"></a>1. 数据采集方案</h4><ul><li><strong>多端统一接入</strong>：定义标准 <strong>HTTP 上报协议</strong>，统一 <code>App/Web/API</code> 多端数据接入方式，降低接入成本。</li><li><strong>区域路由策略</strong>：基于 <strong>用户标识自动路由</strong> 到相应区域采集节点，提升数据上报效率，降低网络延迟。</li><li><strong>数据校验机制</strong>：<ul><li><strong>上报数据格式校验</strong>：在采集层进行数据格式校验，过滤无效数据。</li><li><strong>去重处理</strong>：对重复上报数据进行 <strong>去重处理</strong>，保障数据质量，避免重复计算。</li></ul></li></ul><h4 id="2-消息中间件选型"><a href="#2-消息中间件选型" class="headerlink" title="2. 消息中间件选型"></a>2. 消息中间件选型</h4><table><thead><tr><th>对比维度</th><th>RabbitMQ优势</th><th>设计考量点</th></tr></thead><tbody><tr><td>运维成本</td><td>复用现有集群</td><td><strong>无需额外运维投入</strong></td></tr><tr><td>可靠性</td><td>消息持久化+ACK机制</td><td><strong>数据零丢失保障</strong></td></tr><tr><td>扩展性</td><td>集群模式支持水平扩展</td><td><strong>满足未来增长需求</strong></td></tr></tbody></table><p><strong>选型分析:</strong>  综合考虑 <strong>运维成本、可靠性和扩展性</strong> 等因素，<strong>复用现有 RabbitMQ 集群</strong> 是最优选择。RabbitMQ 集群具备良好的 <strong>消息持久化、ACK 机制和水平扩展能力</strong>，能够满足实时用户标签系统对消息队列的需求。</p><h4 id="3-计算存储架构"><a href="#3-计算存储架构" class="headerlink" title="3. 计算存储架构"></a>3. 计算存储架构</h4><table><thead><tr><th>数据类型</th><th>存储方案</th><th>设计考量点</th></tr></thead><tbody><tr><td>上报日志</td><td>MongoDB分片集群</td><td><strong>高吞吐写入，灵活 Schema</strong>，支持海量用户行为日志存储</td></tr><tr><td>标签规则</td><td>MySQL</td><td><strong>事务支持，版本管理</strong>，保障规则数据一致性和可维护性</td></tr><tr><td>标签结果</td><td>MySQL+Redis</td><td><strong>实时查询与持久化存储</strong>，兼顾实时查询性能和数据可靠性</td></tr></tbody></table><p><strong>存储选型:</strong></p><ul><li><strong>MongoDB 分片集群</strong>：适用于存储 <strong>海量、Schema 灵活</strong> 的用户行为日志数据，满足高吞吐写入需求。</li><li><strong>MySQL</strong>：适用于存储 <strong>结构化</strong> 的标签规则和标签结果数据，提供 <strong>事务支持和数据一致性</strong> 保障。</li><li><strong>Redis</strong>：适用于缓存 <strong>热点标签数据</strong>，利用其 <strong>高性能内存数据库</strong> 特性，提升标签查询效率。</li></ul><h3 id="四、性能优化实践"><a href="#四、性能优化实践" class="headerlink" title="四、性能优化实践"></a>四、性能优化实践</h3><h4 id="1-采集层优化"><a href="#1-采集层优化" class="headerlink" title="1. 采集层优化"></a>1. 采集层优化</h4><ul><li><strong>负载均衡</strong>：采用 <strong>Nginx 轮询 + 权重分配</strong> 策略，实现采集层负载均衡，<strong>单节点支持 10k QPS</strong> 高并发接入。</li><li><strong>异步处理</strong>：数据上报请求 <strong>异步化处理</strong>，降低请求响应时间，<strong>响应时间 &lt;50ms</strong>。</li><li><strong>数据压缩</strong>：采用 <strong>Gzip 压缩</strong> 技术，对上报数据进行压缩，<strong>降低 70% 网络传输量</strong>，提升传输效率。</li></ul><h4 id="2-容灾方案设计"><a href="#2-容灾方案设计" class="headerlink" title="2. 容灾方案设计"></a>2. 容灾方案设计</h4><ul><li><strong>消息重试</strong>：RabbitMQ 启用 <strong>死信队列</strong>，处理标签计算失败消息，保障数据可靠性。</li><li><strong>数据备份</strong>：MySQL 数据库进行 <strong>每日全量备份 + 增量备份</strong>，防止数据丢失。</li><li><strong>故障切换</strong>：Redis 采用 <strong>主从模式</strong> 部署，实现 <strong>主从自动切换</strong>，<strong>切换时间 &lt;30s</strong>，保障缓存服务高可用。</li></ul><h3 id="五、标签体系设计"><a href="#五、标签体系设计" class="headerlink" title="五、标签体系设计"></a>五、标签体系设计</h3><h4 id="1-标签分类模型"><a href="#1-标签分类模型" class="headerlink" title="1. 标签分类模型"></a>1. 标签分类模型</h4><pre class="mermaid">graph TD    A[用户标签] --> B(基础标签)    A --> C(行为标签)    B --> D[用户属性]    B --> E[设备信息]    C --> F[购买行为]    C --> G[浏览偏好]</pre><ul><li><strong>基础标签</strong>：描述用户的<strong>静态属性</strong>，例如：用户属性（年龄、地域）、设备信息（设备类型、操作系统）。<strong>更新机制为批量每日更新</strong>。</li><li><strong>行为标签</strong>：描述用户的<strong>动态行为</strong>，例如：购买行为（购买商品、订单金额）、浏览偏好（浏览商品类目、浏览时长）。<strong>更新机制为事件驱动实时更新</strong>。</li></ul><h4 id="2-典型场景实现：新用户转老用户逻辑"><a href="#2-典型场景实现：新用户转老用户逻辑" class="headerlink" title="2. 典型场景实现：新用户转老用户逻辑"></a>2. 典型场景实现：新用户转老用户逻辑</h4><p>以 <strong>新用户转老用户</strong> 标签更新场景为例，说明实时标签系统的应用流程：</p><ol><li><strong>监听下单事件</strong>：系统 <strong>实时监听</strong> 订单系统产生的下单事件。</li><li><strong>校验历史订单数</strong>：标签计算系统接收到下单事件后，<strong>校验用户近一年内历史订单数是否为 1</strong>。</li><li><strong>触发标签状态变更</strong>：若校验通过，则 <strong>触发用户标签状态变更</strong>，将用户标签从 “新用户” 更新为 “老用户”。</li><li><strong>推送价格策略</strong>：标签计算系统将 <strong>新的用户标签推送至商品服务</strong>。商品服务 <strong>实时更新价格策略</strong>，使用户在 <strong>&lt;500ms 内</strong> 看到商品价格折扣。</li></ol><h3 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h3><p>实时用户标签系统的成功上线，显著提升了用户标签的<strong>实时性</strong>和<strong>应用效率</strong>，为业务的<strong>精细化运营</strong>提供了强有力的数据支撑。项目在<strong>高性能、高可靠、可扩展</strong>等方面做了深入设计和优化，为后续的迭代升级奠定了坚实基础。</p><p>未来，我们将继续在以下方面进行探索和优化：</p><ul><li><strong>更智能的告警</strong>：引入 <strong>异常检测</strong> 等智能告警策略，提升问题发现和处理效率。</li><li><strong>更丰富的标签类型</strong>：扩展 <strong>用户兴趣标签、用户偏好标签</strong> 等，构建更全面的用户画像。</li><li><strong>更灵活的规则引擎</strong>：实现更负载的标签计算逻辑，提升系统灵活性。</li></ul><p>随着实时用户标签系统的不断完善，将为业务带来更大的价值，持续驱动业务增长。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、项目背景与业务价值&quot;&gt;&lt;a href=&quot;#一、项目背景与业务价值&quot; class=&quot;headerlink&quot; title=&quot;一、项目背景与业务价值&quot;&gt;&lt;/a&gt;一、项目背景与业务价值&lt;/h3&gt;&lt;p&gt;在竞争激烈的跨境电商领域，用户体验和精细化运营至关重要。为了实现&lt;strong&gt;精准营销、动态定价和运营分析&lt;/strong&gt;等关键业务场景，我们需要更及时、更准确地理解用户行为&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC(ShardingSphere)SQL监控实践</title>
    <link href="https://www.yzhu.name/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/"/>
    <id>https://www.yzhu.name/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/</id>
    <published>2023-11-25T07:54:41.000Z</published>
    <updated>2025-11-11T03:53:15.775Z</updated>
    
    <content type="html"><![CDATA[<p>最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起<span id="more"></span>。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们的需求是监控应用程序对数据库的SQL执行情况，并将其与现有的指标集成。我们希望监控以下指标（但不限于）：</p><ul><li>SQL语句的执行时间</li><li>SQL语句的执行次数</li><li>SQL语句的执行结果</li><li>SQL语句的主库和备库路由</li></ul><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>我们现有数据库相关技术栈包括MySql, Sharding-JDBC,HikariDataSource和MyBaties；在方案设计阶段，我们考虑了以下三种方案：</p><h4 id="ShardingSphere的metrics"><a href="#ShardingSphere的metrics" class="headerlink" title="ShardingSphere的metrics"></a>ShardingSphere的metrics</h4><p> ShardingSphere的agent供了SQL监控的功能，具体可参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/observability/">ShardingSphere的可观测性</a>然而，该代理会暴露一个独立的监控指标页面，无法直接集成到我们现有的监控指标页面中。我们需要单独采集ShardingSphere代理的监控指标，并将其与现有指标进行整合，这增加了一定的复杂性，因此我们放弃了该方案。</p><h4 id="Mybaties的拦截器"><a href="#Mybaties的拦截器" class="headerlink" title="Mybaties的拦截器"></a>Mybaties的拦截器</h4><p> 使用MyBatis的拦截器实现SQL监控非常简单，只需实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可。以下是一个示例代码：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line">public class SqlMetricsInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];</span><br><span class="line">        SqlCommandType sqlCommandType = mappedStatement.getSqlCommandType();</span><br><span class="line">        /** 上报sql metrics**/</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        if (target instanceof Executor) &#123;</span><br><span class="line">            return Plugin.wrap(target, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  在容器启动后，我们将该拦截器注入到MyBatis的org.apache.ibatis.session.SqlSessionFactory中：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line">private ObjectProvider&lt;Interceptor&gt; interceptorsProvider;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ObjectProvider&lt;SqlSessionFactory&gt; sqlSessionFactories;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    for (SqlSessionFactory factory : sqlSessionFactories) &#123;</span><br><span class="line">        for (Interceptor interceptor : interceptorsProvider) &#123;</span><br><span class="line">            factory.getConfiguration().addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过以上步骤，我们可以在现有的监控指标页面中看到采集到的与SQL相关的监控指标。但是，该方案无法区分主库和备库的SQL。</p><h4 id="JDBC-Statement"><a href="#JDBC-Statement" class="headerlink" title="JDBC Statement"></a>JDBC Statement</h4><p>  我们知道，最终的SQL执行是通过JDBC的Statement完成的，因此我们可以直接在JDBC的Statement执行SQL的地方上报监控指标。我们可以自定义Statement来执行SQL，并同时上报SQL的监控指标。以下是类关系图示例：<br>   <img src="/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/ShardingSphere-JDBC-SQL-Metrics-class.png"></p><p>   在<code>DalStatement</code>和<code>PreparedStatement</code> 重载<code>executeQuery</code>和<code>executeUpdate</code> 方法增加相关监控指标，具体代码可参考<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">ydal-spring-boot-starter</a></p><p>   这样可以输出类似如下的metrics上报到prometheus<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sql_execute_time_seconds_count&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 82.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 12.373654891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 14.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 167.934782891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 1.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 0.493257718</span><br></pre></td></tr></table></figure><br>   通过这种方式，我们可以在现有的监控指标页面中查看采集到的SQL监控指标，并区分主库和备库的SQL。 详细代码：<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次SQL监控的实践，我们成功地集成了SQL监控功能到我们的应用程序中，并将其与现有的指标集成在一起。这使得我们能够更好地了解应用程序对数据库的访问情况，并及时发现潜在的性能问题和瓶颈。我们选择了自定义的JDBC Statement来实现SQL监控，并通过上报监控指标的方式将其集成到现有的监控系统中。这种方案简单且有效，使我们能够对SQL执行进行精确监控，并根据需要进行进一步的优化和调整。尽管我们在本次实践中取得了成功，但我们也意识到SQL监控仅仅是性能优化和数据库访问管理的一部分。在未来的项目中，我们将继续探索更多的数据库访问优化技术，并进一步提高应用程序的性能和可伸缩性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起&lt;/p&gt;</summary>
    
    
    
    
    <category term="监控" scheme="https://www.yzhu.name/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Data Memcached集群迁移至Redis集群</title>
    <link href="https://www.yzhu.name/2023/09/09/Data-Memcached-To-Redis/"/>
    <id>https://www.yzhu.name/2023/09/09/Data-Memcached-To-Redis/</id>
    <published>2023-09-09T03:38:05.000Z</published>
    <updated>2025-11-11T03:53:15.766Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务规模的增长，我们的缓存系统面临扩展性和运维效率的挑战。近期我们团队将缓存系统从Memcached迁移到Redis集群。<span id="more"></span></p><h2 id="项目背景与迁移动机"><a href="#项目背景与迁移动机" class="headerlink" title="项目背景与迁移动机"></a>项目背景与迁移动机</h2><p>我们的缓存系统最初基于Memcached，性能表现稳定，但随着业务发展，Memcached的局限性逐渐暴露：</p><ul><li><strong>扩展性受限</strong>：Memcached集群不支持自动分片，扩容和缩容需客户端手动实现，操作繁琐且运维成本高，难以应对流量快速增长。</li><li><strong>监控能力薄弱</strong>：Memcached提供的指标有限（仅命中率、内存使用等），故障排查和告警不便，影响问题定位效率。</li><li><strong>数据类型单一</strong>：仅支持键值对，复杂业务需求需额外开发支持，效率低下。</li></ul><p>这些问题促使我们寻找替代方案，最终选择了Redis集群。迁移的目标不是提升性能，而是解决扩展性和监控问题，为未来发展预留空间。</p><h2 id="技术选型：为什么选择Redis集群"><a href="#技术选型：为什么选择Redis集群" class="headerlink" title="技术选型：为什么选择Redis集群"></a>技术选型：为什么选择Redis集群</h2><p>我们直接选择了Redis集群，原因如下：</p><ul><li><strong>成熟度</strong>：Redis的社区拥有丰富文档和活跃支持，而且我们团队在其他项目中的使用已非常成熟。</li><li><strong>功能优势</strong>：支持自动分片、丰富数据结构（如Hash、List）和内置监控，弥补Memcached的不足。</li><li><strong>团队熟悉</strong>：团队对Redis的开发和运维经验丰富，降低了学习成本。</li></ul><h2 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h2><p>迁移分为几个阶段，确保无侵入且风险可控：</p><ol><li><strong>代码改造</strong>：<ul><li>通过底层SDK适配Redis集群，封装缓存操作接口（<code>get</code>、<code>set</code>），业务代码无需改动。</li><li>配置动态切换缓存后端（Memcached或Redis）。</li></ul></li><li><strong>测试验证</strong>：<ul><li>模拟业务场景验证功能正确性。</li><li>测试Redis集群的扩容&#x2F;缩容，确保无影响。</li></ul></li><li><strong>灰度发布</strong>：<ul><li>从5%流量开始，逐步增至20%，观察一周后全量切换。</li><li>按用户维度区分流量，避免数据一致性问题。</li></ul></li><li><strong>数据过渡</strong>：<ul><li>新请求写入Redis，旧数据在Memcached过期，无需显式迁移。这种策略能有效降低迁移复杂性。但对于某些关键缓存数据，可能需要更谨慎的迁移方案。</li></ul></li><li><strong>监控支持</strong>：<ul><li>使用Prometheus和Grafana，从测试到全量全程监控Redis和业务指标。关键监控指标包括Redis的CPU使用率、内存使用率、连接数、命中率、Key的数量，以及业务相关的错误率、请求量等。</li></ul></li></ol><h2 id="挑战与解决方案"><a href="#挑战与解决方案" class="headerlink" title="挑战与解决方案"></a>挑战与解决方案</h2><p>迁移中暴露了三个主要挑战，我们逐一解决：</p><ol><li><strong>大Key问题</strong>：<ul><li><strong>挑战</strong>：Memcached节点内存大，大Key不明显；Redis集群分片内存小，大Key导致负载不均。</li><li><strong>解决方案</strong>：将大Key拆分为多个小Key（如<code>user:123</code>拆为<code>user:123:profile</code>），均匀分布。</li><li><strong>效果</strong>：内存使用率从100%降至50%。</li></ul></li><li><strong>热Key问题</strong>：<ul><li><strong>挑战</strong>：Redis分片配置低，热Key高频访问导致QPS激增。</li><li><strong>解决方案</strong>：引入本地缓存（TTL 1分钟），允许短暂不一致，优先从本地读取。</li><li><strong>效果</strong>：Redis负载减少80%。</li></ul></li><li><strong>JVM崩溃</strong>：<ul><li><strong>挑战</strong>：在流量高峰时JVM崩溃，因为系统内部使用Redisson依赖的netty与gRPC依赖的netty版本冲突。</li><li><strong>解决方案</strong>：升级Redisson到最新版。</li><li><strong>效果</strong>：崩溃问题消失。</li></ul></li></ol><h2 id="迁移成果"><a href="#迁移成果" class="headerlink" title="迁移成果"></a>迁移成果</h2><ul><li><strong>性能与稳定性</strong>：<ul><li>迁移后性能和稳定性与Memcached持平，未见提升，因目标非性能优化。</li><li>压测显示两者在20万QPS下表现相当。</li></ul></li><li><strong>用户体验</strong>：<ul><li>页面加载时间和服务稳定性无变化，用户无感知反馈。</li></ul></li><li><strong>实际价值</strong>：<ul><li><strong>扩展性</strong>：Redis集群支持动态扩容，解决了Memcached的瓶颈。</li><li><strong>监控性</strong>：丰富指标提升了运维效率。</li></ul></li></ul><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol><li><strong>无侵入SDK</strong>：降低风险，业务代码稳定。</li><li><strong>灰度发布</strong>：分阶段切换，问题可控。</li><li><strong>关闭持久化</strong>：提升性能，适配需求。为了追求更高的读写性能，我们选择关闭了Redis的持久化功能。在生产环境中，需要根据具体的业务场景权衡是否开启持久化以及选择合适的持久化策略。</li><li><strong>全面监控</strong>：实时反馈，快速响应。</li><li><strong>聚焦扩展性</strong>：明确目标，预留潜力。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次迁移让我们从Memcached的局限中解脱，Redis集群为未来增长奠定了基础。虽然性能未提升，但扩展性和监控能力的改善达到了预期。关于成本方面，迁移到Redis集群可能会带来一定的服务器成本增加，但运维效率的提升有望在长期降低总体成本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着业务规模的增长，我们的缓存系统面临扩展性和运维效率的挑战。近期我们团队将缓存系统从Memcached迁移到Redis集群。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>灰度发布过程中缓存数据一致性问题</title>
    <link href="https://www.yzhu.name/2023/05/13/Gray-Scale-Deployment-Cache-Consistency/"/>
    <id>https://www.yzhu.name/2023/05/13/Gray-Scale-Deployment-Cache-Consistency/</id>
    <published>2023-05-13T12:54:07.000Z</published>
    <updated>2025-11-11T03:53:15.768Z</updated>
    
    <content type="html"><![CDATA[<p>灰度发布是一种常见的上线策略。如果灰度发布时间较长，且在灰度期间各分组共用缓存，那么该过程中可能会面临缓存数据一致性的挑战。本文将讨论在灰度发布过程中导致缓存数据不一致的问题和解决方案。 <span id="more"></span></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通常，我们采用了灰度发布策略来确保新功能的平稳上线。我们将用户流量分为两个组（为了描述简单，假设灰度只有两个分组）：A组和B组。在灰度发布的第一阶段，我们选择将20%的流量分配给B组，将剩余的80%分配给A组。这样可以确保新功能在一部分用户中进行测试和验证，同时保持对大多数用户的稳定性。然而，在灰度发布过程中由于代码版本的不一致，导致A组和B组的缓存数据出现了不一致的情况。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在灰度发布期间可能出现以下两个场景导致数据不一致问题：</p><ol><li><p><strong>缓存增加元素：</strong> 在B组的代码版本（v2）中，我们增加了一个缓存对象的元素，但是A组的代码版本（v1）并没有包含这个元素。这导致A组写入缓存的数据，在B组读取时无法正确反序列化，导致数据解析失败。</p></li><li><p><strong>计算逻辑变化：</strong> 缓存对象的元素（e1）是逻辑计算得出的结果，在B组的代码版本（v2）中我们修改了该元素计算逻辑，但是A组的代码版本（v1）仍是旧的计算逻辑；这导致A组写入的缓存B组读出不符合预期，而B组写入的缓存A组读出不符合预期。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在面对这种缓存数据一致性问题时，我们采取了以下解决方案：</p><ol><li><p><strong>a&#x2F;b组缓存隔离</strong>：A&#x2F;B组分别访问不同的缓存，不同的分组可以连接不同的缓存或者不同的分组以不同的key前缀区分。然而实际情况是以上问题只会发生在极个别的缓存元素上。这种方案虽然能解决以上问题，但缓存数量会随着分组的增加而成倍增加，造成资源的严重浪费，同时缓存命中率也会下降。</p></li><li><p><strong>反序列化兼容增加的元素</strong>：基本所有的序列化&#x2F;反序列化组件都支持该功能。比如JDK自带的功能确保<code>serialVersionUID</code>保持不变即可，或者使用protobuf、json等序列化类库都可以实现。该方法虽然能解决A组写入B读取反序列化失败的问题，但B组反序列化成功仍然缺少新增加的元素。</p></li><li><p><strong>使用新key</strong>：在B组代码中使用新的key，这样A&#x2F;B组缓存可以彻底隔离。但对于某些底层数据结构，可能被上层很多缓存引用，而且是通过多级引用，开发人员容易遗漏某些key。</p></li><li><p><strong>版本控制</strong>：大致思路是每个缓存在key上携带本次变更的版本号。如果本次发布缓存元素没有变化，则版本号不变。具体实现过程如下：</p><ul><li>在Spring容器启动过程中获取所有标记<code>@Cacheable</code>注解的方法。</li><li>对方法返回值对象内元素按照元素类型和一定的算法计算对象code值。如果对象元素发生变化，则对象code值一定变化。如果是元素是自定义对象需要递归计算。</li><li>读写缓存时在缓存key增加code后缀。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后我们采用了<strong>版本控制</strong>的方案。在实施前，我们进行了充分的测试和验证，确保缓存的版本控制逻辑正确无误，并在灰度发布期间保持了缓存数据的一致性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;灰度发布是一种常见的上线策略。如果灰度发布时间较长，且在灰度期间各分组共用缓存，那么该过程中可能会面临缓存数据一致性的挑战。本文将讨论在灰度发布过程中导致缓存数据不一致的问题和解决方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="一致性" scheme="https://www.yzhu.name/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Session Memcached集群迁移至Redis集群</title>
    <link href="https://www.yzhu.name/2022/10/22/Session-Memcached-To-Redis/"/>
    <id>https://www.yzhu.name/2022/10/22/Session-Memcached-To-Redis/</id>
    <published>2022-10-22T14:51:20.000Z</published>
    <updated>2025-11-11T03:53:15.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>随着业务的快速发展，我们原有的 <code>session</code> 存储方案  <code>Memcached</code>  逐渐显露出一些瓶颈，主要体现在以下几个方面。：</p><ul><li><strong>扩展性受限</strong>：<code>Memcached</code> 集群不支持分片，要分片需要在客户端实现分片逻辑，<strong>扩容和缩容操作繁琐</strong>，运维成本较高，难以满足业务快速增长的需求<span id="more"></span>。</li><li><strong>监控能力薄弱</strong>：<code>Memcached</code>  提供的<strong>监控指标有限</strong>，难以全面掌握集群运行状态，<strong>故障排查和告警</strong>不够便捷。</li><li><strong>缺少持久化</strong>：<code>Memcached</code>  作为纯内存缓存，<strong>数据无法持久化</strong>，存在数据丢失风险，虽然 <code>session</code> 数据对持久化要求不高，但在某些极端情况下，数据丢失仍可能影响用户体验。</li></ul><p>为了解决  <code>Memcached</code>  的上述问题，并提升  <code>session</code>  存储的<strong>扩展性、可维护性和监控能力</strong>，我们决定将  <code>session</code>  存储方案迁移至  <strong>Redis 集群</strong>。<code>Redis</code>  集群在<strong>集群化、监控告警、数据持久化</strong>等方面都具备显著优势，能够更好地满足我们业务发展的需求。</p><h3 id="迁移方案与实施阶段"><a href="#迁移方案与实施阶段" class="headerlink" title="迁移方案与实施阶段"></a>迁移方案与实施阶段</h3><p>本次  <code>session</code>  迁移项目，我们采取了<strong>分阶段、平滑迁移</strong>的策略，最大程度降低迁移风险，保障业务的连续性和稳定性。整个迁移过程分为三个阶段：</p><pre class="mermaid">graph TD    subgraph "第一阶段"        A1[应用服务] --> |写| B1[Memcached]        A1 --> |写| C1[Redis]        B1 --> |读| A1    end        subgraph "第二阶段"        A2[应用服务] --> |写| B2[Memcached]        A2 --> |写| C2[Redis]        C2 --> |读| A2    end        subgraph "第三阶段"        A3[应用服务] --> |写| C3[Redis]        C3 --> |读| A3        B3[Memcached] -.-> |停止写入| A3    end</pre><ul><li><p><strong>第一阶段：双写 Memcached 和 Redis，读 Memcached</strong></p><ul><li><strong>目标</strong>：验证  <code>Redis</code>  集群的稳定性和性能，为后续切换读取流量做好数据准备。</li><li><strong>策略</strong>：应用系统同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>只从  <code>Memcached</code>  读取  <code>session</code>  数据</strong>。</li><li><strong>数据一致性保障</strong>：<strong>双写成功才算成功</strong>，确保  <code>Memcached</code>  和  <code>Redis</code>  数据一致性。任何写入失败都会记录详细日志并触发告警，方便后续数据补偿。</li><li><strong>持续时间</strong>：为了保证  <code>Redis</code>  集群中  <code>session</code>  数据的完整性，双写阶段持续 <strong>30 天</strong>，覆盖  <code>session</code>  的最长过期时间，确保  <code>Redis</code>  集群拥有全量  <code>session</code>  数据。</li></ul></li><li><p><strong>第二阶段：双写 Memcached 和 Redis，读 Redis</strong></p><ul><li><strong>目标</strong>：将读取流量平滑切换到  <code>Redis</code>  集群，验证  <code>Redis</code>  集群在高并发读取场景下的性能表现。</li><li><strong>策略</strong>：应用系统仍然同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>读取操作切换至  <code>Redis</code>  集群</strong>。</li><li><strong>平滑切换</strong>：采用<strong>灰度发布</strong>策略，逐步将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，降低切换风险。</li><li><strong>回滚准备</strong>：<strong>保留  <code>Memcached</code>  的写入</strong>，为后续可能的回滚操作预留数据基础。</li></ul></li><li><p><strong>第三阶段：停止 Memcached 写入，读 Redis</strong></p><ul><li><strong>目标</strong>：完全切换到  <code>Redis</code>  集群，停用  <code>Memcached</code>。</li><li><strong>策略</strong>：<strong>停止向  <code>Memcached</code>  写入  <code>session</code>  数据</strong>，所有读写操作均转向  <code>Redis</code>  集群。</li><li><strong>风险评估</strong>：在进入第三阶段前，进行全面的<strong>风险评估</strong>，确认系统运行稳定，各项监控指标正常。由于第二阶段已经验证了  <code>Redis</code>  集群的读取能力，且  <code>Memcached</code>  写入持续运行，因此第三阶段的风险较低。</li></ul></li></ul><h3 id="关键技术挑战与解决方案"><a href="#关键技术挑战与解决方案" class="headerlink" title="关键技术挑战与解决方案"></a>关键技术挑战与解决方案</h3><p>在  <code>session</code>  迁移过程中，我们主要面临以下技术挑战：</p><ul><li><strong>数据一致性</strong>：在双写阶段，如何保证  <code>Memcached</code>  和  <code>Redis</code>  的数据一致性至关重要。我们通过<strong>双写强一致性策略</strong>和完善的<strong>异常监控告警机制</strong>来解决这个问题。</li><li><strong>平滑切换</strong>：如何平滑地将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，避免对用户体验造成影响。我们采用<strong>灰度发布</strong>策略，逐步切换流量，并密切监控系统运行状态。</li><li><strong>性能保障</strong>：<code>Redis</code>  集群在高并发场景下的性能是否能够满足需求，需要进行充分的验证。我们在第二阶段通过<strong>全量流量读取  <code>Redis</code>  集群</strong>，验证了  <code>Redis</code>  集群的性能表现。</li><li><strong>监控与回滚</strong>：如何全面监控迁移过程，及时发现和处理异常，并制定完善的回滚方案，保障迁移过程的安全可控。利用我们<strong>完善的监控体系</strong>，针对每个阶段制定了详细的<strong>回滚计划</strong>。</li></ul><h3 id="性能监控与回滚方案"><a href="#性能监控与回滚方案" class="headerlink" title="性能监控与回滚方案"></a>性能监控与回滚方案</h3><p>为了保障  <code>session</code>  迁移项目的平稳落地，我们建立了完善的性能监控和回滚方案：</p><h4 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h4><p>在整个迁移过程中，我们重点监控以下关键指标：</p><ul><li><strong>Redis 集群性能指标</strong>：<ul><li><strong>CPU 使用率、内存使用率</strong>：监控  <code>Redis</code>  集群资源使用情况，判断集群是否过载。</li><li><strong>请求延迟</strong>：监控  <code>Redis</code>  请求响应时间，评估  <code>Redis</code>  集群性能是否满足需求。</li><li><strong>错误率</strong>：监控  <code>Redis</code>  请求错误率，及时发现  <code>Redis</code>  集群异常。</li><li><strong>大key和热key</strong>：关注  <code>Redis</code>  的流量和CPU变化是否出现<strong>大key和热key</strong>。</li></ul></li><li><strong>Session 读写成功率</strong>：<ul><li><strong>Redis  <code>session</code>  读取成功率</strong>：监控从  <code>Redis</code>  集群读取  <code>session</code>  的成功率，确保读取操作正常。</li><li><strong>Redis  <code>session</code>  写入成功率</strong>：监控向  <code>Redis</code>  集群写入  <code>session</code>  的成功率，确保写入操作正常。</li><li><strong>Memcached  <code>session</code>  写入成功率</strong>：在双写阶段，监控向  <code>Memcached</code>  写入  <code>session</code>  的成功率，确保双写操作正常。</li></ul></li><li><strong>应用系统业务指标</strong>：<ul><li><strong>接口响应时间</strong>：监控应用系统接口响应时间，评估迁移对应用系统性能的影响。</li><li><strong>错误率</strong>：监控应用系统错误率，评估迁移是否引入新的错误。</li><li><strong>登录用户指标</strong>：监控登录用户数量变化，判断迁移是否影响用户登录。</li><li><strong>各阶段转化率</strong> (加购，生单，支付)：监控用户在各个关键业务流程的转化率，评估迁移是否对业务指标造成负面影响。</li></ul></li></ul><h4 id="2-回滚方案"><a href="#2-回滚方案" class="headerlink" title="2. 回滚方案"></a>2. 回滚方案</h4><ul><li><strong>回滚触发</strong>：当监控指标出现异常，例如：应用系统接口响应时间显著增加、业务指标出现明显波动等情况时，立即触发回滚。</li><li><strong>回滚步骤</strong>：<ol><li><strong>流量切换</strong>：立即将  <code>session</code>  读取流量<strong>回退到  <code>Memcached</code></strong>。由于第二阶段持续保持  <code>Memcached</code>  写入，<code>Memcached</code>  中仍然保有全量  <code>session</code>  数据，可以快速切换回读。</li><li><strong>问题排查</strong>：回滚后，立即排查  <code>Redis</code>  集群异常原因，修复问题。</li><li><strong>重新迁移</strong>：待问题解决后，重新评估并选择合适的时机再次进行迁移。</li></ol></li></ul><p>由于我们在第二阶段已经进行了充分的  <code>Redis</code>  集群读取验证，并且在第三阶段前进行了全面的风险评估，因此实际上<strong>并未触发回滚</strong>。  <strong>第二阶段保留  <code>Memcached</code>  写入的主要目的就是为了应对可能的回滚场景</strong>，为系统提供一层额外的安全保障。</p><h3 id="项目总结与收益"><a href="#项目总结与收益" class="headerlink" title="项目总结与收益"></a>项目总结与收益</h3><p><code>session</code> 从 <code>Memcached</code> 平滑迁移至 <code>Redis</code> 集群项目，历时数月，整个迁移过程较为顺利，最终<strong>平稳落地，达到预期目标</strong>。通过本次迁移，我们成功解决了 <code>Memcached</code> 在<strong>扩展性、监控能力</strong>等方面的瓶颈，为业务发展提供了更可靠、更高效的 <code>session</code> 存储方案。</p><p><strong>项目收益总结</strong>：</p><ul><li><strong>提升扩展性</strong>：<code>Redis</code> 集群具备良好的<strong>水平扩展能力</strong>，可以轻松应对未来 <code>session</code> 数据量的增长。相比原来需要在客户端实现分片的 <code>Memcached</code> 方案，<code>Redis</code> 集群的扩容和缩容操作更加简单直观，极大降低了运维成本。</li><li><strong>增强监控能力</strong>：<code>Redis</code> 集群提供<strong>更丰富的监控指标</strong>，并能与 <code>Prometheus</code> 等监控系统方便集成，提升运维效率。</li><li><strong>性能稳定</strong>：迁移后系统性能与原 <code>Memcached</code> 方案基本持平，但在运维性和可扩展性方面获得了显著提升，为未来业务增长预留了充足的扩展空间。</li><li><strong>为未来优化奠定基础</strong>：迁移至 <code>Redis</code> 集群，为后续 <code>session</code> 存储的<strong>性能优化、功能增强</strong>（例如，利用 <code>Redis</code> 更丰富的数据结构实现更复杂的 <code>session</code> 管理功能）奠定了基础。</li></ul><p>本次  <code>session</code>  迁移项目，  <strong>分阶段平滑迁移策略、完善的监控回滚方案、以及对数据一致性的高度重视</strong>，是项目成功的关键因素。  这些经验也为我们后续进行类似的大型系统迁移项目提供了宝贵的参考.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h3&gt;&lt;p&gt;随着业务的快速发展，我们原有的 &lt;code&gt;session&lt;/code&gt; 存储方案  &lt;code&gt;Memcached&lt;/code&gt;  逐渐显露出一些瓶颈，主要体现在以下几个方面。：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩展性受限&lt;/strong&gt;：&lt;code&gt;Memcached&lt;/code&gt; 集群不支持分片，要分片需要在客户端实现分片逻辑，&lt;strong&gt;扩容和缩容操作繁琐&lt;/strong&gt;，运维成本较高，难以满足业务快速增长的需求&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用Apache HttpClinet连接池默认大小引发耗时瞬间升高</title>
    <link href="https://www.yzhu.name/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/"/>
    <id>https://www.yzhu.name/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/</id>
    <published>2022-07-30T05:54:02.000Z</published>
    <updated>2025-11-11T03:53:15.772Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由<code>HttpURLConnection</code>,<code>Apache HttpComponents</code>和<code>OkHttp</code>三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高<span id="more"></span></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>今天天收到报警说我们有一个服务A的接口TP95瞬间升高，打开监控检查发现流量瞬间升高时，耗时会瞬间升高，如图所示；<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/monitor.jpg" alt="图一"><br>打开链路跟踪查看调用链关系，发现该时接口耗时几乎全部耗费在调用下游服务B，如图所示；正常情况下服务B接口TP95耗时在500毫秒以内<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/opentracing.jpg" alt="图二"><br>而且该服务接口连接超时设置2秒，读取超时设置2秒；所以预期内该接口在4秒内应该结束。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="监控检查"><a href="#监控检查" class="headerlink" title="监控检查"></a>监控检查</h4><ol><li>查看服务B的监控发现服务B的耗时一直很稳定，几乎没有波动</li><li>查看服务C对服务B相同接口的调用在该时刻也很稳定</li><li>查看服务A的GC监控，gc最长耗时60ms，也不会引起该问题 </li><li>查看网络监控，一切正常</li></ol><p>通过监控数据基本确定问题不在服务B，另外Ops工程师反馈近期也没做过任何infrastrucre调整；基本确定问题仍然在服务A，接下来review服务A请求服务B的相关代码</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>服务A代码中用<code>RestTemplate</code>调用服务B的接口, <code>RestTemplate</code>的Bean采用默认注入的Builder来生成，而且设置了连接超时和读取超时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">    return builder.setReadTimeout(Duration.ofMillis(readTimeoutConfig)).setConnectTimeout(Duration.ofMillis(connectTimeoutConfig)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码形式<code>RestTemplate</code>底层实现采用了<code>Apache HttpComponents</code>作为HTTP客户端，<code>Apache HttpComponents</code>在初始化过程中会用默认参数初始化连接池，最终代码会执行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public PoolingHttpClientConnectionManager(</span><br><span class="line">    final HttpClientConnectionOperator httpClientConnectionOperator,</span><br><span class="line">    final HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span><br><span class="line">    final long timeToLive, final TimeUnit tunit) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.configData = new ConfigData();</span><br><span class="line">    this.pool = new CPool(new InternalConnectionFactory(</span><br><span class="line">            this.configData, connFactory), 2, 20, timeToLive, tunit);</span><br><span class="line">    this.pool.setValidateAfterInactivity(2000);</span><br><span class="line">    this.connectionOperator = Args.notNull(httpClientConnectionOperator, &quot;HttpClientConnectionOperator&quot;);</span><br><span class="line">    this.isShutDown = new AtomicBoolean(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码第7行构造<code>CPool</code>时传递的常量<code>2</code>表示连接池请求相同域名最大连接数，<code>20</code>表示连接池访问所有域名的最大连接数 。</p><p>至此，问题已然清楚，当zeus-order请求量瞬间升高时zeus-order访问zeus的并发量也瞬间增大，如果超过2个并发的HTTP请求只能等待，由于没有设置从连接池获取连接的超时时间，会无限等待，直到连接池内有空闲的HTTP连接然后获取连接继续发出HTTP请求，这样整个请求耗时将可能超过设置的HTTP超时时间</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>基于以上分析，我们使用自定义的HttpClient传递相关参数即可，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        PoolingHttpClientConnectionManager connectMgr = new PoolingHttpClientConnectionManager() ;</span><br><span class="line">        connectMgr.setDefaultMaxPerRoute(defaultMaxPerRoute);</span><br><span class="line">        connectMgr.setMaxTotal(maxTotal);</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connectMgr)</span><br><span class="line">                .build();</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">                new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        requestFactory.setConnectTimeout(connectTimeoutConfig);</span><br><span class="line">        requestFactory.setReadTimeout(readTimeoutConfig);</span><br><span class="line">        requestFactory.setConnectionRequestTimeout(connectRequestTimeoutConfig);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(requestFactory);</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>自定义三个超时时间：<br><strong>connectTimeout</strong>:            建立连接的超时时间<br><strong>readTimeout</strong>:               读取数据的超时时间<br><strong>connectionRequestTimeout</strong>:  从连接池获取连接的超时时间</p><p>修改以后上线观察一天即时出现上述问题的高峰瞬间，耗时始终保持平稳。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由&lt;code&gt;HttpURLConnection&lt;/code&gt;,&lt;code&gt;Apache HttpComponents&lt;/code&gt;和&lt;code&gt;OkHttp&lt;/code&gt;三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高&lt;/p&gt;</summary>
    
    
    
    
    <category term="线上问题" scheme="https://www.yzhu.name/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基础组件升级策略与实践</title>
    <link href="https://www.yzhu.name/2022/03/26/Infra-Component-Upgrade/"/>
    <id>https://www.yzhu.name/2022/03/26/Infra-Component-Upgrade/</id>
    <published>2022-03-26T12:35:29.000Z</published>
    <updated>2025-11-11T03:53:15.768Z</updated>
    
    <content type="html"><![CDATA[<p>基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法； <span id="more"></span></p><h2 id="为什么需要基础组件"><a href="#为什么需要基础组件" class="headerlink" title="为什么需要基础组件"></a>为什么需要基础组件</h2><p>为什么我们的系统要引入基础组件，使用基础组件由什么优势,以下根据个人体会列出了几点：</p><ol><li>提高开发效率：基础组件为提供了可重用、可定制和可扩展的组件和库。通过使用这些组件，开发团队能够快速搭建系统，并在不必从头开始编写代码的情况下实现常见功能。这大大提高了开发效率，缩短了产品上线时间</li><li>降低开发成本：通过使用成熟的基础组件，我们能够减少自主开发和维护的工作量。这意味着可以节省开发资源，并将精力集中在增值业务和创新上。</li><li>统一标准和规范：基础组件有助于确保在整个系统中使用一致的标准和规范。这种一致性使得不同团队的开发人员能够更好地协同工作，并减少因为不一致性而导致的问题。例如，使用统一的redis客户端组件限制一些危险命令的使用。</li><li>提升系统可靠性和稳定性：基础组件经过专业的设计和测试，通常具有高度可靠性和稳定性。它们被广泛使用和验证，可以减少系统中的错误和故障。而且，这些组件通常具有自动化的监控和错误处理机制，能够及时发现和处理潜在的问题，提高系统的稳定性。</li><li>解偶业务系统与中间件，平台之间的代码：提高系统的稳定性，方便维护，开发人员聚焦到业务功能开发；</li><li>提高管理效率，通过技术手段将操作流程规范化</li><li>安全性：确保系统采用安全大版本</li></ol><h2 id="为什么进行基础组件升级"><a href="#为什么进行基础组件升级" class="headerlink" title="为什么进行基础组件升级"></a>为什么进行基础组件升级</h2><ol><li>修复组件Bug,提高系统稳定性: 随着时间的推移,基础组件中会暴露出各种Bug,这些Bug可能会导致系统崩溃或业务异常。升级组件可以修复已知的Bug,提高系统稳定性。</li><li>获取最新功能特性,满足业务需要：基础组件推出新版本时,通常会提供新的功能和特性。业务需求瞬息万变,升级组件可以获得最新功能来满足业务需求。</li><li>改善性能,提升效率：新版本的基础组件通常在性能和效率上有改进,如增加缓存、优化算法等。升级后可以减少响应时长,提升系统吞吐量。</li><li>优化资源利用,降低成本：基础组件的新版本可能在资源调度和分配上进行了优化,可以提高资源利用率,降低系统运营成本。</li><li>提高开发效率：新版本组件通常会优化API设计,提高开发效率。同时修复Bug也可以减少开发调试时间。</li><li>解除对旧版的依赖：旧版本组件停止维护后,存在安全风险和兼容性问题。升级可以避免对旧版组件的依赖。</li><li>减少技术债务：使用了较旧版本的基础组件，可能会有技术债务积累，包括安全漏洞、性能瓶颈等；升级基础组件是控制技术债务的重要措施之一，积压的技术债务会制约公司发展</li><li>处理兼容性问题: 随着系统的发展和业务的扩展，可能需要与其他系统进行集成和交互，升级基础组件可以提供更好的兼容性和互操作性；</li></ol><h2 id="升级前的准备工作"><a href="#升级前的准备工作" class="headerlink" title="升级前的准备工作"></a>升级前的准备工作</h2><p>在进行基础组件升级之前，进行充分的准备工作是至关重要的，这可以帮助确保升级过程的顺利进行并最小化潜在风险。以下是升级前需要做的一些准备工作：</p><ol><li>明确目标： 定义升级的具体目标，明确您希望通过升级实现的业务和技术目标。了解升级所需的功能、性能、安全性等需求。</li><li>收集现有信息： 收集关于当前系统和基础组件的详细信息，包括版本、依赖关系、功能和性能特征等。这将有助于为升级过程做出更准确的决策。</li><li>评估风险和影响： 识别潜在的风险和影响范围，包括与升级相关的功能中断、兼容性问题、性能下降等。评估这些风险的严重程度，以便制定应对策略。</li><li>数据策略： 在进行升级之前，确保对系统进行完整的备份。如果升级中出现问题，可以回滚到之前的状态。对于数据库等有状态的组件，可以创建快照； </li><li>制定升级计划： 制定详细的升级计划，包括升级的步骤、时间表、责任人等。确定升级过程中需要涉及的各方，并为他们提供清晰的指导。对于较大范围升级工作，可以拆分为多个里程碑，尽可能保证每个步骤影响范围降到最低；</li><li>制定回滚计划： 确定如何还原系统到升级前的状态，以便在紧急情况下进行干预。原则上对升级操作的每个步骤都有对应的回滚步骤，如果不能回滚的场景下必须给出快速解决的方法。</li><li>测试环境预演： 在测试环境中进行升级的测试预演，以模拟真实生产环境。测试环境应该尽可能地与生产环境相似，以便更准确地预测升级可能的影响。</li><li>性能和压力测试： 在压测环境中进行压力测试，以评估新版本基础组件在不同负载条件下的表现。这有助于预测在生产环境中可能出现的问题。</li><li>制定上线计划通知所有相关方</li><li>用户培训： 如果新版本引入了新的特性或变化，为团队成员提供培训，确保他们熟悉和适应新版本。</li></ol><h2 id="升级实践"><a href="#升级实践" class="headerlink" title="升级实践"></a>升级实践</h2><ol><li>版本选择： 仔细评估新版本的功能、性能和安全特性。选择与业务需求最匹配的版本，同时考虑其稳定性和用户反馈,重点关注开源社区对issue list。</li><li>兼容性检查： 检查新版本与现有系统的兼容性。确保新版本不会破坏现有的功能和集成。</li><li>测试环境验证： 在测试环境中进行升级测试，尽量模拟真实生产环境，确保测试到各种可能影响到的场景。</li><li>自动化测试： 针对关键业务场景和功能，创建自动化测试用例。这有助于快速验证新版本的稳定性和正确性。</li><li>性能测试： 在压测环境中进行压力测试，以评估新版本在不同负载条件下的表现。识别潜在的性能问题。</li><li>数据迁移计划： 如果升级涉及数据存储系统，制定数据迁移计划。确保数据的完整性和一致性。</li><li>备份和回滚： 在进行任何升级操作之前，确保对系统进行全面备份。制定回滚计划，以便在升级过程中遇到问题时能够迅速还原。</li><li>灰度发布： 如果条件许可尽可能采用渐进式发布策略，将新版本逐步引入生产环境，以减少风险。</li><li>监控和报警： 升级后留意监控和报警，以便实时监控系统的性能和稳定性，及时发现并快速解决潜在问题。</li></ol><h2 id="升级后的监测与迭代"><a href="#升级后的监测与迭代" class="headerlink" title="升级后的监测与迭代"></a>升级后的监测与迭代</h2><ol><li>性能监测： 持续监测系统的性能，包括响应时间、吞吐量、延迟等。比较升级前后的性能数据，确保新版本不会导致性能下降。</li><li>稳定性监测： 监测系统的稳定性，识别是否存在崩溃、死锁、内存泄漏等问题。及时处理并解决这些问题，以确保系统不会因此而崩溃或变得不稳定。</li><li>资源利用率监测： 监测服务器、内存、CPU、网络等资源的利用率。确保新版本不会导致资源耗尽。</li><li>错误日志报警： 关注错误日志报警，确保升级后不会出现更多错误，防止问题升级为严重故障。</li><li>快速响应和修复： 如果发现了严重问题，确保能够快速响应并进行修复。灵活地进行紧急发布，以解决可能影响业务的问题。</li><li>收集用户的反馈: 了解用户在使用新版本时遇到的问题，帮助用户解决问题或在在后续版本修复。</li></ol><h2 id="设计基础组件的注意事项"><a href="#设计基础组件的注意事项" class="headerlink" title="设计基础组件的注意事项"></a>设计基础组件的注意事项</h2><p>在设计基础组件时，有一些注意事项可以考虑，以确保其可靠性、可扩展性和易用性。以下是一些常见的注意事项：</p><ol><li>定义清晰的接口：确保组件的功能和接口定义清晰明确。这将帮助其他开发人员理解如何正确使用组件，并减少潜在的集成问题。</li><li>高可用性和容错性：基础组件通常是系统中不可或缺的一部分，因此必须具备高可用性和容错性。考虑使用冗余、自动故障转移和负载均衡等机制来提高系统的可用性。</li><li>可扩展性：设计组件时要考虑到系统未来的扩展需求。确保组件可以水平扩展，以应对增加的负载和数据量。</li><li>安全性：基础组件通常处理敏感数据和关键业务逻辑，因此安全性是至关重要的。实施适当的安全措施，如身份验证、访问控制和数据加密等，以保护组件免受潜在的威胁。</li><li>性能优化：确保组件在处理大量请求和数据时能够提供良好的性能表现。使用高效的算法和数据结构，并进行性能测试和优化，以确保组件能够满足系统的性能需求。</li><li>文档和日志记录：提供清晰、详细的文档和日志记录，以便开发人员和运维团队能够理解组件的工作原理和故障排查方法。</li><li>监控和警报：实施监控和警报机制，以及时检测和响应组件的问题。监控关键指标，并设置警报以便在出现异常情况时及时通知相关人员。</li><li>版本控制和发布管理：使用版本控制系统来管理组件的代码和配置，确保可追溯性和可靠的发布管理。考虑使用自动化工具和流程来简化部署和升级过程。</li><li>可测试性：设计组件时要考虑到测试的可行性。提供适当的接口和工具，以便开发人员能够方便地编写和运行单元测试、集成测试和端到端测试。</li><li>与其他组件的集成：如果组件需要与其他组件进行集成，要确保接口和数据格式的兼容性，并进行充分的集成测试，以验证组件的正确性和稳定性。</li><li>遵循规范：组件实现需要遵循行业设计规范和标准,以提升互操作性</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法；&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于protobuf的定义在跨语言消息传递中的应用</title>
    <link href="https://www.yzhu.name/2021/09/21/message-dsl-base-protobuff/"/>
    <id>https://www.yzhu.name/2021/09/21/message-dsl-base-protobuff/</id>
    <published>2021-09-21T09:46:14.000Z</published>
    <updated>2025-11-11T03:53:15.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中<span id="more"></span>通常通过文档约定消息格式各自定义自己的消息体。在我们实际使用过程中发现不同语言之间传递信息还是会出现一些问题；比如：Java用fastjson输出复杂数据在Go项目解析失败，而且各语言在配置mq参数时候有各自的约定,人工操作容易引起误操作，所以我们希望能有一套跨语言的工具能分别生出各自语言的代码和配置。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>现有系统跨语言之间RPC的调用我们采用了gRPC,很自然的想到可以借鉴gRPC Protobuf定义消息体。具体方法就是扩展<code>google.protobuf.MethodOptions</code>定义</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>下面以RabbitMQ为例，在Protobuf文件中定义MQ相关参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extend google.protobuf.MethodOptions &#123;</span><br><span class="line">    </span><br><span class="line">    // exchange类型: topic direct fanout ,默认: direct</span><br><span class="line">    string routeType = 7010101;</span><br><span class="line"></span><br><span class="line">// producer 发送到exchange上有效的routekey; 仅topic模式有效</span><br><span class="line">    repeated string routeKey = 7010102;</span><br><span class="line"></span><br><span class="line">    //consumer监听的队列名称，direct模式 该参数无效</span><br><span class="line">    repeated string listener = 7010103;</span><br><span class="line"></span><br><span class="line">   // 延迟队列的延迟时间</span><br><span class="line">   int32 delay = 6010106;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>: 如果exchange为topic模式，监听队列绑定的routekey必须根据此处定义的routKey定义设置;比如文件定义的routeKey是a.b.c则consumer端绑定到队列的routkey只能是 a.b.c, a.b.<em>, a.</em>, * 其中之一</p><h5 id="生产Java代码"><a href="#生产Java代码" class="headerlink" title="生产Java代码"></a>生产Java代码</h5><p>通常在Maven工程中我们使用<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成gRPC的Java代码。现在我们可以扩展<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成MQ的代码。核心扩展点如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @Mojo(</span><br><span class="line">        name = &quot;compile-mq&quot;,</span><br><span class="line">        defaultPhase = LifecyclePhase.GENERATE_SOURCES,</span><br><span class="line">        requiresDependencyResolution = ResolutionScope.COMPILE,</span><br><span class="line">        threadSafe = true</span><br><span class="line">)</span><br><span class="line">public class ProtocCompileMQMojo extends AbstractProtocCompileMojo&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</span><br><span class="line">        super.execute();  </span><br><span class="line">        // 利用 DescriptorProtos.FileDescriptorSet 读取proto文件的定义根据规范生出Java文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配合MQ的SDK可以大大提高开发效率而且减低配置的复杂性。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>消息的可靠投递</title>
    <link href="https://www.yzhu.name/2021/04/13/reliable-message-delivery/"/>
    <id>https://www.yzhu.name/2021/04/13/reliable-message-delivery/</id>
    <published>2021-04-13T09:43:57.000Z</published>
    <updated>2025-11-11T03:53:15.777Z</updated>
    
    <content type="html"><![CDATA[<p>在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递<span id="more"></span>,即：不能丢消息。</p><h3 id="MQ消费术语"><a href="#MQ消费术语" class="headerlink" title="MQ消费术语"></a>MQ消费术语</h3><pre><code>为了保证保证消息的可靠投递，先了解一下MQ的消费术语</code></pre><ul><li><p>At Lest Once(至少一次)<br> 消息在消费的过程中，至少被发送到一个consumer; 如果consumer处理失败，会再次发送到consumer； 所以消息可能会重复被消费，通常会要求consumer保证幂等性</p></li><li><p>At Most Once(至多一次)<br> 消息在消费的过程中，至多被一个consumer消费; 如果consumer处理失败，消息可能会丢失；只能用于可接受消息丢失的场景  </p></li><li><p>Exactly Once(仅有一次)<br>  发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。常用MQ产品没有太多理想的实现 。</p></li></ul><h3 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h3><p>我们以<a href="https://www.rabbitmq.com/">RabbitMQ</a>为例从以下几个方面保证说明如何实现消息的可靠投递</p><h4 id="消息中间件可靠性"><a href="#消息中间件可靠性" class="headerlink" title="消息中间件可靠性"></a>消息中间件可靠性</h4><ul><li>使用RabbitMQ的集群模式，basic模式和镜像模式都可以保证消息不丢失；根据业务特点在吞吐量和高可用之间权衡选择合适的集群模式</li><li>确保exchange和queue的持久化</li></ul><h4 id="生产端可靠性"><a href="#生产端可靠性" class="headerlink" title="生产端可靠性"></a>生产端可靠性</h4><ul><li>发送消息时候设置消息持久化属性<strong>DeliverModel</strong> </li><li>消息持久化到数据库状态为发送中</li><li>消息到达exchange开启confirm模式，生产者发送完消息后等待broker的ack，超过一定时间没有收到broker的ack后启动job重试，直到收到broker的ack，数据库消息状态更新为已发送</li><li>消息未到达队列开启回退机制，如果消息从exchange无法投递到队列，回调通知调用者，调用者可以重试</li></ul><h4 id="消费端的可靠性"><a href="#消费端的可靠性" class="headerlink" title="消费端的可靠性"></a>消费端的可靠性</h4><ul><li>消费端确保消息处理逻辑的幂等性</li><li>关闭自动ack</li><li>消费端每处理完一次消息后手动回复ack; 如果处理消息程失败回复nack, 默认情况下broker会继续下发消息直到消费成功；注意：消息处理失败必须回复nack，否则broker认为该consumer节点down，不再下发消息到该节点</li></ul><h4 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h4><p>对中间件，存储系统，应用等增加监控，在出现问题的时候能第一时间发现</p><p>综上所述，为了保证消息的可靠投递我们需要从开发和运维的角度去考虑；确保每一个环节都能可靠。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>跨境电商支付系统重构实战：从单体到微服务的演进</title>
    <link href="https://www.yzhu.name/2021/01/09/Payement-Rebuild/"/>
    <id>https://www.yzhu.name/2021/01/09/Payement-Rebuild/</id>
    <published>2021-01-09T02:09:08.000Z</published>
    <updated>2025-11-12T14:41:51.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们的支付系统最初作为单体应用的子模块存在，随着业务规模扩大，高并发下的<strong>掉单</strong>和<strong>重复支付</strong>问题频发，日均人工对账成本高达数小时。为解决这些痛点并支持未来业务扩展，我们决定将支付系统重构为独立的微服务架构，核心目标包括：<span id="more"></span><br><strong>稳定性</strong>：消除中间状态不一致导致的掉单<br><strong>可扩展性</strong>：快速接入新的支付渠道<br><strong>可维护性</strong>：降低模块耦合，提升迭代效率</p><h2 id="系统架构概览"><a href="#系统架构概览" class="headerlink" title="系统架构概览"></a>系统架构概览</h2><p>新的支付系统采用微服务架构并使用Docker部署，主要分为以下四个子服务：</p><table><thead><tr><th>服务名称</th><th>职责描述</th><th>特性要求</th></tr></thead><tbody><tr><td><code>pay-front</code></td><td>处理用户端支付请求，高并发优化</td><td>秒级弹性扩展</td></tr><tr><td><code>pay-backend</code></td><td>对接后端系统（如 OMS），保障交易稳定性</td><td>99.99% 可用性</td></tr><tr><td><code>pay-admin</code></td><td>管理后台配置（支付路由、规则）</td><td>配置变更秒级生效</td></tr><tr><td><code>pay-job</code></td><td>执行定时任务（对账、退款补偿）</td><td>分布式任务调度</td></tr></tbody></table><h4 id="服务间交互"><a href="#服务间交互" class="headerlink" title="服务间交互"></a>服务间交互</h4><ul><li><strong>pay-front:</strong> 接收到用户支付请求后，调用第三方支付渠道的接口进行支付处理。支付成功后通过 RabbitMQ 推送支付成功消息。</li><li><strong>pay-backend:</strong> 通过RPC接口接收来自后端系统（如 OMS）的查询和人工退款请求。</li><li><strong>pay-admin:</strong> 通过操作数据库（主库）来管理支付规则、支付路由等配置，并会主动使Redis缓存中的相关配置失效，使得下次用户请求时能够从数据库加载最新的配置。</li><li><strong>pay-job:</strong> 主要与数据库进行交互，执行定时任务，例如检查长时间处于中间状态的订单（支付中、退款中），并同步第三方支付渠道的状态来更新订单的最终状态。</li></ul><h4 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h4><p><strong>主从分离 + 读写隔离</strong>：</p><pre class="mermaid" style="text-align: center;">                        graph TD    A[主库（写）] --> B[从库1（pay-front读）]    A --> C[从库2（其他服务读）]          </pre><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>为了降低学习成本和提高开发效率，我们选择了团队目前最熟悉的技术栈：</p><ul><li><strong>开发语言:</strong> Java</li><li><strong>微服务框架:</strong> SpringCloud</li><li><strong>配置中心和注册中心:</strong> Consul</li><li><strong>缓存:</strong> Redis集群</li><li><strong>数据库:</strong> MySQL 主从分离</li><li><strong>消息队列:</strong> RabbitMQ</li><li><strong>链路跟踪</strong> Jaeger</li><li><strong>监控报警</strong>：Prometheus+Grafana+AlertManager</li><li><strong>日志</strong>：ELK</li><li><strong>容器化:</strong> Docker</li></ul><h2 id="核心功能实现"><a href="#核心功能实现" class="headerlink" title="核心功能实现"></a>核心功能实现</h2><p>新的支付系统涵盖了跨境电商支付的核心功能，包括：</p><ul><li>下单支付</li><li>退款</li><li>支付查询</li><li>对账</li><li>与全球10+三方支付渠道的集成</li></ul><h4 id="幂等性保障"><a href="#幂等性保障" class="headerlink" title="幂等性保障"></a>幂等性保障</h4><p><strong>问题</strong>：第三方支付回调重复导致订单状态混乱</p><p><strong>解决方案</strong>：</p><ul><li><strong>幂等 Key 生成</strong>：<code>订单号+支付渠道+时间戳</code>哈希值</li><li><strong>存储层校验</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO payment (id, order\_id, status, version)&amp;#x20;</span><br><span class="line"></span><br><span class="line">VALUES (?, ?, &#x27;PROCESSING&#x27;, 1)&amp;#x20;</span><br><span class="line"></span><br><span class="line">ON DUPLICATE KEY UPDATE version=version+1;</span><br></pre></td></tr></table></figure><p><strong>第三方透传</strong>：在请求参数中携带幂等 Key，确保唯一请求标识</p><h4 id="最终一致性保障"><a href="#最终一致性保障" class="headerlink" title="最终一致性保障"></a>最终一致性保障</h4><p><strong>中间状态处理流程</strong>：</p><pre class="mermaid" style="text-align: center;">                        sequenceDiagram    participant User    participant pay-front    participant 第三方支付    participant pay-job        User->>pay-front: 用户在电商平台发起支付    pay-front->>第三方支付: 携带幂等Key请求    第三方支付-->>pay-front: 返回支付中    pay-front->>pay-job: 记录中间状态    pay-job->>第三方支付: 定时查询状态（每5分钟）    第三方支付-->>pay-job: 返回最终状态    pay-job->>数据库: 更新订单状态          </pre><h4 id="配置动态生效"><a href="#配置动态生效" class="headerlink" title="配置动态生效"></a>配置动态生效</h4><p><code>pay-admin</code> 修改数据库配置后，触发 Redis 缓存失效；<code>pay-front</code>下次请求时从数据库加载最新配置</p><h4 id="错误处理与一致性"><a href="#错误处理与一致性" class="headerlink" title="错误处理与一致性"></a>错误处理与一致性</h4><p>设计<code>支付中</code>和<code>退款中</code>的中间状态，通过定时任务检查并更新订单状态以保证数据最终一致性。</p><h2 id="高可用与监控"><a href="#高可用与监控" class="headerlink" title="高可用与监控"></a>高可用与监控</h2><h3 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a>监控体系</h3><table><thead><tr><th>维度</th><th>工具</th><th>监控指标</th></tr></thead><tbody><tr><td>性能监控</td><td>Prometheus+Grafana</td><td>QPS、RT、线程池利用率</td></tr><tr><td>日志分析</td><td>ELK</td><td>支付链路日志、异常堆栈</td></tr><tr><td>分布式追踪</td><td>Jaeger</td><td>服务间调用耗时、错误节点定位</td></tr></tbody></table><h2 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h2><p><strong>灰度发布流程</strong>：</p><pre class="mermaid" style="text-align: center;">                        graph LR    A[旧系统] --> B{流量分配}    B -->|5%| C[新系统]    B -->|95%| A    C --> D[监控中心]    D -->|异常| E[触发回滚]    D -->|稳定| F[逐步增加至100%]          </pre><p>我们采用了灰度发布的方式来上线新系统。首先将少量（5%）的用户流量切换到新系统，在一周内逐步增加流量到20%，稳定运行一周后，才进行全量切换。同时，我们的新系统接口能够兼容新旧数据格式，确保可以平滑过渡。</p><h2 id="关键挑战与解决方案"><a href="#关键挑战与解决方案" class="headerlink" title="关键挑战与解决方案"></a>关键挑战与解决方案</h2><h4 id="挑战-1：新旧系统平滑切换"><a href="#挑战-1：新旧系统平滑切换" class="headerlink" title="挑战 1：新旧系统平滑切换"></a>挑战 1：新旧系统平滑切换</h4><p>本次重构最大的挑战在于如何在保障现有系统稳定运行的前提下，平滑地切换到新的支付系统，并且几乎不对现有业务造成任何影响。我们主要通过以下策略来应对：</p><ul><li><strong>灰度发布:</strong> 逐步将用户流量导向新系统，降低风险。</li><li><strong>接口兼容:</strong> 新系统接口兼容旧数据格式，减少调用方改动。</li><li><strong>完善的监控和回滚计划:</strong> 实时监控系统状态，并制定了详细的回滚方案，以应对可能出现的问题。</li></ul><h4 id="挑战-2：第三方支付渠道适配"><a href="#挑战-2：第三方支付渠道适配" class="headerlink" title="挑战 2：第三方支付渠道适配"></a>挑战 2：第三方支付渠道适配</h4><p><strong>统一接入层设计</strong>：</p><ul><li>工厂模式：抽象PaymentChannelFactory，根据渠道ID自动路由到具体实现（如PayPal、Stripe）；</li><li>​模板方法模式：定义支付流程标准骨架（创建订单→调用渠道→状态回调），子类仅实现差异步骤。</li></ul><h2 id="收益与总结"><a href="#收益与总结" class="headerlink" title="收益与总结"></a>收益与总结</h2><p>新的支付系统上线至今，我们已经取得了显著的收益：</p><table><thead><tr><th>指标</th><th>旧系统</th><th>新系统</th><th>提升幅度</th></tr></thead><tbody><tr><td>日均掉单数</td><td>20+</td><td>0</td><td>100%</td></tr><tr><td>支付接口响应时间</td><td>1000ms</td><td>300ms</td><td>70%</td></tr><tr><td>新支付方式接入周期</td><td>5 天</td><td>1.5 天</td><td>70%</td></tr><tr><td>人工对账成本</td><td>4 小时 &#x2F; 天</td><td>0.5 小时 &#x2F; 天</td><td>87.5%</td></tr></tbody></table><p>本次支付系统的重构是一次成功的实践，我们不仅解决了旧系统的历史遗留问题，也为未来的业务发展奠定了坚实的技术基础。通过采用微服务架构、熟悉的技术栈和稳健的部署策略，我们实现了系统的平滑过渡，并显著提升了系统的稳定性、可扩展性和可维护性。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们的支付系统最初作为单体应用的子模块存在，随着业务规模扩大，高并发下的&lt;strong&gt;掉单&lt;/strong&gt;和&lt;strong&gt;重复支付&lt;/strong&gt;问题频发，日均人工对账成本高达数小时。为解决这些痛点并支持未来业务扩展，我们决定将支付系统重构为独立的微服务架构，核心目标包括：&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>转载：寂静之城 -- 马伯庸</title>
    <link href="https://www.yzhu.name/2020/09/05/The-Silence-City/"/>
    <id>https://www.yzhu.name/2020/09/05/The-Silence-City/</id>
    <published>2020-09-05T03:37:53.000Z</published>
    <updated>2025-11-11T03:53:15.776Z</updated>
    
    <content type="html"><![CDATA[<p>转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻<span id="more"></span></p><blockquote><p>And in the naked light I saw ten thousand people, maybe more. People tal<br>king without speaking, people hearing without listening. People writing<br>songs that voices never shared, no one dared disturb the sound of silenc<br>e. 　　　　　　　　　　　　　　　 — The sound of silence 　美利坚合众国，2015年，纽约。</p><p>　　当电话响起来的时候，阿瓦登正趴在电脑前面睡觉。电话铃声十分急促，尖锐<br>，每一次振动都让他的耳膜难受好久。他揉了揉干涩的眼睛，十分不情愿地爬起来<br>，觉得脑子沉滞无比。<br>　　其实他的脑子一直就很沉滞，这种感受既然是生理上的也是心理上的。他身处<br>的房间很狭窄，空气不很好，唯一的两扇窗户紧闭着——即使打开窗户也没用，外<br>面的空气更加浑浊。这是一间大约只有三十平米的小屋子，屋子墙壁上泛黄的墙纸<br>有好几处开始剥落，天花板上的水渍渗成奇怪的形状；一张老式的军绿色行军床摆<br>在墙角，床腿用白漆写着编号；紧挨着行军床的是一张三合板制成的电脑桌，桌上<br>摆着一台浅白色的电脑，机箱后面五颜六色的电线纠缠在一起，把它们自己打成一<br>个古怪的死结，杂乱无章地蔓延到地板与墙角，仿佛常春藤一样。</p><p>　　阿瓦登走到电话前，慢慢坐到地板上，目光呆滞地盯着电话，手却没有动。这<br>部古怪的东西是老式的按键式电话，大概是十几年前的款式，这是阿瓦登有一次去<br>费城出差时偶尔在一家杂货店里买到的；他拿回家以后稍微修理了一下，发现居然<br>还能用，这让他当时小小地兴奋了一阵子。<br>　　电话继续在响着，已经是第七声。阿瓦登意识到自己不得不去接听了。于是他<br>弓下腰，用两个指头拈起电话，慢慢把电话放到耳边。<br>　　“请说出你的网络编号？”话筒里传来的声音并不急噪，事实上它也不带其他<br>任何的感情色彩，因为这是电脑合成的人工智能语音系统。<br>“19842015”<br>　　阿瓦登熟练地报出一连串数字，同时开始觉得胸有些更闷了。说实话他并不喜<br>欢这些空洞的电子声音， 他有时候想，假如打过电话来的是一位声音圆润的女性该<br>多好。阿瓦登知道这是一种不切实际的幻想，不过这幻想会让他的身体得到几秒钟<br>的舒缓。</p><p>　　话筒里的声音仍旧在继续着。</p><p>　　“关于你在十月四日提交的网络论坛用户注册申请已经被受理，经有关部门审<br>查后确认资格无误，请在三日内持本人身份证件、网络使用许可证及相关文件前往<br>办理登记手续，并领取用户名及密码。”</p><p>　　“知道了，谢谢。”</p><p>　　阿瓦登谨慎地选择词语，同时努力挤出一副满足的微笑，好象话筒的另一侧有<br>人在看着自己一样。放下电话，阿瓦登先是茫然地盯着它看了大约两分钟，然后站<br>起来活动一下手腕，坐回到电脑前面，缓慢地推动了一下鼠标。</p><p>　　</p><p>　　电脑屏幕“啪”地一声亮了起来，显示出一个登陆的界面，还有一行英文：“<br>请输入你的网络编号和姓名。”阿瓦登将那八位数字敲进去，又输入了自己的名字<br>，点击“登陆”。随即机箱的指示灯开始频繁地闪动起来，整个机器发出细微的噪<br>音。</p><p>　　每一个使用互联网的人都有一个网络编号，没有这个编号，就无法连接进互联<br>网络。每一个编号都是独一无二的，每个人只有一个；这是使用者在网上的唯一代<br>号，既不能修改，也不能取消。这些编号分别对应着使用者身份证上的名字，因此<br>19842015就是阿瓦登，阿瓦登就是19842015。阿瓦登知道有些记忆力不好的人会把<br>自己的编号印在衣服的后面，那看起来颇为滑稽，也容易引发一些不正当的联想。</p><p>　　有关部门说使用网络实名制是为了规范网络秩序方便管理，杜绝因匿名使用网<br>络而产生的一系列重大问题和混乱。阿瓦登不太清楚那一系列重大问题会是什么，<br>他自己没试过用假名上网，他所认识的任何人里也不曾有人尝试过——事实上，从<br>技术角度来说，他根本没办法匿名登陆互联网络，没有编号就没有权限上网，而编<br>号则连接着他的详细档案，换句话说，没人能在网上隐藏自己。有关部门把这一切<br>都考虑的很周详。</p><p>　　“有关部门”，这是一个语意模糊、但却有着权威与震慑力的词组。它既是泛<br>指，又是确指，其所涵盖的意义相当广泛。有时候，它指的是为阿瓦登颁发网络编<br>号的美国联邦网络管理委员会；有时候它是将最新通告及法规发到阿瓦登EMAIL信箱<br>的服务器；还有时候它是监察网络的FBI特属网络调查科；总之一句话，有关部门是<br>无处不在，无职不司的，总会在适当的时候出现，给予指导、监控或者警告，无论<br>你是在网上还是网下。</p><p>　　简直就象是老大哥一样无微不至。</p><p>　　电脑仍旧在持续运转着，阿瓦登知道这得花上一阵子。这台电脑是有关部门配<br>发给他的，具体型号和配置阿瓦登并不清楚，机箱是被焊死的，无法打开。于是他<br>拿出一小瓶清凉油，用右手小拇指的指甲挑出一点抹在自己的太阳穴，然后从脚下<br>堆积如山的杂物里翻出一个塑料杯子，从桌子旁的饮水机里接了半杯蒸馏水，就着<br>一片镇痛片一饮而尽。蒸馏水穿过喉咙和狭长的食道滑进胃里，空泛的味道让他有<br>些恶心。</p><p>　　音响里忽然传来一阵美国国歌的旋律，阿瓦登放下杯子，重新把目光投到电脑<br>上去。这是已经连入互联网络的标志。屏幕上首先跳出来的是有关部门的通告，白<br>底黑色四号字，里面陈述了使用互联网的意义以及最新的规章制度。</p><p>　　“缔造健康的互联网络，美国万岁！”</p><p>　　音响里传来激昂的男性呼声，阿瓦登不大情愿地跟着大声念了一遍。“缔造健<br>康的互联网络，美国万岁！”</p><p>　　这段呼号持续了三十秒钟，然后消失，取而代之的是写着“缔造健康的互联网<br>络”标语的桌面背景。另外一个窗口慢慢浮上开，上面开列出几个选项：工作、娱<br>乐、电子信箱和BBS论坛。其中BBS选项呈现灰色，说明这项功能还没有开通。</p><p>　　整个操作系统简洁明了，这台电脑的浏览器没有地址输入栏，只是在收藏夹里<br>有几个无法修改的的网站地址。理由很简单，这些网站都是健康向上的，假如其他<br>站点和这些网站一样，那么只保留这些网站就够了；假如其他站点与这些网站不一<br>样，那么就是不健康的，是低级趣味，不能保留。这是有关部门精心设计的，是为<br>了公民的精神健康着想，生怕他们受到不良信息的侵染。</p><p>　　阿瓦登首先点开了“工作”，一连串和他工作相关的站点列表与相关软件在电<br>脑上显示出来。阿瓦登是一名程序员，他每天的工作就是根据上级的要求编写程序<br>。这份工作很无聊，不过可以保证他有稳定的收入。他不知道自己的源代码会被用<br>到哪里去，上级也从来没有跟他说过。 　　他打算继续昨天的工作，但是很快发现<br>自己很难继续下去。阿瓦登觉得今天的情绪比以前要烦躁，无法集中精神，大脑还<br>是很呆滞，胸口仍旧发闷。他试图娱乐自己，但是他发现“娱乐”选项里只有纸牌<br>与挖地雷，根据有关部门的说法，这是两个健康的游戏，没有暴力，没有色情，不<br>会让人产生犯罪冲动，也不涉及任何政治色彩。据说美国境外也是有互联网络站点<br>的，不过无法连上去，因为本国的互联网络自成格局，独立自主，普通人无法直接<br>连接到国外——IE浏览器没有地址栏，就算知道地址也没有用处。</p><p>　　“您有一封新邮件。”</p><p>　　系统忽然跳出来提示，阿瓦登终于找到了可以暂停工作的理由，他很快移动鼠<br>标到电子信箱的选项上，点开，很快一个新的界面出现了。</p><p>　　“To: 19842015</p><p>　　From：10045687</p><p>　　Subject: 模块、已经、完成、当前、项目、是否、开始。”</p><p>　　阿瓦登微微地叹了一口气，觉得有些失望。每一次他收到新的电子邮件，都希<br>望能够有一次新鲜的刺激来撞击他日益迟钝的脑神经，每一次他都失望了。其实他<br>早就知道这一点，只不过他觉得保持期待至少能够享受到几秒钟快感。就好象他期<br>待着打电话过来的是一个圆润温柔的女性声音一样。不给自己一些渺茫的希望，阿<br>瓦登觉得自己迟早会疯掉的。</p><p>　　这封信很简短，但是内容很充实。19842015是阿瓦登的网络编号，而10045687<br>则是他的一位同事的编号，这种工作性质的信件通常都以编号相称。信的内容是几<br>个不连续的英文单词，这是有关部门所提倡的一种电子邮件书写方式，因为这样可<br>以方便软件检查信件中是否含有敏感词汇。</p><p>　　阿瓦登打开回信的页面，同时另开了一个窗口，打开一份名字叫做“网络健康<br>语言词汇列表”的TXT文档。这是有关部门要求每一位网民所必须使用的词汇。当他<br>们书写电子邮件或者使用论坛服务的时候，都得从这个词汇列表中寻找适合的名词<br>、形容词、副词或者动词来表达自己想要说的话。一旦过滤软件发现网民使用了列<br>表以外的词，那么这个词就会被自动屏蔽，取而代之的是“请使用健康语言”。</p><p>　　“屏蔽”是个专有名词，被屏蔽的词将不允许再度被使用，无论是在书信里还<br>是口头都不允许。讽刺的是，“屏蔽”一词本身也是被屏蔽的词汇之一。</p><p>　　这个列表是经常更新的，每一次更新都会有几个词在列表上消失，于是阿瓦登<br>不得不费劲脑汁寻找其他词语来代替那个被屏蔽掉的词语或者单字。比如在以前，<br>“运动”这个词是可以使用的，但后来有关部门宣布这也是一个敏感词汇，阿瓦登<br>只好使用“质点位移”来表达相同的意思。</p><p>　　他对照着这份列表，很快就完成了一封文字风格与来信差不多的EMAIL——健康<br>词汇表迫使人们不得不用最短的话来表达最多意思，而且要尽量减少不必要的修辞<br>，所以这些信件就好象是那杯蒸馏水一样，淡而无味，阿瓦登有时候想，他早晚也<br>会和这些水和信一样腐烂，因为这些信是他写的，水是他喝的。</p><p>　　接下来阿瓦登启动检查软件先扫了一遍，确保自己没无意中加入什么敏感词汇<br>。等这一切都完成后，他按下了发送键，邮件被送出去了。</p><p>　　阿瓦登没有留下备份，因为他的机器里没有硬盘，也没有软驱、光驱或者USB接<br>口。这个时代宽带技术已经得到了很大发展，应用软件可以集中在统一的一个服务<br>器中，个人用户调用时的速度丝毫不会觉得迟滞。因此个人不需要硬盘，也不需要<br>本地存储，他们在自己电脑里写的每一份文档、每一段程序、甚至每一个动作都会<br>被自动传送到有关部门的公共服务器中，这样便于管理。换句话说，阿瓦登所使用<br>的电脑，仅仅具备输入和输出两种功能。</p><p>　　完成了这封信后，阿瓦登再度陷入了软绵绵的焦躁状态，这是一个连续工作了<br>三天的程序员的正常反应。这种情绪很危险，因为它让人效率低下精神低迷，而且<br>没有渠道发泄。“疲劳”、“烦躁”以及其他负面词汇都属于危险词汇，如果他写<br>信给别人抱怨的话，那么对方收到的将会是一封写满“请使用健康语言”的EMAIL。</p><p>　　这就是阿瓦登每天的生活，今天比昨天更糟糕，但应该比明天还稍微好一点。<br>事实上这个叙述也很模糊，因为阿瓦登自己并不清楚什么是“好一点”，什么是“<br>更糟糕”。“好”与“坏”是两个变量，而他的生活就是一个定量，只有一个常数<br>叫“压抑”。</p><p>　　阿瓦登推开鼠标，把脑袋向后仰去，长长地呼了一口气。（至少“呼”这个字<br>还没有被屏蔽）这是空虚的表现，他想哼些歌，但却又不记得什么，转而吹了几下<br>口哨，但那听起来与一只生了肺结核的狗差不多，只得做罢。有关部门象幽灵一样<br>充斥在整个房间里，让他无法舒展自己的烦闷。就好象一个人在泥沼里挣扎，刚一<br>张口就被灌入泥水，甚至无法大声呼救。</p><p>　　他的头不安分地转了几转，眼神偶尔撇到了摆在地板上的老式电话机，他忽然<br>想到还必须要去有关部门申请自己的BBS论坛浏览许可证。于是他关掉“工作”和“<br>电子邮件”窗口，退出了网络登陆。阿瓦登在做这些事的时候毫不犹豫，他很高兴<br>能够暂时摆脱互联网络，在那上面他只是一串枯燥的数字和一些“健康词汇”的综<br>合体。</p><p>　　阿瓦登找出一件破旧的黑色呢子大衣，那件大衣继承自他的父亲，袖口和领子<br>已经磨损的很严重，个别地方有灰色的棉花露出来，但还是很耐寒。他把大衣套到<br>身上，戴上一副墨绿色的护镜，用过滤口罩捂住嘴。他犹豫了一下，拿起“旁听者<br>”别在耳朵上，然后走出家门去。</p><p>　　纽约的街上人很少，在这个时代，互联网的普及率相当地高，大部分事务在网<br>上就可以解决，有关部门并不提倡太多的户外活动。太多的户外活动会导致和其他<br>人发生物理接触，而两个人发生物理接触后会发生什么事则很难控制。</p><p>　　“旁听者”就是为了防止这种事而发生的，这是一种便携式的语言过滤器，当<br>携带者说出敏感词汇的时候，它就会自动发出警报。每一位公民外出前都必须要携<br>带这个装置，以便随时检讨自己的言语。当人们意识到旁听者存在的时候，他们往<br>往会选择沉默，至少阿瓦登是如此。有关部门正逐步试图让网络和现实生活统一起<br>来，一起“健康”。</p><p>　　这时候正是11月份，寒风凛冽，天空漂浮着令人压抑的铅灰阴云，街道两旁的<br>电线杆仿佛落光了叶子的枯树，行人们都把自己包裹在黑色或灰色的大衣里面，浓<br>缩成空旷街道上的一个个黑点飞快移动着。一层若有若无的烟雾将整个纽约笼罩起<br>来，不用过滤口罩在这样的空气里呼吸将会是一件很有挑战的事情。</p><p>　　距离上一次离开家门已经有两个月了吧，阿瓦登站在公共汽车站的站牌下，不<br>无感慨地想，周围的一切看起来很陌生，泛黄，而且干燥。那是上一次沙尘暴的痕<br>迹。不过沙尘暴这个词也已经被屏蔽了，因此阿瓦登的脑海里只是闪过那么一下，<br>思想很快就转移到别的事情上去了。</p><p>　　站在阿瓦登旁边的是一个穿着蓝色制服的高个男人。他先是狐疑地看了阿瓦登<br>一眼，看到后者沉默地沉在黑色大衣里，他的两只脚交替移动，缓慢地凑了过去，<br>装做漫不经心对阿瓦登说：</p><p>　　“烟，有吗？”</p><p>　　男人说，每一个字都说的很清晰，而且词与词之间间隔也足够长。这“旁听者<br>”还没有精密到能够完全捕捉到每一个人语速和语调的程度，因此有关部门要求每<br>一位公民都要保持这种说话风格，以方面检测发言人是否使用了规定以外的词汇。</p><p>　　阿瓦登转过头去，看了他一眼，舔舔自己干裂的嘴唇，回答说：</p><p>　　“没有。”</p><p>　　男人很失望，又一次不甘心地张开嘴。</p><p>　　“酒，有吗？”</p><p>　　“没有。”</p><p>　　阿瓦登又重复了一次这个词，他也已经很久没有收到烟和酒了，也许是缺货的<br>关系吧，这是常有的事。不过有一点很奇怪，“旁观者”这一次却没有发出警报。<br>以阿瓦登的经验，以往一旦烟、酒或者其他生活必需品发生短缺现象，这个词就会<br>暂时成为被屏蔽掉的敏感词汇，直到恢复供给为止。</p><p>　　这个男人看起来很疲惫，红肿的眼睛是这个时代的人们普遍的特征，这是长时<br>间挂在网上的关系。他的头发蓬乱，嘴边还留着青色的胡子碴，制服下的衬衣领口<br>散发着刺鼻的霉味。能看的出，他也很久不曾到街上来了。</p><p>　　阿瓦登这时候才注意到，他的耳朵上空荡荡的，没有挂着那个银灰色的小玩意<br>“旁听者”，这实在是一件严重的事情。不携带“旁听者”外出，就意味着语言不<br>会再被过滤，一些不健康的思想和言论就有可能孳生，因此有关部门相当严厉地规<br>定公民上街必须携带旁听者。而这个男人的耳朵旁却什么也没有。阿瓦登暗暗吃惊<br>，一时间不知道是该去提醒还是装做没看到。他暗自想，也许向有关部门举报会更<br>好。</p><p>　　这时候那个男人又朝他靠近了一点，眼神变的饥渴起来。阿瓦登心里一阵紧张<br>，下意识地向后退去。这难道是一次抢劫？还是说他是个压抑太久的同性恋者？那<br>个男人忽然扯住他的袖子，阿瓦登狼狈地挣扎却没有挣开。出乎他的意料，那个男<br>人并没有进一步的动作，而是大吼一声，用一种阿瓦登已经不太习惯了的飞快语速<br>向他倾泻起话语来。阿瓦登被这突如其来的爆发弄的莫名其妙，不知所措。</p><p>　　“我只是想和你多几句话，就几句，我很久没有说过话了。我叫斯多葛，今年<br>三十二岁，记得，是三十二岁。我一直梦想有一套在湖边的房子，有一副钓鱼竿和<br>一条小艇；我讨厌网络，打倒网管；我妻子是个可恶的网络中毒者，她只会用枯燥<br>乏味的话叫我的网络编号；这个城市就是一个大疯人院，里面大疯子管着小疯子，<br>并且把所有没疯的人变的和他们同样疯狂；敏感词汇都去他X的，老子受够了……”</p><p>　　男人的话仿佛一瓶摇晃了很久然后突然打开的罐装碳酸饮料，迅猛，爆裂，而<br>且全无条理。阿瓦登惊愕地望着这个突然狂躁起来的家伙，却不知道如何应对；更<br>可怕的是，他发现自己居然对他产生了一点同情，那种“同病相怜”式的同情。男<br>人的话这时候已经从唠叨变成了纯粹谩骂，全部都是最直抒胸臆的那种。阿瓦登已<br>经有五、六年不曾说过这些脏话，最后一次听到这些也是四年前。有关部门认为这<br>都有碍精神文明，于是全部都屏蔽掉了。</p><p>　　而现在这个男人就在公众场合对着他大吵大嚷，似乎要将被屏蔽掉的敏感词汇<br>一口气全倒出来。他的目光和手势并不针对任何人，甚至也不针对阿瓦登，更象是<br>在一个人在自说自话。阿瓦登的耳膜似乎不习惯这种分贝，开始有些隐隐做痛，他<br>捂着耳朵，拿不定主意是干脆逃掉还是……这时候，远处街道出现两辆警车，一路<br>闪着警灯直直冲着这座公共汽车站而来。</p><p>　　警车开到站台旁时，男人仍旧在痛骂着。警车门开了，涌出了五、六名全副武<br>装的联邦警察。他们扑过去将那个男子按在地上，用橡皮棍痛打。男人两条腿挣扎<br>着，嘴里的语速更快了，骂出来的话也越来越难听。其中一名警察掏出一卷胶带，<br>“嚓”地一声扯下一条向男人的嘴贴去。男人在嘴被胶带封住之前，突然提高嗓门<br>，冲着警察痛快无比地喊了一句：“FUXKYOU, YOUSONOFBITCH！”阿瓦登看到他的<br>表情由疯狂变成享受，面带着微笑，似乎完全陶醉在那一句话所带来的无上快感和<br>解脱感中。</p><p>　　联邦警察们七手八脚地将男人送进了警车，这时才有一名警察走到了阿瓦登的<br>跟前。</p><p>　　“他，是，你朋友？”</p><p>　　“我，不，认识。”</p><p>　　警察盯了他一阵，取下他耳朵上的“旁观者”查看记录，发现他并没有提及任<br>何敏感词汇，于是重新给他戴回去，警告他说那名男子说的全部都是极度反动的词<br>汇，要求他立刻忘掉，然后转身押着那男子离开了。</p><p>　　阿瓦登松了一口气，其实刚才他有一瞬间涌现出一种冲动，也想在这空旷的街<br>道上大喊一声“FUXKYOU, YOUSONOFBITCH”那一定很爽快，他心里想，因为那男子<br>说出这句话的时候表情很享受。不过他也知道，这也是妄想的一种，“旁观者”紧<br>帖在耳朵上的冰凉感觉时刻提醒着他。 　　街上很快就恢复了冷清，十分钟后，一<br>辆公共汽车慢吞吞地开进站里，锈迹斑斑的车门哗啦一声打开，一个电子女声响彻<br>整个空荡荡的车厢：“请乘客注意文明用语，严格按照健康词汇发言。”</p><p>　　阿瓦登把自己缩进大衣，压抑住自己异样的兴奋，决定继续保持沉默下去。</p><p>　　大约过了一个小时，公共汽车到了目的地。从破碎的车窗玻璃里吹进来的寒风<br>让阿瓦登脸上挂起一层暗灰色的霜气，面部被风中的沙砾和煤渣刮的生疼。他听到<br>电子女声报出了站名，就站起身来，象一条狗一样抖抖身上的土，走下车去。</p><p>　　车站对面就是阿瓦登要去的地方，那是有关部门负责受理BBS论坛申请的网络部<br>。这是一间五层的大楼，正方形，全水泥混凝土结构，外表泛灰。如果没有那几个<br>窗户的话，那么它的外貌将与水泥块没有任何区别：生硬、死气沉沉，让蚊子和蝙<br>蝠都退避三舍。</p><p>　　BBS论坛是一种奇特的东西，从理论上来讲它完全多余，BBS的功能完全可以由<br>EMAIL新闻组来取代，后者更容易管理和审查。而且申请使用BBS论坛资格不是件容<br>易的事，申请人必须要通过十几道手续和漫长的审查才能有浏览资格，浏览资格三<br>个月才会被允许在指定论坛发布帖子，至于自己开设BBS则几乎是不可能。</p><p>　　因此真正对BBS有兴趣的人少之有少。阿瓦登当初之所以决定申请BBS论坛资格<br>，纯粹是因为他那种模糊但却顽强的怀旧心态，就好象他从杂货店里买的那部老式<br>电话一样。他也不知道自己为什么会自找麻烦，也许是为了给生活带来些刺激，还<br>是说为了强调自己和曾经旧时代的那么一点点联系，也许两者兼有之。</p><p>　　阿瓦登恍惚记得在他小的时候，互联网与现在并不太一样。并不是指技术上的<br>不同，而是一种人文的感觉。他希望能通过使用BBS论坛回想起一些当年的事情。</p><p>　　阿瓦登走进网络部的大楼，大楼里和外面一样寒冷，而且阴森。走廊里没有路<br>灯，蓝白色调的两侧墙壁贴满了千篇一律的网络规章条文与标语，冰冷的空气呼吸<br>到肺里，让阿瓦登一阵痉挛。只有走廊尽头的小门缝隙里流泻出一丝光亮，小门的<br>上面挂着一块牌子，上面写的是“网络部BBS论坛科。”</p><p>　　一走进这间屋子，阿瓦登立刻感觉到一阵温洋洋的热气。屋子里的暖气（或者<br>是空调）开的很大，让阿瓦登冻麻了的手脚和脸麻酥酥的，有些发痒，他不禁想伸<br>出手去挠挠。</p><p>　　“公民，请您站在原地不要动。”</p><p>　　一个电子女声忽然从天花板上的喇叭里传来，阿瓦登触电似地把手放下，恭敬<br>地站在原地不同。他借这个机会观察了一下这间屋子。这屋子准确来说应该是一个<br>狭长形的大厅，一道拔地而起的大理石柜台象长城一样将房间割裂成两部分，柜台<br>上还装着一排银白色的圆柱形栅栏，直接连到天花板。屋子里没有任何装饰，没有<br>观赏植物，没有塑料鲜花，甚至没有长椅和饮水机。</p><p>　　“缔造健康的互联网络，美国万岁。”</p><p>　　阿瓦登跟着声音重复了一遍。</p><p>　　“请前往八号窗口。”</p><p>　　电子女声的语调很流畅，因为这是电脑制作出来的，因此没有敏感词汇的限制<br>。</p><p>　　阿瓦登转头看到在自己右手边的不远处，大理石柜台上的液晶屏幕显示着八号<br>的字样。他走过去，拼命抬起头，因为柜台实在太高了，他只能勉强看到边缘，而<br>无法看到柜台另一侧的情形。不过他能听到，一个人走到柜台对面，坐下去，并有<br>翻动纸张与敲击键盘的声音。</p><p>　　“请把文件放入盒子里。”</p><p>　　柜台上的喇叭传来命令。出乎意料，这一次在喇叭里的声音却变了。虽然同样<br>冷漠枯燥，但阿瓦登还是能分辨出它与电子女声的不同——这是一个真正的女性的<br>声音。他惊讶地抬头望去，却什么都看不到，柜台太高了。</p><p>　　“请把文件放入盒子里。”</p><p>　　声音又重复了一次，语气里带着一丝烦躁，似乎对阿瓦登的迟钝很不满。</p><p>　　“是的，这是真正的女声……”阿瓦登想，电子女声永远是彬彬有礼不带任何<br>感情色彩的。他把相关的电子身份证、网络许可证、网络编号和敏感词汇犯罪记录<br>等一系列个人资料卡片一起放进柜台外的一个小金属盒子里，然后把盒子插进柜台<br>上一个同样大小的凹槽中，关好门。 很快他听到“唰”的一声，他猜测这也许是对<br>面的人——也许是个女人——将盒子抽出去的声音。</p><p>　　“你申请BBS服务的目的是什么？”</p><p>　　</p><p>　　喇叭后的女声浸满了纯粹事务性的腔调。</p><p>　　“为了、提高、互联网络、工作效率、为了、缔造、一个、健康、的网络、环<br>境，更好地、为、祖国、做出、贡献。”</p><p>　　阿瓦登一字一句地回答，心里知道这只是一道官方程序，只需要按标准回答就<br>可以。</p><p>　　对面很快就陷入沉默，大约过了十五分钟，喇叭再度响起。</p><p>　　“最后手续确认，你已经获得BBS论坛浏览权。”</p><p>　　“谢谢。”</p><p>　　“砰”的一声，金属盒子从柜子里弹了出来，里面除了阿瓦登的证件以外还多<br>了五张小尺寸光盘。</p><p>　　“这是有关部门核发给你的BBS论坛统一用户名与密码，BBS论坛列表、互联网<br>BBS论坛使用指南及相应法规、以及最新健康网络词汇列表。”</p><p>　　阿瓦登向前踏了一步，从盒子里将这些东西一股脑全拿出来，揣进大衣的大兜<br>里。那些东西其实是可以全部放在同一张光盘里的，不过有关部门认为每一张光盘<br>装一份文件有助于用户理解这些文件的严肃性和重要性，并产生敬畏。</p><p>　　他心里盼望着那个喇叭能再说两句。让他失望的是，对面传来的是一个人起身<br>并且离开的声音，从脚步声的韵律判断，阿瓦登愈发相信这是一名女性。</p><p>　　“手续办理完毕，请离开网络部回到自己的工作岗位上。”</p><p>　　甜美空洞的电子女声从天花板上传来，阿瓦登厌恶地抽动鼻翼，拿手揉了揉，<br>转身离开这间温暖的大厅，重新进入到寒冷的走廊。</p><p>　　在回家的路上，阿瓦登蜷缩在公共汽车上一动不动，顺利申请到BBS的使用权让<br>他有些虚无缥缈的兴奋。他闭着眼睛，找了一个合适的角度躲开破窗而入的寒风，<br>右手在兜里不断摩挲那一系列光盘，还在怀念着那一个神秘的女声。</p><p>　　如果能再一次听到该多好，他不能抑制自己这样的想法，同时用拇指的指肚在<br>光盘上轻轻地摩擦，幻想这几张光盘也曾经被她的手触摸过。他兴奋的几乎也想破<br>口大骂一句“FUXKYOU, YOUSONOFBITCH”，真奇怪，那名男子的骂声在他的记忆里<br>根深蒂固，并时不时不自觉地滑到唇边。</p><p>　　忽然，他的手指在光盘上发觉到一丝异常的感觉。阿瓦登下意识地朝四周望去<br>，确认周围一个乘客也没有后，他小心翼翼地把光盘全拿出来，就着窗外的光亮仔<br>细端详。</p><p>　　阿瓦登很快注意到，在装有BBS论坛列表的光盘背面，被人用指甲轻轻地划了一<br>道刮痕。这条刮痕很轻，如果不是阿瓦登仔细地抚摩光盘的话，是很难发觉到的。<br>这条刮痕很奇特，是一条直线，而在这条直线末端的不远处，则是另外一条极短的<br>刮痕，似乎刻意想弯成一个圆点。整体看上去就好象是一个叹号，或者倒过来说，<br>象是字母i。</p><p>　　很快他在其他四张光盘上也发现了类似的刮痕，它们造型都不同，但都似乎代<br>表着某种符号。阿瓦登回想起喇叭里那个女声最后一句提到过的文件顺序，于是把<br>这五张光盘按照BBS论坛统一用户名与密码、BBS论坛列表、互联网BBS论坛使用指南<br>、相应法规、以及最新健康网络词汇列表的顺序排列好，接着依次把那五道刮痕用<br>手指临摹到汽车窗户上。很快那些刮痕构成了一个英文单词：</p><p>　　title</p><p>　　题目？这是什么意思？</p><p>　　阿瓦登看着这个单词莫名其妙，这究竟是纯属无意的痕迹，还是有人刻意为之<br>？如果是有人刻意为之，他这么做的用意是什么？</p><p>　　这时候汽车停住了，又有几名乘客走上车来。阿瓦登挪动一下身体，不让他们<br>看到自己在车窗上写出来的字迹，然后装做打呵欠的样子抬起袖子，轻轻把那五个<br>字母擦掉。</p><p>　　阿瓦登暗自庆幸，如果他没有在现在发现这些光盘上的痕迹，那么以后就永远<br>没有机会发觉了。按照规定，个人电脑是不允许使用任何存储存设备的，因此阿瓦<br>登的电脑并没有光驱。他下一步所要做的是将这些光盘送交到管区网络安全部，由<br>他们将光盘内资料登陆到服务器中，再转发给阿瓦登。这是为了防止个人私自在家<br>里制造、阅读或者传播黄色或者反动信息，网络安全部发出的通告是这么解释的。<br>联邦的网络警察经常会突入到个人家中进行临时检查，看用户是否非法拥有信息贮<br>存设备，阿瓦登曾经亲眼见过一个邻居被警察带走，原因仅仅是因为他私自藏了一<br>张光盘在家里——其实他只是打算拿那个当茶杯垫用。那个邻居再没回来过。</p><p>　　无论这些符号代表的是什么意思，它都是一种全新的体验，这让阿瓦登感觉到<br>兴奋。怀旧与渴望新奇是阿瓦登生活在这个时代的两根精神支柱，否则他会与这座<br>城市一样变的僵硬，然后窒息而死。</p><p>　　他先来到网络安全分部，将光盘交给那里的负责人，负责人反复地检查光盘和<br>阿瓦登的表情，好象所有使用BBS论坛的人都不可信赖一样。末了负责人终于找不到<br>什么破绽，只得将光盘收下，然后举起右手，阿瓦登和他一起高呼“缔造健康的互<br>联网络”。这句话是唯一被允许可以连贯着被说出来的句子。</p><p>　　回到家里，阿瓦登脱掉大衣，摘了过滤口罩，将旁观者扔到了行军床上，然后<br>整个人也倒进枕头里。每次出去外面都会让他疲劳，这一半是因为他孱弱的肉体已<br>经不大适合室外活动；另外一半原因是因为他必须花费大量的精力来应付旁观者。</p><p>　　过了四十分钟，他才悠悠地醒过来，头还是和平常一样地疼，胸口还是一如既<br>往地闷。胡乱吃了一点东西以后，阿瓦登爬到电脑桌前，打开电脑，按程序登陆上<br>网络，习惯性地先检查了一遍信箱。</p><p>　　信箱里有七、八封新的信件，其中两封是同事发来的事务信。另外五封则是网<br>络安全部发给他的，内容就是他送交的那几张光盘。</p><p>　　阿瓦登打开了包含有BBS论坛的用户名、密码和BBS论坛列表的两封信。他看到<br>自己的论坛通用用户名叫做19842015，和自己的网络编号完全一样，不由得有些失<br>望。他依稀记得在小的时候，BBS论坛的用户名是可以自己决定的，而且每一个论坛<br>都可以不同，一个人在网上并不单只是一串枯燥数字。</p><p>　　小时候的记忆往往是跟童话和幻想混杂在一起，未必与实际相符。现实中你只<br>能使用有关部门指定的用户名和密码，理由很简单，用户名和密码内也可能含有敏<br>感词汇。</p><p>　　阿瓦登又打开了那份BBS列表，全部都是有关部门开设的官方论坛，没有私人的<br>——事实上个人能够合法持有的电脑设备从技术上来说也无法架设新BBS——这些论<br>坛的主题各有侧重点不同，但基本上是围绕着如何更好响应国家号召，缔造健康互<br>联网络来说的。比如其中一个电脑技术论坛，主题就是如何更好地屏蔽掉敏感词汇<br>。</p><p>　　居然在这些论坛中还有一个是关于游戏的。里面正在讨论的是一个如何帮助别<br>人使用健康词汇的网络游戏，玩家可以操纵一名小男孩在街上侦察，看是否有人使<br>用了敏感词汇，小男孩可以选择上前指责或者通知警察，抓到的人越多，小男孩得<br>到的褒奖就越高。</p><p>　　阿瓦登随便打开了几个论坛，里面的人都彬彬有礼，说话很“健康”，就好象<br>街上的那些行人一样。不，准确地说，比街上的气氛还要压抑。在街上的人也许还<br>有机会保留一下自己的小动作，比如阿瓦登刚才在公共汽车上就偷偷地写了TITLE五<br>个字母；而在网上论坛，人的最后的一点隐私也全被暴露出来，有关部门随时可以<br>调看你的一切行动，无从遁形，这就是科学技术发展所带来的进步。</p><p>　　一阵失落和失望袭上阿瓦登的心头，他合上眼睛，把鼠标甩开，重重地向后靠<br>去。原来他天真地以为BBS论坛也许会少许宽松一些，现在看来甚至比现实中更叫人<br>窒息，他感觉到自己好象陷入沉滞的电子淤泥之中，艰于呼吸。“FUXKYOU, YOUSO<br>NOFBITCH”再一次涌现到他的唇边，强烈无比，要化好大的力气才控制住。</p><p>　　忽然，他又想到了那个神秘的title，那究竟是什么意思？那五张光盘里或许隐<br>藏着什么？也许这跟title有关系？</p><p>　　阿瓦登想到这里，把目光重新转向电脑屏幕，仔细去看网络安全部发来的五封<br>信的title部分。五张光盘各隐藏着一个字母，凑到一起就是title，那么按照这个<br>方式，那五封EMAIL的title凑到一起，就变成了一句话：去用户学习论坛。”</p><p>　　阿瓦登记得刚才他确实看到其中一个论坛的名字叫做“用户学习”，于是他抱<br>着姑且一试的心态连接到这个论坛去。他希望这并不是一个巧合。</p><p>　　用户论坛是一个事务性论坛，里面是一些关于BBS用户资料的投诉帖和管理帖，<br>斑竹的是一个叫19387465的人；发帖的人和回帖的人数量都很少，里面冷冷清清的<br>。阿瓦登打开帖子列表，按照刚才的规律去搜寻每一个帖子的标题，并把它们综合<br>到一起，很快他就得到了另外一句话： 　　“每周日辛普森大楼5层B户。”</p><p>　　又是一个谜团，阿瓦登想。但这却坚定了他的信心，这其中必定隐藏着玄机。<br>光盘、EMAIL和BBS论坛，连续三次都可以通过首词组组合的方式得到暗示，绝非巧<br>合。</p><p>　　究竟是什么人会在有关部门的官方文件中隐藏着这样的信息呢？每周日在效率<br>大楼5层B户又会发生什么事情呢？</p><p>　　阿瓦登终于找到了久违的兴奋感，未知事物的新奇刺激着他麻木很久的神经。<br>更重要的是，这种在有关部门正式文件中玩弄的文字技巧，叫他有一种喘息的快感<br>，仿佛一个密不透风的铁面罩上几个透进空气的小孔。</p><p>　　营造健康的互联网络。</p><p>　　FUXKYOU, YOUSONOFBITCH。</p><p>　　阿瓦登盯着屏幕上的桌面背景，用嘴唇比出了那句粗话的口型，并且比出了中<br>指。</p><p>　　在接下来的日子里，阿瓦登一直处于一种潜藏的兴奋状态，就象是一个摆出无<br>辜表情嘴里却藏着糖果的小孩子，在大人转身过去之后露出狡黠的笑容，尽情享受<br>心中藏有秘密的乐趣。</p><p>　　日子一天一天地过去，健康词汇在列表里又少了几个，窗外的空气又浑浊了几<br>分，这已经是生活的常态。阿瓦登自己已经开始拿网络健康词汇表当日历来用，划<br>掉三个词就证明过了三天，划掉七个就证明过了一周，于是周日终于到来了。</p><p>　　阿瓦登抵达辛普森大楼的时间是中午，暗示的句子里并没有指明时间，阿瓦登<br>认为在中午前往应该是比较可以接受的。当穿着深绿军大衣，耳朵上别着旁观者的<br>阿瓦登来到辛普森大楼的入口时，他的心开始忐忑不安地跳跃起来。他在上一星期<br>设想了无数种可能发生的情景，而现在这个谜底就要揭晓了。无论在周日效率大楼<br>会发生什么，也不会比现在的生活更加糟糕，阿瓦登心里想，所以他并不怎么害怕<br>。</p><p>　　他走进大楼内部，发现这里的人也很少，空旷的走廊里只听到他哒哒的脚步声<br>与回音。一部老电梯里贴着“缔造美好网络家园”的广告，以及一个充满了正义感<br>的男性头像海报，背景是星条旗，他在纸里用右手食指指向观看者，头上写着一行<br>字是“公民，请使用健康词汇。”阿瓦登厌恶地转过身去，发现另外一侧也贴着同<br>样的海报，避无可避。</p><p>　　值得庆幸的是五楼很快就到了，电梯的门一开，对面的门上就赫然挂着B户的牌<br>子。门是掉了漆的绿色，门框上还点了几滴墨水，一部简易的电子门铃挂在右上角<br>。</p><p>　　阿瓦登深深吸了一口气，伸手去按电纽。</p><p>　　电铃响起，很快屋子里传来脚步声。阿瓦登觉得这脚步的韵律很熟悉，似乎是<br>在哪里见到过。门“咔拉”一声被打开一半，一名年轻女子一手握着把手，把身体<br>前倾望着阿瓦登，警惕地说：</p><p>　　“你，找谁？”</p><p>　　女子疑惑地问道。阿瓦登一下子就认出了她的声音，就是那个在网络部BBS论坛<br>科柜台后面的女性。她很漂亮，穿着墨绿色绒线衫，头上梳着这时代流行的短发，<br>皮肤特别的白，只有嘴唇能看到一些血色。</p><p>　　看着女子的眼神，一瞬间阿瓦登不知道该说什么好，犹豫了一下，他举起右手<br>，轻声回答说：“title。”</p><p>　　阿瓦登不知道这句话能否奏效，也不知道自己是否真的找对了地方，但这是他<br>唯一能想到的回答了。他紧张地望着那女子，假如那女子忽然报警，那么自己就会<br>被抓起来仔细审问为什么无缘无故跑到陌生人家里。“肆意游走罪”只比“使用敏<br>感词汇罪”轻那么一点。</p><p>　　女子听到他这么说，脸上还是毫无表情，只是把头幅度很轻微地点了一下，右<br>手谨慎地做了一个“进来”的手势。阿瓦登刚要张口，那女子严厉地瞪了他一眼，<br>吓的他把话又吞回去了，乖乖地跟着她进了屋子。</p><p>　　一进屋子，女子首先做的就是把门关好，然后拉起来一层铅灰色的门帘挡在门<br>口。阿瓦登不安地眨着眼睛，趁她拉门帘的时候环顾四周。这屋子是标准的两室一<br>厅，在厅里摆放的是一套双人沙发与一个茶几，茶几上居然还有几束红紫色的塑料<br>花。靠墙是电脑桌和电脑，墙上挂着普通的白色日历， 但被主人用粉红色的纸套了<br>边，看起来颇为温馨。一盏粗笨的日光灯从天花板上垂下来，上面象是恶作剧一样<br>挂了几缕绿色的电线，象是垂下藤蔓的葡萄架。阿瓦登注意到厅口的鞋架上有四双<br>鞋，尺码不同，说明今天的客人并不只他一个。</p><p>　　阿瓦登正踌躇不安，忽然女子从背后拍了拍他的肩膀，示意他朝里面走。于是<br>两个人穿过客厅另一侧的短小回廊来到其中一间卧室。卧室上挂着同样质地的铅灰<br>色帘子，女子伸手举起帘布，推开了门。阿瓦登迈了进去，首先映入眼帘的是三名<br>面带微笑的人类，以及一间用真正的鲜花装点的房间。屋子里有很多旧日记忆里的<br>古老物品，比如一幅印象派的油画、一尊乌干达木雕，甚至还有一个银烛台，唯独<br>没有电脑。</p><p>　　他正在迟疑，女子也进了屋子。她谨慎地拉好门帘关上门，将耳边的旁观者取<br>下，回过身来对阿瓦登用曼妙的声音说道：</p><p>　　“欢迎加入说话会！”</p><p>　　“说话会？”</p><p>　　出于习惯，阿瓦登并没有把这三个字说出口，因为他不确定是否“健康”，只<br>是用眼神表示自己的疑惑。</p><p>　　“在这里你可以随便说话，这个该死的东西不会起作用的。”女子把自己的旁<br>观者晃了晃，那个小东西象死掉了一样，对女子句子里两个敏感词汇“随便”和“<br>该死”充耳不闻。</p><p>　　阿瓦登一下子想到上星期在公共汽车站前碰到的男子，如果他摘下旁观者，会<br>不会也会落到同一境地呢？那女子见他犹豫不决，指了指门口的铅灰色门帘说：“<br>放心好了，这里是可以屏蔽掉旁观者信号的，不会有人觉察到。”</p><p>　　“你们，是什么，人，这，是，哪里？”</p><p>　　阿瓦登一边摘下耳朵上的旁观者，一边小声说道，语调还是改不了那种有关部<br>门规定的说话方式。</p><p>　　“这里是说话会，是一个完全自由场所，在这里你可以畅所欲言，请不要拘束<br>。”</p><p>　　另外一个人起身对他说道，这是一名瘦高的中年男子，鼻梁上的眼镜非常地厚<br>。</p><p>　　阿瓦登嗫嚅着，却找不到发音的焦点，在四个人的注视下显得窘迫不堪，脸都<br>要红起来。女子同情地看了他一眼：“可怜的家伙，不用太紧张，每一个刚到这里<br>的人都是这样。慢慢就习惯了。”</p><p>　　她把手搭到阿瓦登的肩上：“我们其实见过的，当然，我见过你，而你没见过<br>我。”她一边说，一边将自己的头发解下来，原来她留的是一头齐肩的乌黑长发，<br>头发披下来的一瞬间阿瓦登觉得她真的很美。</p><p>　　“我……我记得你，记得你的声音。”阿瓦登终于说出了一句完整的话，虽然<br>不够流畅。</p><p>　　“是吗，那可太好了。”女子笑起来，拉着他的手，让他坐到沙发上，递给他<br>一杯水。阿瓦登注意到这是一个款式古老的茶杯，上面还刻着花纹，杯子里的水带<br>着浓郁的香气，阿瓦登尝了一点，那种甜丝丝的味道对喝惯纯净水的舌头来说刺激<br>格外地大。让他觉得浑身一下子被注进了许多活力。</p><p>　　“弄到这个可不容易，我们也不是每周都能喝到。”女子坐到他身边，两只乌<br>黑的眼睛注视着他，“你是怎么知道这个集会的？”</p><p>　　阿瓦登把发现光盘暗示的过程说了一遍，其他四个人都赞许地点了点头。“果<br>然是个聪明人，脑筋还没被陈腐的空气腐蚀掉。”一个三十多岁的胖子称赞道，他<br>的嗓门大的要命。那个戴眼镜的中年人把两只手交叉在一起，表示赞同。</p><p>　　“这正是天生的说话会成员，聪明、敏锐，而且不甘屈从于沉默。”</p><p>　　“那么。”胖子提议，“先让我们鼓掌欢迎说话会的新成员吧。”</p><p>　　于是四个人鼓起掌来，小小的屋子里响起一片掌声。阿瓦登羞涩地举起杯子做<br>回应，他还不太习惯这样的场面。等到掌声稍息，他抬起头怯生生地问道：</p><p>　　“可以问个问题吗？说话会到底是什么？”</p><p>　　带他进屋的女子伸出食指，在他鼻子前两公分的地方比了一比，解释道：</p><p>　　“说话会，就是可以畅所欲言的集会。在这里你不必顾忌什么，说出任何你想<br>说的东西。这里没有敏感词汇，也没有健康互联网络。这里是绝对自由的空间，你<br>可以尽情释放你的灵魂，舒展你的身体，没有任何禁锢与束缚。”说着说着，她的<br>声音变的高亢、奔放，里面饱含了许多早已经被屏蔽掉的词汇，阿瓦登不曾听到这<br>样流畅连贯的话语很久了。</p><p>　　“我们的宗旨就是，说话，就这么简单。”中年人扶扶眼镜，补充道。</p><p>　　“可是，要说些什么呢？”阿瓦登又问道。</p><p>　　“任何事情，你心里想的任何事情都可以说出来。”中年人露出宽和的笑容，<br>“尤其是那些被美国政府限制的思想。”</p><p>　　这可真是一个大胆的集会啊，这分明就是犯罪，阿瓦登心想，但他发觉自己却<br>被这种犯罪慢慢地吸引住了。</p><p>　　</p><p>　　“当然，有件事我们会事先说明。说话会是危险的，每一个成员都冒着被有关<br>部门拘捕的风险。联邦执法人员也随时可能破门而入，以非法集会以及非法使用不<br>合法词语的名义把我们抓起来。你现在有权拒绝加入，并且离开。”</p><p>　　阿瓦登听到女子的警告，心里一度犹豫起来。但一想到此刻离去的话，那么又<br>要开始持续那种窒息的泥沼生活，他就难以压抑自己的烦闷。阿瓦登第一次发现，<br>原来“说话”对他来说是一个致命的诱惑，他先前并不知道自己原来是如此地渴望<br>着说话。</p><p>　　“我不会离开的，我要加入你们，说话。”</p><p>　　“那太好了。唔，那么不妨就从自我介绍开始吧。”女子高兴地说，同时站起<br>身来，把右手搭到胸前，“从我开始。我的名字叫阿尔特弥斯，至于网络编号和身<br>份证号码，让他们见鬼去吧！谁会去管那个！我有我自己的名字，我不是数字。”</p><p>　　她的话让所有人包括阿瓦登都笑了起来。接着她继续说道：“不过，这其实只<br>是一个假名，这是希腊神话里的女神。”</p><p>　　“假名？”</p><p>　　“是的，和我户籍本上的名字是不同的。”</p><p>　　“可是，为什么？”</p><p>　　“你不会对自己在档案里的名字厌倦吗？我想起一个自己喜欢的名字，哪怕只<br>有一次机会也好，自己想叫什么就叫什么。在这个说话会里的每一个人都有一个自<br>己喜欢的名字，我们彼此拿这个称呼。”</p><p>　　阿瓦登若有所思地点点头，他很理解阿尔特弥斯的想法。事实上当他在使用网<br>络论坛的时候，也希望能够自己取一个称心如意的名字，而不是被分配一个用户名<br>。</p><p>　　通过介绍，阿瓦登了解到阿尔特弥斯是网络部BBS论坛管理科的职员，今年23岁<br>，未婚，最讨厌蟑螂和蜘蛛，喜欢缝纫与园艺，屋子里的花就是她偷偷从城市边缘<br>摘回来的。</p><p>　　接下来是那名中年人，他自我介绍说名字叫兰斯洛特，41岁，是城市电厂的一<br>名工程师；兰斯洛特这名字出自英国的亚瑟王传说，是一名忠贞的骑士。他有自己<br>的老婆和两个孩子，一男一女；男孩三岁，女孩四岁，他们最喜欢吃的就是柠檬味<br>道的水果糖。说到这里，兰斯洛特说希望下次聚会能把他们也带了，孩子们正是学<br>说话的时候，他想教给他们真正的说话。</p><p>　　那个三十多岁的胖子是网络部的一名网管，叫瓦格纳。这个身份让阿瓦登吃惊<br>不已，他的印象里网管都是些绷着脸全无表情的冷漠生物，但眼前的瓦格纳脸圆滚<br>滚的，油光锃亮，嘴边两条翘起的小胡子神气十足。他喜欢的是雪茄和歌剧，利用<br>网管的特权这两样东西都不难弄到。</p><p>　　“这个能屏蔽掉信号的门帘就是他弄的。”阿尔特弥斯补充说，瓦格纳冲她做<br>了个“乐意为您效劳”的手势，然后点燃了雪茄，把它放到嘴里，很快屋子里就笼<br>罩起一片稀薄的烟雾。</p><p>　　说话会的第四名成员是一位穿着黑色制服的女性，今年刚满三十。她的名字是<br>杜拉丝，城市日报（那个时代的报纸已经全部都数字化了）的编辑，她比阿尔特弥<br>斯还瘦，颧骨高高耸起，眼窝身陷，两片薄薄的嘴唇即使在最说话的时候也很少分<br>开，看不到牙齿。爱好是饲养狗和猫，尽管她并没有养。</p><p>　　“那么，到你了。”阿尔特弥斯对阿瓦登说。阿瓦登想了想，结结巴巴地把自<br>己的情况说了一遍，当谈到自己的爱好时候，他一时间居然想不到自己喜好什么，<br>似乎什么都没有，在那之前他甚至从来没想过。</p><p>　　“那，你最想做的是什么事呢？”阿尔特弥斯把手再一次放在他肩上，诱导着<br>问道。</p><p>　　“真的什么都可以？”</p><p>　　“什么都可以，在这里没有任何限制。”</p><p>　　阿瓦登觉得自己终于找到机会了，他咳了一声，抓抓头，脱口而出一句响亮的<br>叫喊：“FUXKYOU, YOUSONOFBITCH！”</p><p>　　在一瞬间，在座的四个人都被他这句话震惊了。瓦格纳率先反应了过来，他先<br>叼住雪茄，用力鼓掌，然后用右手把雪茄取下来，张嘴大声地赞叹道：“真棒，痛<br>快，这简直是最完美的入会誓词。”</p><p>　　“我宁可听十遍这样的脏话，也不想再去碰那个乏味的电子女声。”兰斯洛特<br>也是一脸陶醉，毫不掩饰自己对电子女声的厌恶。而阿尔特弥斯和杜拉丝全都咯咯<br>地笑起来，杜拉丝发现自己的笑容幅度大了一点，不好意思地把嘴掩住。阿瓦登觉<br>得他们与其说是觉得新奇，不如说是在享受这句脏话所带来的对体制的蔑视与挑战<br>。</p><p>　　“那你叫希望自己叫什么名字呢？” 阿尔特弥斯歪着头问。</p><p>　　“唔……王二。“ 阿瓦登沉吟了一下，回答说。这是一个中式的名字，他以前<br>有一个中国人朋友，喜欢讲故事，故事里的主角名字总是叫王二。</p><p>　　屋子里的气氛现在完全融洽了，大家都开始谈些比较自然的话题，每个人都摆<br>出了最舒服的姿势，阿尔特弥斯不时拿起茶壶来为大家续水。阿瓦登紧张的心情逐<br>渐放松下来，他感觉到自己的脑子前所未有地轻松。</p><p>　　“你知道的。”阿尔特弥斯又给他倒了一杯甜水，“我们一直想把说话会保持<br>在一定规模，平日是没有办法畅所欲言的，我们需要空间。麻烦的是，我们没办法<br>公开征集会员，又不可能直接通过物理接触去寻找，那风险太大。于是兰斯洛特就<br>设计了一套暗示系统，只有发现这些暗示的人才能知道本会的存在。”</p><p>　　“这套系统考虑到的还不止是安全问题。”兰斯洛特把自己的眼镜摘下来仔细<br>擦拭了一下，得意地说，“这其实也是一个会员资格验证。说话会所吸纳的成员，<br>必须有智慧，有头脑，内心渴望激情，并且对自由有着渴望。”</p><p>　　瓦格纳用两根指头夹着雪茄，在事先准备好的烟灰缸里弹了弹烟灰，大声说道<br>：“据我的经验，申请BBS论坛服务的人，大多数都是为了怀旧，或者说渴望一些新<br>鲜的东西，这样的人往往都怀有激情，认为BBS论坛也许能给他们一些与现实不一样<br>的东西——当然，事实上并非如此，美国政府对BBS论坛的管理甚至严厉过电子邮件<br>——这暗示着他们心里渴望解脱束缚。因此我们将暗示隐藏在申请BBS论坛的光盘之<br>中，只有申请人才有机会接触到这些暗示。而只有那些有智慧、观察敏锐的人才会<br>发觉到这些暗示的存在，并顺利解读出来，找到这里。”</p><p>　　“归根到底，说话会也不过是一群渴望自由说话的秘密小团体罢了。”兰斯洛<br>特笑道。</p><p>　　“你是第二个找到说话会的人，第一个是杜拉丝小姐。”</p><p>　　阿尔特弥斯告诉阿瓦登。阿瓦登敬佩地看了杜拉丝一眼，后者淡淡地回答道：<br>“这没什么，这是我的工作，我的工作就是摆弄文字。”</p><p>　　阿瓦登想到上一周在公共汽车站碰到的那个疯狂男子，于是把这件事讲给其他<br>成员听。听完之后，兰斯洛特摇了摇头，从嘴唇里滑出一声叹息：</p><p>“这样的事情我也是见过的，我的一个同事就是如此。所以说话会的存在是必要的<br>，这是缓解压力的阀门。长时间的敏感词汇限制会让人都疯掉的，因为他们既无法<br>思考又没办法表达。”</p><p>“这正是美国政府有关部门所希望看到的，这样只有傻瓜能够存活下来，一个全是<br>傻瓜的社会是稳定的。” 瓦格纳费力地把自己肥胖的身躯挪了一下位置，轻蔑地说<br>。</p><p>“你也是有关部门的一分子，瓦格纳先生。”阿尔特弥斯一边往茶杯里续了些热水<br>，一边抬头轻声说道。</p><p>“阿尔特弥斯小姐，我只是一个能比普通人多使用几个敏感词汇的普通人而已。”</p><p>　　大家都笑了起来。阿瓦登从来没有见过这么多的人说这么多的话，这是前所未<br>有的奇妙经验。他惊讶地发现自己居然很快就融进了这个小圈子里，隔阂与陌生感<br>很快就消失了；同时消失的还有胸闷与头晕等习惯性的毛病。</p><p>　　很快话题就从说话会本身扩展到了更加宽泛随意的话题，阿尔特弥斯唱支歌，<br>兰斯洛特说了几个笑话，杜拉丝则给大家讲了美国南部诸州的风土人情；瓦格纳甚<br>至还唱了一段歌剧，虽然阿瓦登一个字也听不懂，但他一点也不吝惜掌声。在这个<br>城市的某一个被屏蔽掉的角落里，五个不甘沉默的人正在享受着在这个时代视为奢<br>侈品的事情——说话。</p><p>　　“王二，你可曾看过《1984》？”</p><p>　　阿尔特弥斯忽然问道，她就靠着阿瓦登坐下，阿瓦登摇摇头，反问道：“这是<br>网络编号的一段么？”</p><p>　　“这是一本书的名字。”</p><p>　　“书？”阿瓦登听到这个名词，头摇的更大了。这是个古老的名词，在这个电<br>脑技术非常发达的时代，网络可以承载一切信息，任何人都可以在网上图书馆查到<br>电子版；因此有关部门认为实体书籍变成了一种没有必要存在的浪费，实体书也就<br>逐渐消亡了。瓦格纳对此的评论是：“有关部门喜欢电子书籍的心情是可以理解的<br>，电子书籍的话，只需要FIND和REPLACE两个命令就可以消灭掉全部不健康词汇，替<br>一本书消毒；而实体书籍的校对与修订却是件旷日持久的工作。”</p><p>　　“这是一本伟大的书，是旧世界哲人们对我们这个时代的预言。”阿尔特弥斯<br>认真地说。“它很早以前就洞察到了肉的束缚与解脱，灵的束缚与解脱，这是说话<br>会的基石。”</p><p>　　阿瓦登不无惊奇地发现他的网络编号开头恰好是这这本书名字：19842015。</p><p>　　“那么，该怎么样才能看到呢？”阿瓦登盯着阿尔特弥斯乌黑色的眼睛问。</p><p>　　“我们也无法找到纸质版，网络图书馆不可能存在这样的书。”兰斯洛特摇摇<br>头，然后重新露出笑容，左手向着杜拉丝摆了个请的姿势，“但我们的杜拉丝小姐<br>应该为她的记忆力而自豪，她在很早已经有幸阅读过这两本书，并且能够记得里面<br>的大部分文字。”</p><p>　　“太好了，然后她写下来了，对吗？”</p><p>　　“那太危险，这时代持有实体书是个大罪过，也容易让说话会暴露。我们只是<br>在每次聚会的时候请杜拉丝小姐为我们背诵。既然是说话会，那么把这两个故事讲<br>出来不是更名符其实吗？”</p><p>　　大家都安静下来，杜拉丝站起来走到屋子中央，其他四个人坐在旁边看着她。<br>阿瓦登不经意地把手搂在阿尔特弥斯肩上，后者微微朝这边靠过来，女性头发的幽<br>香“咝咝”地划过他的鼻子，让他的心里一阵荡漾。屋子里非常暖和，他分不清这<br>是花香还是阿尔特弥斯的味道。</p><p>　　杜拉丝的声音并不高，不过却很清晰有力；她的记忆力确实惊人，不仅记得情<br>节，包括一些细节和句子都可以复述下来。杜拉丝讲到了朱丽亚假装摔倒，然后偷<br>偷递给温斯顿一张写着“我爱你”的纸条，绘声绘色，这让听众们都听的入神了，<br>阿尔特弥斯听的尤其认真，以至于都没有注意到阿瓦登一直注视着她。</p><p>　　“1984的作者预见到了专制的进步，却没有预见到技术的进步。”瓦格纳在杜<br>拉丝停下来喝水的时候发表自己的评论，阿瓦登觉得他与外貌不太相称，是个很有<br>洞察力的技术官僚。</p><p>　　“在大洋国人们还可以靠传递纸条来偷偷表达自己的想法，但是现在不一样了<br>。美国政府有关部门把我们全赶到了网上，而在网络技术发达的今天，我们即使想<br>发一条短信都会被系统或者网管看的一清二楚，无从遁形。现实里呢，还有旁观者<br>在。”瓦格纳在腿上敲了敲雪茄根部，“一句话，技术是中性的，但技术的进步会<br>让自在的世界更自在，集权的世界更加集权。”</p><p>　　“这句话说的很有哲学家的味道哟。”阿尔特弥斯冲瓦格纳挤了挤眼睛，从抽<br>屉里取来一把饼干和曲奇散发给大家。</p><p>　　“就好象同样是0和1，有的人就能写出工具软件，有人却拿那个编出恶性病毒<br>？”</p><p>　　阿瓦登想到一个类似的比喻，瓦格纳听了以后满意地打了个响指。</p><p>　　“很不错的比喻，王二，就是如此，真不愧是程序员。”</p><p>　　谈话持续了不知道有多久，杜拉斯看了一眼墙壁上的挂钟，连忙提醒谈兴正浓<br>的四个人时间快到了。说话会不能持续很长时间，旁听者被屏蔽的越久，暴露的危<br>险就越大。</p><p>　　“那么好吧，我们就抓紧最后半个小时来完成今天的活动。”</p><p>　　阿尔特弥斯一边说着，一边将桌子上的空杯子收走。兰斯洛特和瓦格纳也都站<br>起身来，活动一下已经有些酸疼的肩膀和腰，只有杜拉丝坐在位子上没有动。</p><p>　　“活动？还有什么活动？”</p><p>　　阿瓦登奇怪地问道，说话会除了说话还有其他活动？</p><p>　　“唔，对啊，我们还有其他活动。”阿尔特弥斯撩起额前的长发，对他妩媚一<br>笑：“我们还会和对方完全交流。”</p><p>　　“完全交流？”</p><p>　　“就是intercourse”</p><p>　　“………………”阿瓦登一下子变的脸色苍白，呼吸急促起来，仿佛胃里被灌<br>进去零下三十度的寒风，他几乎不相信自己的耳朵。</p><p>　　“说话会有说话的自由，也有选择与谁上床的自由。”阿尔特弥斯毫不羞涩地<br>说，“我们互相谈话，然后选择合适的人做爱，就象我们选择我们喜欢的词汇说话<br>一样。”</p><p>　　兰斯洛特看阿瓦登很窘迫，走过去拍拍他的肩膀，慢慢地说：“当然，我们不<br>会强迫任何人，这完全是在自愿的基础上。今天我还要早点回去照顾小孩，你们人<br>数正好合适。”</p><p>　　阿瓦登的脸色涨红，热的仿佛夏季的电脑CPU，他甚至不敢多看阿尔特弥斯一眼<br>。他憧憬过女性很长时间，但如此接近还是第一次。</p><p>　　还要回家去照顾小孩子的兰斯洛特向大家道别后就先行离去了，阿尔特弥斯将<br>房间留给瓦格纳与杜拉丝，然后带着惶恐不安的阿瓦登来到了另外一间房间。这间<br>显然是阿尔特弥斯的卧室，屋子里很简单，但却收拾的十分干净，在床上枕头旁还<br>摆着一个手制的布娃娃，床单和窗帘都是粉红色的。</p><p>　　最初的是由阿尔特弥斯主动开始的，丝毫没心理准备的阿瓦登只是被动地任她<br>摆布。经过了几轮挑逗，阿瓦登才逐渐放开，任由潜藏在自己心内的原始欲望奔流<br>出来，那种期待听到圆润女声的青春憧憬本来只是苦闷生活的意淫，而在今天它加<br>倍实现了。很快这种憧憬与他在现实中被压抑的郁闷合流，转化成了猛烈的冲动，<br>让他一次又一次与阿尔特弥斯融为一体。阿瓦登不知道这种冲动和他想大声说出“<br>FUXKYOU, YOUSONOFBITCH”冲动有什么不同，不过现在不是考虑这个的时候，他现<br>在脑子里想的只有尽情地、全无束缚地让自己释放激情，完全没有任何束缚。</p><p>　　强烈的刺激一波波地冲击着兴奋中枢，最终一阵快感浪潮在狂暴洋面扬起头来<br>，达到了一个极高的顶端。阿瓦登在那一瞬间感觉到了前所未有的自由，那种轻盈<br>无比的自由，以及因自由而生的快乐与疲惫。浑身是汗的他喘息着倒在了阿尔特弥<br>斯身上，一阵舒畅的倦意如潮水般淹没了他的身体……</p><p>　　……当他醒来的时候，发现阿尔特弥斯躺在自己身边，赤裸的身体好象一尊白<br>玉雕像，睡姿恬美静谧。他侧过身子去，慵懒地打了个呵欠，然后阿尔特弥斯睁开<br>了眼睛。</p><p>　　“很舒服，对不对？”她问道。</p><p>　　“是啊……”阿瓦登不知道该说什么好，他顿了顿，犹豫地说道：“你以前和<br>兰斯洛特、瓦格纳他们也……呃，我是说，象刚才那样子过吗？”</p><p>　　“是的。”阿尔特弥斯温柔地回答，她半支起胳膊，长发从肩膀披到了胸口。<br>她的大方坦白反而让阿瓦登有些不知所措。屋子里出现了一段时间的沉默，然后阿<br>尔特弥斯忽然开口问道：</p><p>　　“还记得今天杜拉丝讲的那段故事吗？女主角偷偷递给男主角写着“我爱你”<br>的纸条。”</p><p>　　“唔，还记得。”阿瓦登回答，很高兴终于能从那个拙劣的话题摆脱出来了。</p><p>　　“在有关部门的健康互联网络词汇列表里，没有爱这个字呢。在我们这个时代<br>，我爱你也是一个敏感词汇，被屏蔽掉了。”阿尔特弥斯的眼神里似乎是感慨，又<br>象是失落。</p><p>　　“我爱你。”阿瓦登不禁脱口而出，他知道在这间屋子里可以说出任何自己想<br>说的话，不必顾忌。</p><p>　　“谢谢你。”</p><p>　　阿尔特弥斯听到之后只是笑了笑，起身穿上衣服，催促阿瓦登时间差不多了。<br>阿瓦登有些失望，因为她没有预期反应的热烈，仿佛他刚才说的只是有些无关紧要<br>的东西。</p><p>　　这时候杜拉丝和瓦格纳已经离开了，屋子里只剩他们两个人。阿尔特弥斯把他<br>送到门口，将旁观者交给他，然后叮嘱他说：“记得在外面绝对不要提及说话会的<br>任何事情或者任何人，我们在说话会以外的地方是完全不认识的。”</p><p>　　“我记住了。”阿瓦登回答，然后转身要走。</p><p>　　“王二。”</p><p>　　阿尔特弥斯忽然叫道，阿瓦登连忙转身，还没等他反应过来，两片柔软温暖的<br>嘴唇忽然贴到了他的双唇，然后是一个细切的声音在耳边响起：“谢谢你，我爱你<br>。”</p><p>　　阿瓦登觉得眼睛有些湿润，他戴上旁观者，推开门，重新步入到那一片令人窒<br>息的世界中去，但他此时已与来时的心境大不相同。</p><p>　　此后阿瓦登的精神面貌明显有了改善。他谨慎地享受着这种秘密集会的乐趣，<br>并且乐在其中。每一周或者两周，他们五个人都会在周日秘密地举行说话会的活动<br>，聊天，唱歌或者听杜拉丝讲1984的故事。阿瓦登同阿尔特弥斯又“完全交流”了<br>几次，偶尔他也会跟杜拉丝“交流”。他有了两个身份，一个是现实中和网上的阿<br>瓦登，编号19842015，还有一个是说话会里的王二。他很享受这个名字，觉得这就<br>是自己另外的一个人生。</p><p>　　有一次集会，他们谈到了敏感词汇的问题。阿瓦登记得很早的时候——他对这<br>方面的记忆有点模糊——有关部门给出的是一份敏感词汇列表，由网站的内部管理<br>人员秘密参考使用，他对如何演变成现在的局面大惑不解。那一天瓦格纳带了一瓶<br>葡萄酒，兴致很高，于是索性给他们讲了讲“屏蔽”的进化史，身为网管的他经常<br>可以接触到这些资料。</p><p>　　在最开始美国政府只是单纯地屏蔽掉敏感词汇，但很快他们就发现这样的措施<br>根本没有用处。很多人会采取在词组中夹杂符号或者数字的方式来绕开系统检查；<br>于是有关部门不得不将这些近似敏感词汇也一一屏蔽掉。然而众所周知，数字与符<br>号之间的组合方式是近乎无限的，只要你有想象力，就完全可以组合出一个新的词<br>组而且不失掉他的原意。比如说“politic”这个词，就有“politi&#x2F;c”、“政pol<br>it&#x2F;ic”、“pol&#x2F;itic”等近乎无限种表达方式。</p><p>　　当有关部门意识到这个问题时，他们采取了新的策略。既然无法辨识词组，那<br>么就用单词屏蔽。这一举措在一开始是奏效的，违规交谈的人显著减少，但很快人<br>们就发现可以用同音字或者谐音的方式来继续表达自己的危险思想。即使有关部门<br>封掉全部敏感词汇的同音字，也无济于事，思想活跃的美国人充分发挥了自己的想<br>象力，使用隐喻，借代、类比、引申及其他修辞方法，或者将一个敏感词用数个不<br>敏感的字来代替。人类的思维方式要比电脑开阔许多。电脑屏蔽掉一条路，他们还<br>会有更多的路可以选择。</p><p>　　这一场水面以下的角力看起来似乎是美国大众要取得胜利。这时候，一个具有<br>逆向思维精神的人出现了。他的身份不明。有人说他是有关部门的主管；也有人说<br>他是因过度使用敏感词汇而被捕的危险人士。无论他是谁，总之整个局面被扭转过<br>来。他向有关部门建议，不再告诉大众禁止说什么，而是规定他们只能说什么，用<br>什么方式去说。有关部门很快就心领神会，制订了新的规章制度：取消了敏感词汇<br>列表，取而代之的是互联网络健康语言列表，并把这举措推广到了日常生活中的语<br>言屏蔽系统中去。</p><p>　　这一次，大众终于处于下风。以往他们与有关部门尽情地在网络与现实中捉着<br>迷藏，而现在他们却被有关部门扼住了咽喉。这样一来，有关部门可以有效率地掌<br>握住言论，因为整个语言的框架都被彻底控制了。在有限的空间内，大众几乎是无<br>计可施。</p><p>　　尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他<br>们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思<br>就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一<br>动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使<br>用。</p><p>　　“当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组<br>，那么就可以继续自由交流——你知道莫尔斯电码吧？”</p><p>　　瓦格纳说到这里，拿起茶杯一饮而尽，满意地打了一个嗝。</p><p>　　“可是，这场战争的代价就是语言的失落。表达能力会越来越贫乏，越来越淡<br>而无味，人们会越来越倾向于沉默，这对有关部门反而是好事。”兰斯洛特摆出一<br>副忧虑的表情，有节奏地用指关节敲击着桌面，“这样一来，岂不就等于是大众的<br>自由意识将语言推向死亡的边缘？真讽刺啊。按照这个趋势，有关部门是不会败的<br>，他们会笑到最后。”</p><p>　　“不，不，笑这种情感他们是不会了解的。”瓦格纳淡淡地回答。</p><p>　　“我倒是觉得，美国是一直处于恐惧的情感之中呢，生怕人们掌握了太多的词<br>汇，表达出太多的思想，变的难以掌握。”阿尔特弥斯说完摆出一副她在上班期间<br>冷若冰霜的呆板脸孔，学着僵硬的腔调喊了一句：“营造健康的网络环境，美国万<br>岁！”</p><p>　　杜拉丝、兰斯洛特与瓦格纳都哈哈大笑，唯一没笑的是王二（阿瓦登）。他对<br>于兰斯洛特刚才的那句话始终耿耿于怀：大众与有关部门的对抗，其最终结局就是<br>语言的消亡。那么他们现在这个小小的说话会，也只不过是在一列开向悬崖的列车<br>里关上窗帘，享受坠毁前最后的宁静罢了。</p><p>　　不过他没有说出口，因为这太煞风景了。阿瓦登不希望破坏说话会的气氛，这<br>对他很重要。</p><p>　　从说话会回到家里，阿瓦登躺在行军床上，双手枕着脑袋，陷入了沉思。自从<br>加入说话会以后，他变的比以前更容易陷入思考。有时候他想的是这个社会、这个<br>互联网络或者这座城市中存在的荒谬性；有时候他想的是自己的生活；还有时候他<br>想的是阿尔特弥斯。他不知道是不是在一个压抑的世界里，人的情感会变的格外强<br>烈，他现在陷入对阿尔特弥斯的迷恋无法自拔。阿瓦登一直很羡慕杜拉丝讲的《19<br>84》里面的温斯顿，他和朱利亚有一间两个人独处的小屋，一个只属于他们两个人<br>的小世界。</p><p>　　他在与阿尔特弥斯“完全交流”的时候曾经吐露过自己的心声，阿尔特弥斯没<br>有直接回答，而是表示两个人的关系无法再比说话会更近一步——维持现在的状态<br>就已经是个人行为的极限，有关部门可不会一直打瞌睡。“我们只能把感情生活压<br>缩在每周一次的说话会活动里，这已经很奢侈了。”她对他说，同时温柔地抚摩他<br>的胸膛。“只有在说话会里，我们才是阿尔特弥斯和王二。而在其他时间里，你是<br>19842015，而我是19387465。”</p><p>　　对此，阿瓦登只能发出一声轻轻的叹息，确实他不该奢求更多。</p><p>　　除了感情，发生变化的还有互联网络。自从加入说话会以后，阿瓦登逐渐发现<br>互联网表面下潜藏的一些东西。正如瓦格纳在一次活动的时候指出，普罗大众与有<br>关部门的战争从未结束，总会有思想和言论从严厉管制的缝隙中流泻出来。阿瓦登<br>发现，在完全公式化的EMAIL与网络论坛中其实隐藏着不少耐人寻味的细节，就好象<br>那个title一样，存在着各式各样的密码与隐藏寓意。这些东西出自不同人的手里，<br>样式和破译方式都不同，阿瓦登不知道那些密码背后隐藏的是怎样的内容。不过有<br>一点可以确知的是，说话会并不是唯一的一个地下集会，瓦格纳说的对，始终还是<br>有人在试图用“健康”词汇表达“不健康”思想。</p><p>　　讽刺的是，给阿瓦登感触最深的，是有关部门的管制。以往他只是模糊地感觉<br>到自己被绑缚起来，现在他能清晰地看清这种束缚与压抑的脉络，以及加诸在自己<br>身上的各种手段。在小小说话会中享受到的自在让他更加深刻地感受到在宽阔现实<br>中的不自在。</p><p>　　“FUXKYOU, YOUSONOFBITCH！”</p><p>　　每一次的聚会，三位男士都会轻蔑地一起高喊这一句粗话。他们清楚这不会给<br>有关部门带来什么不良影响，不过这确实很痛快。</p><p>　　这一周，阿瓦登特别地忙碌，他的同事因为不明原因而被屏蔽掉了，这样一来<br>整个项目就全压在了他一个人身上。这项目是为有关部分设计一种软件，用来控制<br>大功率主动式“旁观者”的能源分配控制。软件很复杂，他不得不每天在电脑前工<br>作十几个小时，只有在身体实在支撑不住的时候才停下来随便吃一点东西，喝一口<br>纯净水，困了就躺在旁边的行军床上睡上一觉，爬起来继续工作。屋子里满是浑浊<br>的烟味与袜子脏衣服的酸臭味，阿瓦登就在这种环境下蓬头垢面地敲着键盘，并不<br>时揉揉满布血丝的眼睛。</p><p>　　偏偏在这个时候屋子里的暖气坏掉了。洋灰色的暖气片从昨天开始就变的冰凉<br>，不再有热水流动。阿瓦登检查了一下，发现并不是管道问题，而且邻居们也碰到<br>同样的事，看来是供热系统出了问题。这一变故的正面影响是稍微淡化了屋子内的<br>酸臭味，负面影响是整个屋子变的有如冰窖一样。紧闭的窗户和门能挡住寒风，却<br>挡不住寒冷，低温让本来就寒酸的房间更笼罩上一层霜气。无论是那把木椅还是行<br>军床都象是冷酷的冰雕，屋子里唯一还有些热气的就只剩下电脑。阿瓦登不得不披<br>上所有的御寒衣物，蜷缩在床上，把电脑的散热口对准自己。</p><p>　　有关部门宣布“供热”和“暖气”暂时也被列入敏感词汇，于是阿瓦登没办法<br>写信向供热部门询问，只好静待，除了用来敲键盘的指头以外，尽量保持全身一动<br>不动，以节约热量。在停止供暖后的第四天，暖气片里终于传来“哗啦哗啦”的声<br>音，带着热气的水开始流动，屋子里恢复了温暖，“供热”和“暖气”又可以恢复<br>使用了。于是EMAIL与网络论坛上全都是“庆祝有关部门恢复供应暖气，急人民之所<br>急”的帖子，EMAIL新闻组里也全是类似主题。</p><p>　　不过这对阿瓦登来说太晚了，他生了病，感冒，而且是重感冒。他面色苍白，<br>全身软弱无力，头疼的象是被一枚达姆弹射入头部，只能躺在床上等医生。医生来<br>到他家里，给他做了两三次点滴，喂了一些叫不上名字的药片，叫他静养。这一场<br>病足足持续了数天，他不得不放弃参加这一星期的说话会，身体状况实在太差了，<br>阿瓦登甚至怀疑自己搞不好会因此而死掉。</p><p>　　阿瓦登躺在床上，心里懊悔不已，说话会是他唯一的乐趣，现在他却没办法参<br>加。他把头蒙在被子里胡思乱想，瓦格纳这一次会带什么特别的东西来呢？兰斯洛<br>特有没有把两个孩子也领过来？还有阿尔特弥斯，他没参加的话，她会和谁“完全<br>交流”呢？瓦格纳还是兰斯洛特？他还想到了杜拉丝，上一次的聚会里，杜拉丝讲<br>到了温斯顿在秘密幽会的屋子里对朱丽亚说“我们已经死了”，朱丽亚附和着说“<br>我们已经死了”，这时候第三个声音说道“你们已经死了。”</p><p>　　杜拉丝就讲到这里，就停住了。阿瓦登急切地想知道接下来发生了什么，第三<br>个声音是谁，是党吗？温斯顿和朱丽亚是否会被捕，他们会有什么样的下场？不光<br>是他，阿尔特弥斯也很希望知道后续情节的发展，不过她并没有去追问杜拉丝。</p><p>　　“让这成为一个悬疑，这样接下来的一周我们的生活都会在期待的乐趣中度过<br>。”她对阿瓦登说，然后两个人继续沉溺于intercourse的快乐。</p><p>　　“也许他们都会死。”阿尔特弥斯在交流结束后，看着天花板说。</p><p>　　“也许那只是奥布林的声音，他去探望他们。”阿瓦登安慰她道，但是他的心<br>里也不确定。</p><p>　　阿瓦登的病持续了十天，然后他终于痊愈了。他痊愈后的第一件事就是从床上<br>爬起来，然后去看墙上的日历：这一天恰好是星期日，说话会活动的日子。阿瓦登<br>已经缺席了一周，这已经令他如饥似渴，甚至做梦都在和他们一起喋喋不休地说着<br>话——所幸他并没有说梦话的习惯，所以24小时工作的旁观者并没发出任何警报。</p><p>　　阿瓦登简单地洗了一下脸，用一把有些生锈的剃刀沾着肥皂仔细地刮掉脸上粗<br>硬的胡须，然后咕噜咕噜地刷了刷牙齿，用手和毛巾沾着热水将自己蓬起的乱发压<br>下去。因为生病，有关部门发了一些补贴给他，其中包括两块羊角面包、两瓶姜汁<br>啤酒和一份精制砂糖。他将这些东西都用塑料布仔细包好，揣到宽大的军大衣里，<br>打算带到说话会上去与大家分享。</p><p>　　今天的天气和往常一样地冷，阿瓦登把自己裹在大衣里，登上前往效率大楼的<br>公共汽车。一路上车厢里的广播重复着“营造健康的互联网络”以及一些优秀网络<br>用户的先进事迹；车厢前面的电子屏幕不断滚动显示着最新的健康词汇列表，一个<br>旁观者自车顶垂下来睥睨着车内的每一个表情呆滞的人。阿瓦登坐在最后一排，望<br>着窗外不断向后移动的建筑物与枯黄的树木发呆。</p><p>　　车子很快就到达了辛普森大楼附近的车站，阿瓦登下了车，把手放到怀里摸了<br>摸塑料布包着的食物，朝着大楼走去。他在半路无意中抬起头，忽然一阵冰冷的寒<br>流刺入他的胸腔，迫使他停住了脚步。</p><p>　　有什么地方不对劲！</p><p>　　他看到了效率大楼的第五层阿尔特弥斯家的窗户发生了一些奇怪的变化。以前阿尔特弥斯家面向大街的窗户总是挂着粉红色的窗帘，而现在窗帘则被扯到了两边<br>，窗户大开，用肉眼可以勉强看到窗玻璃和屋子里雪白的墙壁。假如今天有说话会<br>的话，阿尔特弥斯绝对不会把有屏蔽效果的窗帘打开。而且打开窗户这件事也绝不<br>寻常，在这个城市里的室外空气十分浑浊，几乎不会有人会去开窗换气。</p><p>　　也就是说，今天并没有说话集会召开，而是发生了另外一些事情。阿瓦登望着<br>那窗户，心情开始变的有些慌乱，他把手从兜里掏出来，叼起一支香烟，把身体靠<br>在一根电线杆旁故做镇静，以免被行人怀疑。究竟说话会发生了什么，为什么这一<br>周停办了呢？要知道，只要还有复数的成员能够出席，说话会就会一直办下去，难<br>道说瓦格纳、兰斯洛特、杜拉丝和阿尔特弥斯同时无法出席？这种概率实在太小了<br>。阿瓦登一边这样想着，一边向四周不安地张望。忽然他看到了一样东西，一个念<br>头霎时占据了他的全部心灵，让他几乎眩晕过去。</p><p>　　“说话会本周不会有了，以后也不会有了。”阿瓦登嘴唇默默地蠕动着，面如<br>死灰。</p><p>　　他看到在街道内侧一处不起眼的地方隐藏着一个类似雷达天线的东西，其造型<br>很象是两个背部贴在一起的大碗。阿瓦登心里清楚这是什么东西：这正是他负责软<br>件设计的大功率主动式“旁观者”，这造型他很熟悉。这装置可以主动发射电波去<br>探测人们的声音，并检查其中是否存在敏感词汇。</p><p>　　这样的装置居然就安放在阿尔特弥斯家附近，那么就等于说话会完全暴露在了<br>有关部门的监控之下。主动式旁观者的强大刺探电波会轻易刺穿她家中的铅质窗帘<br>，把所有成员的话原封不动地传到有关部门耳朵里。</p><p>　　这是一个划时代的发明，这一技术的突破意味着有关部门可以不再被动地等待<br>警报，可以主动出击去刺探人们在任何时间任何地点说的任何话语。阿瓦登可以想<br>象接下来会发生什么，阿尔特弥斯他们的每一句话都被有关部门记录下来，会有机<br>器统计出到底有多少违禁词汇被他们使用过；然后联邦警察会冲进她的屋子，将正<br>在聚会的成员们都带走，只留下搜查过后空荡荡的房间和窗户。</p><p>　　阿瓦登想到这里，心如刀绞，他一点也不为自己的侥幸逃脱而感到幸运。他的<br>胃袋翻腾起来，一种恶心的感觉从胃里直接升到嘴边，让他想吐，却又不能吐——<br>因为“呕”也是个敏感词汇；大病初愈的孱弱身躯无法承受这种打击，象害了风寒<br>一样颤抖起来，几乎站立不住。</p><p>　　他不敢继续朝前走去，仓皇地转过身去，登上另外一辆公共汽车，把嘴闭的更<br>紧了。等阿瓦登回到自己家楼下，看到楼房附近另外一架新的主动式旁观者正在兴<br>建中，漆黑的天线在半空舒展开来，仿佛一面巨大的蜘蛛网。看来有关部门已经着<br>手在整个纽约市部署这种新兴高科技产品。</p><p>　　他不敢驻足观看，低着头从那巨大装置旁边走过，一路不停地走回家，然后把<br>自己的脸紧紧地压在枕头里，却不敢哭出声音来，连一句“FUXKYOU, YOUSONOFBIT<br>CH”都不能说。</p><p>　　从那以后，阿瓦登的生活回到了普通状态——就是说和原来一样沉滞、压抑、<br>欠缺激情，健康向上，缺乏低级趣味。兰斯洛特说过：“战争的结果就是，大众的<br>自由意识会将语言推向死亡的边缘”，现在看来，他的预言是很准确的：说话会的<br>覆灭，导致“说话”、“歌剧”、“完全”、“交流”几个词先后被剔除出了健康<br>词汇列表，成为敏感词汇。</p><p>　　另外，虽然阿拉伯数字还能用，但“1984”这一个数字组合也被屏蔽掉了，这<br>让包括阿瓦登在内的程序员在编写程序时不得不谨慎地检查数字是否违规，这额外<br>增加了很多工作量，让他更加疲惫。</p><p>　　阿瓦登不是没有担心过，也许在某一天的深夜，他就会忽然接到一封EMAIL，让<br>他留在家里不要动，不要试图在网络做任何动作；接着电话会响起，电子女声会把<br>这一要求重复再重复，直到警察打开他家的大门，把他带去未知的地方，那里有未<br>知的命运等待着他。《1984》后面的情节发展阿瓦登始终不知道，唯一知道的杜拉<br>丝已经彻底失踪了，所以温斯顿和朱丽亚的结局始终是个谜；就好象兰斯洛特、瓦<br>格纳、杜拉丝和阿尔特弥斯的结局一样，也不从得知。其实这两件事对于阿瓦登来<br>说没什么本质性的区别，所以它们也可以看做是同一个谜。</p><p>　　其实他最担心的，是阿尔特弥斯。每次想到这个名字，阿瓦登就难以抑制心中<br>的郁闷。她究竟会怎么样，彻底被屏蔽掉吗？如果是那样，那么她在这世界上遗留<br>下来的唯一痕迹，就是一个程序员记忆里的假名而已了。</p><p>　　说话会消失后三个星期，仍旧风平浪静，没有任何人来找过阿瓦登，他也没收<br>到过任何类似内容的EMAIL，阿瓦登一直在想，也许是他们没有吐露出自己的下落，<br>也可能是因为他们根本不知道——他们认识的只是一个叫王二的程序员。这个城市<br>里有数以千计的程序员，而王二是个假名。</p><p>　　因此，生活一如既往地平静。不，确切地说，还是有一点不同的，那就是互联<br>网络健康词汇列表：那上面的词组消失的速度比以前要快的快，每小时每分钟都有<br>词与单字飞快地在名单上消失，阿瓦登不得不花上大量时间去更新列表，以跟紧当<br>前形势。</p><p>　　与词汇列表更新速度相对的，EMAIL和网络论坛上的东西越来越乏味。因为人们<br>不得不用极有限的词去表达广泛的意思，大家都变得寡言少语。就连那些秘密的暗<br>语和联系方式也少了许多；整个网络就象是前些天阿瓦登家里出了问题的暖气片一<br>样：虽然名义上是给人带来温暖的东西，但却变的冰冷、僵硬，让人如坠冰窟。</p><p>　　这一天，阿瓦登从电脑前抬起头来，他看了看窗外迷茫的灰色天空，胸口一阵<br>抽搐，不由得痛苦地咳了一声。他拿起塑料杯，将杯子里的纯净水一饮而尽，杯子<br>丢进同样是塑料质地的垃圾桶里，发出钝钝的撞击声，他觉得自己的脑子也是一团<br>垃圾，举起手敲了敲，果然发出同样钝钝的撞击声。</p><p>　　然后他拿起大衣，戴上墨绿色的护目镜，走出门去。阿瓦登没带便携式的旁观<br>者，那东西已经不需要了，城市里到处都是主动式的旁观者，随时监听是否有违禁<br>词汇的存在。整个纽约现在就象是互联网络一样，被有关部门营造成十分健康。</p><p>　　阿瓦登这一次外出是有正当理由的，他决定去取消网络论坛服务，这服务已经<br>用不着了，因为无论EMAIL，新闻组，BBS论坛还是其他什么现在全部都变成了一样<br>的东西。</p><p>　　从日历来说现在应该是春季，但外面还是很冷，高大的灰色建筑矗立在平地上<br>，仿佛绝对零度下的石林。大团大团的风裹着黄沙与废气穿行其间，风沙无处不在<br>，让人置身其中而难以摆脱。阿瓦登把手揣进兜里，脖子缩进领口，畏缩着向网络<br>部的大楼走去。</p><p>　　忽然，他停下了脚步，惊讶地站在原地无法动弹。他看到阿尔特弥斯正站在前<br>面的路灯下，穿着黑色的制服。可是她的变化有多么大啊，面容象是老了十岁，满<br>脸都是衰老的皱纹，年轻的活力荡然无存；她听到脚步声，转过头来，两个乌黑的<br>大眼睛显得异常空洞，目光越过阿瓦登延伸到远方，没有一个明晰的焦点。</p><p>　　阿瓦登万万没有想到会在这个时间这个地点碰到她，这让他已经沉寂已久的心<br>灵泛起了几点火花，可惜他迟钝的神经已经无法表达出“激动”这一个简单的情感<br>了。两个人互相对视了一阵，他终于木然走到她身边，张了张嘴唇，想对她说些什<br>么。但是他掏出今天新发布的健康词汇列表，发现上面是一片空白——终于连最后<br>一个词组也被有关部门屏蔽了。<br>　于是阿瓦登只好保持着沉默，默默地与面无表情的她擦肩而过，继续向前走去<br>。他的身影逐渐融入同样安静的灰色人群之中，整个城市都显得寂静极了。</p></blockquote><p>全文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个三年前的Bug导致上线失败</title>
    <link href="https://www.yzhu.name/2020/05/30/History-Bug-And-Code-Review/"/>
    <id>https://www.yzhu.name/2020/05/30/History-Bug-And-Code-Review/</id>
    <published>2020-05-30T03:16:26.000Z</published>
    <updated>2025-11-11T03:53:15.768Z</updated>
    
    <content type="html"><![CDATA[<p>上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。<span id="more"></span></p><h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol><li>17:10：开始发布B组 </li><li>17:20：开始出现内存，接口超时报警；开发和SA开始介入</li><li>17:25：认为是新版本有问题立刻回滚</li><li>回滚后持续半小时问题没有出现</li></ol><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>根据开发反馈，本次上线功能逻辑非常简单，只有20多行代码，而且测试过程中没发现任何问题；于是，大家开始review那段代码，review后得出一致多结论，该代码没问题。逻辑非常简单，只有一个地方调用了一个方法；这个方法已经存在了好你年了，而且被多个场景在调用；另外，这个方法逻辑复杂，团队内没有人了解。大家一致认为这个方法不会有问题，毕竟经历了「时间的考验」。</p><h3 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h3><p>在测试环境又做了一轮压力测试，一切正常。根据目前点情况看来这个bug跟数据有关；就是说，可能是某条数据触发了这个bug的临界条件.所以，我们决定在生产环境发布一台机器做测试; 这次发布后5分钟后出现了内存飙升现象,马上切掉该机器的流量而且dump Jvm内存 。</p><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>拿到dump文件后立刻启动MAT分析；发现占用内存最多一个对象有3000多万个，分析该对象的调用盏都指向了同一行代码；「这段代码正是经历过时间考验的代码」。review这行代码相关部分马上发现有死循环的问题，只是满足这个条件的数据不容易出现。而这次的数据正好满足了这个条件。找到了原因，解决方法就很容易了；修改完代码review后没问题，测试，上线后一切正常；至此，该问题解决。这里可能有人会说死循环一般会首先导致CPU报警，怎么没看到我们提到CPU到问题；因为这台机器是16核CPU，所以一个核跑满并没有触发报警规则 。</p><h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol><li>必须严格执行code review，从流程上去控制</li><li>需要监控各项指标到同比变化</li></ol><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>我们总是强调code review到重要性，但执行的时候总有这样那样的原因导致落实不彻底；我不了解当时的情况，但这次的问题我相信只要做过code review是一定可以发现的。另外，我始终相信代码质量最终要依赖开发人员来保证，测试只能保证功能性问题。特别是一些非功能性的边界条件，只能依赖开发保证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线上问题" scheme="https://www.yzhu.name/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC(ShardingSphere)多数据库与springboot集成 -- 读写分离</title>
    <link href="https://www.yzhu.name/2020/04/11/ShardingSphere-Springboot/"/>
    <id>https://www.yzhu.name/2020/04/11/ShardingSphere-Springboot/</id>
    <published>2020-04-11T10:54:30.000Z</published>
    <updated>2025-11-11T03:53:15.776Z</updated>
    
    <content type="html"><![CDATA[<p>Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入<code>sharding-jdbc-spring-boot-starter</code>可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。<span id="more"></span></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h3><ul><li><p>实现<code>EnvironmentAware</code>接口 ，在方法<code>setEnvironment</code>解析properties配置可以获取所有配置信息</p></li><li><p>获取以<code>spring.ydal</code>为前缀的所有数据库配置</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; databases = PropertyUtil.handle(environment, &quot;spring.ydal&quot; , Map.class);</span><br></pre></td></tr></table></figure><ul><li>构造每个数据库的数据库的MasterSlave数据源</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;datasource&quot;, Map.class);</span><br><span class="line"> Preconditions.checkState(!dataSourceProps.isEmpty(), &quot;Wrong datasource properties!&quot;);</span><br><span class="line"></span><br><span class="line"> DataSource datasource = DataSourceUtil.getDataSource(dataSourceProps.get(&quot;type&quot;).toString(), dataSourceProps);</span><br><span class="line"> Optional&lt;DataSourcePropertiesSetter&gt; dataSourcePropertiesSetter = DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get(&quot;type&quot;).toString());</span><br><span class="line"> if (dataSourcePropertiesSetter.isPresent()) &#123;</span><br><span class="line">     dataSourcePropertiesSetter.get().propertiesSet(environment, prefix, dataSourceName, datasource);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">masterSlaveRule = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.masterslave&quot;, YamlMasterSlaveRuleConfiguration.class);</span><br><span class="line">MasterSlaveRuleConfiguration msConfig = new MasterSlaveRuleConfigurationYamlSwapper().swap(masterSlaveRule);</span><br><span class="line"></span><br><span class="line">Properties dsProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.props&quot;, Properties.class);</span><br><span class="line">MasterSlaveDataSourceFactory.createDataSource(datasource, msConfig, dsProps)</span><br></pre></td></tr></table></figure><h3 id="禁用ShardingSphere的Springboot的自动配置"><a href="#禁用ShardingSphere的Springboot的自动配置" class="headerlink" title="禁用ShardingSphere的Springboot的自动配置"></a>禁用ShardingSphere的Springboot的自动配置</h3><p>实现该扩展后以jar包的形式提供出去供多个项目使用，所以我们必须在jar里面禁用ShardingSphere的Springboot的自动配置；可以实现如下接口:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class YdalAutoConfigurationImportFilter implements AutoConfigurationImportFilter &#123;</span><br><span class="line">    private static final Set&lt;String&gt; SHOULD_SKIP = new HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(&quot;org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration&quot;));</span><br><span class="line">    @Override</span><br><span class="line">    public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">        boolean[] matches = new boolean[autoConfigurationClasses.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt; autoConfigurationClasses.length; i++) &#123;</span><br><span class="line">            matches[i] = !SHOULD_SKIP.contains(autoConfigurationClasses[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return matches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将<code>YdalAutoConfigurationImportFilter</code>加入<code>META-INF/spring.factories</code></li></ul><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><ul><li>详细代码： <a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入&lt;code&gt;sharding-jdbc-spring-boot-starter&lt;/code&gt;可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
