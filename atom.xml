<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yhzhu的随手记</title>
  
  
  <link href="https://www.yzhu.name/atom.xml" rel="self"/>
  
  <link href="https://www.yzhu.name/"/>
  <updated>2025-03-05T13:20:13.305Z</updated>
  <id>https://www.yzhu.name/</id>
  
  <author>
    <name>yhzhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在线工具集合网站</title>
    <link href="https://www.yzhu.name/2024/11/15/First-Efficiency-Lab/"/>
    <id>https://www.yzhu.name/2024/11/15/First-Efficiency-Lab/</id>
    <published>2024-11-15T14:16:33.000Z</published>
    <updated>2025-03-05T13:20:13.305Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发项目中，我们经常需要处理格式转换、日期计算、编码解码等琐碎的操作。这些任务通常要么需要在IDE中编写代码实现，要么需要在网上搜索相应的在线工具。经过一段时间后，我发现这种方式效率较低，于是我开发了一个集成常用工具的网站：<a href="https://www.firstefficiencylab.com/">https://www.firstefficiencylab.com</a> <span id="more"></span></p><p>该网站目前提供了以下几个工具:</p><h3 id="日期计算器"><a href="#日期计算器" class="headerlink" title="日期计算器"></a><a href="https://www.firstefficiencylab.com/date-calc.html">日期计算器</a></h3><p>计算日期天数差、增减天数以及查找特定日期,常用于处理与日期相关的业务需求。</p><h3 id="单位转换器"><a href="#单位转换器" class="headerlink" title="单位转换器"></a><a href="https://www.firstefficiencylab.com/unit-conv.html">单位转换器</a></h3><p>帮助进行英制和公制单位之间的自由转换,如常用的长度、重量、体积、温度等维度。</p><h3 id="JSON格式化"><a href="#JSON格式化" class="headerlink" title="JSON格式化"></a><a href="https://www.firstefficiencylab.com/json-format.html">JSON格式化</a></h3><p>将JSON数据格式化成有层级缩进的样式,或将格式化后的JSON转成单行,方便发现JSON语法错误。</p><h3 id="编-解码工具"><a href="#编-解码工具" class="headerlink" title="编/解码工具"></a><a href="https://www.firstefficiencylab.com/encode.html">编/解码工具</a></h3><p>使用常见的Base64、MD5、SHA等多种编码解码算法对文本进行转换,适用于加解密、哈希处理等需求。</p><h3 id="Unix时间戳转换"><a href="#Unix时间戳转换" class="headerlink" title="Unix时间戳转换"></a><a href="https://www.firstefficiencylab.com/timestamp.html">Unix时间戳转换</a></h3><p>将Unix时间戳转成可读的时间格式,或通过年月日等输入获取对应的时间戳。</p><h3 id="YAML-JSON转换"><a href="#YAML-JSON转换" class="headerlink" title="YAML/JSON转换"></a><a href="https://www.firstefficiencylab.com/yaml-json.html">YAML/JSON转换</a></h3><p>在YAML和JSON两种格式之间双向转换,并同时支持格式化和语法验证。</p><h3 id="转换图片为白地图"><a href="#转换图片为白地图" class="headerlink" title="转换图片为白地图"></a><a href="https://www.firstefficiencylab.com/image-segment.html">转换图片为白地图</a></h3><p>快速扣除商品背景，将证件照换为白地图，等场景，能够对图片进行一键抠图，快速处理。</p><p>这些工具的灵感大多来源于我们日常工作中的一些高频基本需求。核心目的是集中常用的小工具,提高这部分操作的效率。</p><p>工具地址: <a href="https://www.firstefficiencylab.com/">https://www.firstefficiencylab.com</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日常开发项目中，我们经常需要处理格式转换、日期计算、编码解码等琐碎的操作。这些任务通常要么需要在IDE中编写代码实现，要么需要在网上搜索相应的在线工具。经过一段时间后，我发现这种方式效率较低，于是我开发了一个集成常用工具的网站：&lt;a href=&quot;https://www.firstefficiencylab.com/&quot;&gt;https://www.firstefficiencylab.com&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>跨境电商用户标签系统架构设计</title>
    <link href="https://www.yzhu.name/2023/12/10/User-Tag/"/>
    <id>https://www.yzhu.name/2023/12/10/User-Tag/</id>
    <published>2023-12-10T10:25:21.000Z</published>
    <updated>2025-04-06T13:34:11.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、项目背景与业务价值"><a href="#一、项目背景与业务价值" class="headerlink" title="一、项目背景与业务价值"></a>一、项目背景与业务价值</h3><p>在竞争激烈的跨境电商领域，用户体验和精细化运营至关重要。为了实现<strong>精准营销、动态定价和运营分析</strong>等关键业务场景，我们需要更及时、更准确地理解用户行为<span id="more"></span>。</p><p>然而，传统用户标签系统依赖离线计算，数据更新频率为<strong>每日一次</strong>，实时性不足，无法满足业务快速响应用户行为变化的需求。例如，<strong>新用户下单后无法立即享受老用户折扣</strong>，<strong>个性化推荐也存在滞后性</strong>。</p><p>为了解决这些痛点，我们启动了<strong>实时用户标签系统</strong>项目，旨在构建一套<strong>高性能、低延迟、可扩展</strong>的用户标签基础设施，实现用户行为的<strong>实时采集、计算和应用</strong>，为业务增长提供有力的数据支撑。</p><p>系统上线后，成功支撑<strong>日均三千万级</strong>用户行为数据处理，<strong>标签更新延迟控制在500ms内</strong>，为以下关键业务场景提供了有力支持：</p><ul><li>  <strong>精准营销</strong>：基于用户标签实现<strong>千人千面</strong>的商品推荐，提升点击率和转化率。</li><li>  <strong>动态定价</strong>：根据用户标签（如新老用户）实施<strong>差异化价格策略</strong>，提升用户粘性和复购率。</li><li>  <strong>运营分析</strong>：通过用户行为标签进行<strong>用户行为洞察和转化率优化</strong>，指导运营策略调整。</li></ul><h3 id="二、架构设计全景图"><a href="#二、架构设计全景图" class="headerlink" title="二、架构设计全景图"></a>二、架构设计全景图</h3><h4 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h4><pre class="mermaid">graph TD    AAW[App/Web] -->|HTTP上报| A[区域A数据采集系统]    ABK[后端系统] -->|SDK上报| A    BAW[App/Web] -->|HTT上报| B[区域B数据采集系统]    BBK[后端系统] -->|SDK上报| B    A -->|MQ| C[标签计算系统]    B -->|MQ| C    C --> Da[区域A数据库集群: MongoDB+MySQL+Redis]    C --> Db[区域B数据库集群: MySQL+Redis]    Ea[标签查询] --> Da    Fa[用户系统]-->Ea    Ga[订单系统]-->Ea    Ia[营销系统]-->Ea    Ha[其它...系统]-->Ea    Eb[标签查询] --> Db    Fb[用户系统]-->Eb    Gb[订单系统]-->Eb    Ib[营销系统]-->Eb    Hb[其它...系统]-->Eb</pre><p><strong>数据流:</strong>  <code>App/Web/后端系统</code> → <code>HTTP/SDK上报</code> → <code>区域采集系统</code> → <code>RabbitMQ</code> → <code>标签计算系统</code> → <code>MongoDB/MySQL/Redis</code></p><p><strong>分层架构:</strong></p><ul><li>  <strong>数据采集层</strong>：采用 <strong>Nginx+SpringCloud</strong> 技术栈，<strong>双区域独立部署</strong> (区域A和区域B数据采集系统)，支持 <strong>App/Web/API 多端统一接入</strong>。具备 <strong>高并发 HTTP 接入</strong> 能力和 <strong>区域路由</strong> 功能，确保数据就近接入，降低网络延迟。</li><li>  <strong>消息中间件</strong>：复用现有 <strong>RabbitMQ 集群</strong>，降低运维成本。RabbitMQ 承担 <strong>数据缓冲和异步解耦</strong> 的作用，保障数据采集层和计算层之间的稳定通信。</li><li><strong>计算存储层</strong>：<ul><li>  <strong>标签计算系统</strong>：基于 <strong>Spring</strong> 构建，采用 <strong>轻量级规则引擎</strong> 框架，易于扩展和维护。</li><li>  <strong>规则管理</strong>：<strong>MySQL</strong> 存储标签规则，实现 <strong>规则版本控制和回滚</strong>，方便规则迭代和管理。</li><li>  <strong>标签存储</strong>：采用 <strong>MySQL+Redis</strong> 组合，<strong>MySQL</strong> 持久化存储标签规则与计算结果，<strong>Redis</strong> 提供 <strong>实时查询能力</strong>，支撑高并发的标签查询请求。</li></ul></li></ul><h4 id="2-核心组件设计"><a href="#2-核心组件设计" class="headerlink" title="2. 核心组件设计"></a>2. 核心组件设计</h4><table><thead><tr><th>模块</th><th>技术选型</th><th>设计要点</th></tr></thead><tbody><tr><td>数据采集</td><td>Nginx+SpringCloud</td><td>高并发HTTP接入，区域路由</td></tr><tr><td>消息队列</td><td>RabbitMQ集群</td><td>消息持久化，自动故障转移</td></tr><tr><td>标签计算</td><td>Spring</td><td>轻量级规则引擎，易于扩展</td></tr><tr><td>规则管理</td><td>MySQL</td><td>规则版本控制，支持回滚</td></tr><tr><td>标签存储</td><td>MySQL+Redis</td><td>冷热数据分离存储策略</td></tr><tr><td>用户行为存储</td><td>MongoDB</td><td>用户行为持久化</td></tr></tbody></table><h3 id="三、核心设计决策"><a href="#三、核心设计决策" class="headerlink" title="三、核心设计决策"></a>三、核心设计决策</h3><h4 id="1-数据采集方案"><a href="#1-数据采集方案" class="headerlink" title="1. 数据采集方案"></a>1. 数据采集方案</h4><ul><li>  <strong>多端统一接入</strong>：定义标准 <strong>HTTP 上报协议</strong>，统一 <code>App/Web/API</code> 多端数据接入方式，降低接入成本。</li><li>  <strong>区域路由策略</strong>：基于 <strong>用户标识自动路由</strong> 到相应区域采集节点，提升数据上报效率，降低网络延迟。</li><li><strong>数据校验机制</strong>：<ul><li>  <strong>上报数据格式校验</strong>：在采集层进行数据格式校验，过滤无效数据。</li><li>  <strong>去重处理</strong>：对重复上报数据进行 <strong>去重处理</strong>，保障数据质量，避免重复计算。</li></ul></li></ul><h4 id="2-消息中间件选型"><a href="#2-消息中间件选型" class="headerlink" title="2. 消息中间件选型"></a>2. 消息中间件选型</h4><table><thead><tr><th>对比维度</th><th>RabbitMQ优势</th><th>设计考量点</th></tr></thead><tbody><tr><td>运维成本</td><td>复用现有集群</td><td><strong>无需额外运维投入</strong></td></tr><tr><td>可靠性</td><td>消息持久化+ACK机制</td><td><strong>数据零丢失保障</strong></td></tr><tr><td>扩展性</td><td>集群模式支持水平扩展</td><td><strong>满足未来增长需求</strong></td></tr></tbody></table><p><strong>选型分析:</strong>  综合考虑 <strong>运维成本、可靠性和扩展性</strong> 等因素，<strong>复用现有 RabbitMQ 集群</strong> 是最优选择。RabbitMQ 集群具备良好的 <strong>消息持久化、ACK 机制和水平扩展能力</strong>，能够满足实时用户标签系统对消息队列的需求。</p><h4 id="3-计算存储架构"><a href="#3-计算存储架构" class="headerlink" title="3. 计算存储架构"></a>3. 计算存储架构</h4><table><thead><tr><th>数据类型</th><th>存储方案</th><th>设计考量点</th></tr></thead><tbody><tr><td>上报日志</td><td>MongoDB分片集群</td><td><strong>高吞吐写入，灵活 Schema</strong>，支持海量用户行为日志存储</td></tr><tr><td>标签规则</td><td>MySQL</td><td><strong>事务支持，版本管理</strong>，保障规则数据一致性和可维护性</td></tr><tr><td>标签结果</td><td>MySQL+Redis</td><td><strong>实时查询与持久化存储</strong>，兼顾实时查询性能和数据可靠性</td></tr></tbody></table><p><strong>存储选型:</strong></p><ul><li>  <strong>MongoDB 分片集群</strong>：适用于存储 <strong>海量、Schema 灵活</strong> 的用户行为日志数据，满足高吞吐写入需求。</li><li>  <strong>MySQL</strong>：适用于存储 <strong>结构化</strong> 的标签规则和标签结果数据，提供 <strong>事务支持和数据一致性</strong> 保障。</li><li>  <strong>Redis</strong>：适用于缓存 <strong>热点标签数据</strong>，利用其 <strong>高性能内存数据库</strong> 特性，提升标签查询效率。</li></ul><h3 id="四、性能优化实践"><a href="#四、性能优化实践" class="headerlink" title="四、性能优化实践"></a>四、性能优化实践</h3><h4 id="1-采集层优化"><a href="#1-采集层优化" class="headerlink" title="1. 采集层优化"></a>1. 采集层优化</h4><ul><li>  <strong>负载均衡</strong>：采用 <strong>Nginx 轮询 + 权重分配</strong> 策略，实现采集层负载均衡，<strong>单节点支持 10k QPS</strong> 高并发接入。</li><li>  <strong>异步处理</strong>：数据上报请求 <strong>异步化处理</strong>，降低请求响应时间，<strong>响应时间 &lt;50ms</strong>。</li><li>  <strong>数据压缩</strong>：采用 <strong>Gzip 压缩</strong> 技术，对上报数据进行压缩，<strong>降低 70% 网络传输量</strong>，提升传输效率。</li></ul><h4 id="2-容灾方案设计"><a href="#2-容灾方案设计" class="headerlink" title="2. 容灾方案设计"></a>2. 容灾方案设计</h4><ul><li>  <strong>消息重试</strong>：RabbitMQ 启用 <strong>死信队列</strong>，处理标签计算失败消息，保障数据可靠性。</li><li>  <strong>数据备份</strong>：MySQL 数据库进行 <strong>每日全量备份 + 增量备份</strong>，防止数据丢失。</li><li>  <strong>故障切换</strong>：Redis 采用 <strong>主从模式</strong> 部署，实现 <strong>主从自动切换</strong>，<strong>切换时间 &lt;30s</strong>，保障缓存服务高可用。</li></ul><h3 id="五、标签体系设计"><a href="#五、标签体系设计" class="headerlink" title="五、标签体系设计"></a>五、标签体系设计</h3><h4 id="1-标签分类模型"><a href="#1-标签分类模型" class="headerlink" title="1. 标签分类模型"></a>1. 标签分类模型</h4><pre class="mermaid">graph TD    A[用户标签] --> B(基础标签)    A --> C(行为标签)    B --> D[用户属性]    B --> E[设备信息]    C --> F[购买行为]    C --> G[浏览偏好]</pre><ul><li>  <strong>基础标签</strong>：描述用户的<strong>静态属性</strong>，例如：用户属性（年龄、地域）、设备信息（设备类型、操作系统）。<strong>更新机制为批量每日更新</strong>。</li><li>  <strong>行为标签</strong>：描述用户的<strong>动态行为</strong>，例如：购买行为（购买商品、订单金额）、浏览偏好（浏览商品类目、浏览时长）。<strong>更新机制为事件驱动实时更新</strong>。</li></ul><h4 id="2-典型场景实现：新用户转老用户逻辑"><a href="#2-典型场景实现：新用户转老用户逻辑" class="headerlink" title="2. 典型场景实现：新用户转老用户逻辑"></a>2. 典型场景实现：新用户转老用户逻辑</h4><p>以 <strong>新用户转老用户</strong> 标签更新场景为例，说明实时标签系统的应用流程：</p><ol><li> <strong>监听下单事件</strong>：系统 <strong>实时监听</strong> 订单系统产生的下单事件。</li><li> <strong>校验历史订单数</strong>：标签计算系统接收到下单事件后，<strong>校验用户近一年内历史订单数是否为 1</strong>。</li><li> <strong>触发标签状态变更</strong>：若校验通过，则 <strong>触发用户标签状态变更</strong>，将用户标签从 “新用户” 更新为 “老用户”。</li><li> <strong>推送价格策略</strong>：标签计算系统将 <strong>新的用户标签推送至商品服务</strong>。商品服务 <strong>实时更新价格策略</strong>，使用户在 <strong>&lt;500ms 内</strong> 看到商品价格折扣。</li></ol><h3 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h3><p>实时用户标签系统的成功上线，显著提升了用户标签的<strong>实时性</strong>和<strong>应用效率</strong>，为业务的<strong>精细化运营</strong>提供了强有力的数据支撑。项目在<strong>高性能、高可靠、可扩展</strong>等方面做了深入设计和优化，为后续的迭代升级奠定了坚实基础。</p><p>未来，我们将继续在以下方面进行探索和优化：</p><ul><li>  <strong>更智能的告警</strong>：引入 <strong>异常检测</strong> 等智能告警策略，提升问题发现和处理效率。</li><li>  <strong>更丰富的标签类型</strong>：扩展 <strong>用户兴趣标签、用户偏好标签</strong> 等，构建更全面的用户画像。</li><li>  <strong>更灵活的规则引擎</strong>：实现更负载的标签计算逻辑，提升系统灵活性。</li></ul><p>随着实时用户标签系统的不断完善，将为业务带来更大的价值，持续驱动业务增长。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、项目背景与业务价值&quot;&gt;&lt;a href=&quot;#一、项目背景与业务价值&quot; class=&quot;headerlink&quot; title=&quot;一、项目背景与业务价值&quot;&gt;&lt;/a&gt;一、项目背景与业务价值&lt;/h3&gt;&lt;p&gt;在竞争激烈的跨境电商领域，用户体验和精细化运营至关重要。为了实现&lt;strong&gt;精准营销、动态定价和运营分析&lt;/strong&gt;等关键业务场景，我们需要更及时、更准确地理解用户行为&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC(ShardingSphere)SQL监控实践</title>
    <link href="https://www.yzhu.name/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/"/>
    <id>https://www.yzhu.name/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/</id>
    <published>2023-11-25T07:54:41.000Z</published>
    <updated>2023-12-20T13:56:10.009Z</updated>
    
    <content type="html"><![CDATA[<p>最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起<span id="more"></span>。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们的需求是监控应用程序对数据库的SQL执行情况，并将其与现有的指标集成。我们希望监控以下指标（但不限于）：</p><ul><li>SQL语句的执行时间</li><li>SQL语句的执行次数</li><li>SQL语句的执行结果</li><li>SQL语句的主库和备库路由</li></ul><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>我们现有数据库相关技术栈包括MySql, Sharding-JDBC,HikariDataSource和MyBaties；在方案设计阶段，我们考虑了以下三种方案：</p><h4 id="ShardingSphere的metrics"><a href="#ShardingSphere的metrics" class="headerlink" title="ShardingSphere的metrics"></a>ShardingSphere的metrics</h4><p> ShardingSphere的agent供了SQL监控的功能，具体可参考<a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/observability/">ShardingSphere的可观测性</a>然而，该代理会暴露一个独立的监控指标页面，无法直接集成到我们现有的监控指标页面中。我们需要单独采集ShardingSphere代理的监控指标，并将其与现有指标进行整合，这增加了一定的复杂性，因此我们放弃了该方案。</p><h4 id="Mybaties的拦截器"><a href="#Mybaties的拦截器" class="headerlink" title="Mybaties的拦截器"></a>Mybaties的拦截器</h4><p> 使用MyBatis的拦截器实现SQL监控非常简单，只需实现<code>org.apache.ibatis.plugin.Interceptor</code>接口即可。以下是一个示例代码：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">    @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line">public class SqlMetricsInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];</span><br><span class="line">        SqlCommandType sqlCommandType = mappedStatement.getSqlCommandType();</span><br><span class="line">        /** 上报sql metrics**/</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        if (target instanceof Executor) &#123;</span><br><span class="line">            return Plugin.wrap(target, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  在容器启动后，我们将该拦截器注入到MyBatis的org.apache.ibatis.session.SqlSessionFactory中：<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line">private ObjectProvider&lt;Interceptor&gt; interceptorsProvider;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ObjectProvider&lt;SqlSessionFactory&gt; sqlSessionFactories;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    for (SqlSessionFactory factory : sqlSessionFactories) &#123;</span><br><span class="line">        for (Interceptor interceptor : interceptorsProvider) &#123;</span><br><span class="line">            factory.getConfiguration().addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  通过以上步骤，我们可以在现有的监控指标页面中看到采集到的与SQL相关的监控指标。但是，该方案无法区分主库和备库的SQL。</p><h4 id="JDBC-Statement"><a href="#JDBC-Statement" class="headerlink" title="JDBC Statement"></a>JDBC Statement</h4><p>  我们知道，最终的SQL执行是通过JDBC的Statement完成的，因此我们可以直接在JDBC的Statement执行SQL的地方上报监控指标。我们可以自定义Statement来执行SQL，并同时上报SQL的监控指标。以下是类关系图示例：<br>   <img src="/2023/11/25/ShardingSphere-JDBC-SQL-Metrics/ShardingSphere-JDBC-SQL-Metrics-class.png"></p><p>   在<code>DalStatement</code>和<code>PreparedStatement</code> 重载<code>executeQuery</code>和<code>executeUpdate</code> 方法增加相关监控指标，具体代码可参考<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">ydal-spring-boot-starter</a></p><p>   这样可以输出类似如下的metrics上报到prometheus<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sql_execute_time_seconds_count&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 82.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;slave&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 12.373654891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 14.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;select&quot;,&#125; 167.934782891</span><br><span class="line">sql_execute_time_seconds_count&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 1.0</span><br><span class="line">sql_execute_time_seconds_sum&#123;route=&quot;master&quot;,datasource=&quot;order&quot;,type=&quot;update&quot;,&#125; 0.493257718</span><br></pre></td></tr></table></figure><br>   通过这种方式，我们可以在现有的监控指标页面中查看采集到的SQL监控指标，并区分主库和备库的SQL。 详细代码：<a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次SQL监控的实践，我们成功地集成了SQL监控功能到我们的应用程序中，并将其与现有的指标集成在一起。这使得我们能够更好地了解应用程序对数据库的访问情况，并及时发现潜在的性能问题和瓶颈。我们选择了自定义的JDBC Statement来实现SQL监控，并通过上报监控指标的方式将其集成到现有的监控系统中。这种方案简单且有效，使我们能够对SQL执行进行精确监控，并根据需要进行进一步的优化和调整。尽管我们在本次实践中取得了成功，但我们也意识到SQL监控仅仅是性能优化和数据库访问管理的一部分。在未来的项目中，我们将继续探索更多的数据库访问优化技术，并进一步提高应用程序的性能和可伸缩性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近我们进行了一个项目的重构，其中一个重要目标是减少数据库访问的负载。由于核心数据库被多个应用程序访问，并且数据库服务器只能对整体数据库流量进行监控，我们需要在应用程序端监控不同应用程序的SQL请求，并将其与现有的指标集成在一起&lt;/p&gt;</summary>
    
    
    
    
    <category term="监控" scheme="https://www.yzhu.name/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Data Memcached集群迁移至Redis集群</title>
    <link href="https://www.yzhu.name/2023/09/09/Data-Memcached-To-Redis/"/>
    <id>https://www.yzhu.name/2023/09/09/Data-Memcached-To-Redis/</id>
    <published>2023-09-09T03:38:05.000Z</published>
    <updated>2025-04-06T13:37:05.092Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务规模的增长，我们的缓存系统面临扩展性和运维效率的挑战。近期我们团队将缓存系统从Memcached迁移到Redis集群。<span id="more"></span></p><h2 id="项目背景与迁移动机"><a href="#项目背景与迁移动机" class="headerlink" title="项目背景与迁移动机"></a>项目背景与迁移动机</h2><p>我们的缓存系统最初基于Memcached，性能表现稳定，但随着业务发展，Memcached的局限性逐渐暴露：</p><ul><li><strong>扩展性受限</strong>：Memcached集群不支持自动分片，扩容和缩容需客户端手动实现，操作繁琐且运维成本高，难以应对流量快速增长。</li><li><strong>监控能力薄弱</strong>：Memcached提供的指标有限（仅命中率、内存使用等），故障排查和告警不便，影响问题定位效率。</li><li><strong>数据类型单一</strong>：仅支持键值对，复杂业务需求需额外开发支持，效率低下。</li></ul><p>这些问题促使我们寻找替代方案，最终选择了Redis集群。迁移的目标不是提升性能，而是解决扩展性和监控问题，为未来发展预留空间。</p><h2 id="技术选型：为什么选择Redis集群"><a href="#技术选型：为什么选择Redis集群" class="headerlink" title="技术选型：为什么选择Redis集群"></a>技术选型：为什么选择Redis集群</h2><p>我们直接选择了Redis集群，原因如下：</p><ul><li><strong>成熟度</strong>：Redis的社区拥有丰富文档和活跃支持，而且我们团队在其他项目中的使用已非常成熟。</li><li><strong>功能优势</strong>：支持自动分片、丰富数据结构（如Hash、List）和内置监控，弥补Memcached的不足。</li><li><strong>团队熟悉</strong>：团队对Redis的开发和运维经验丰富，降低了学习成本。</li></ul><h2 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h2><p>迁移分为几个阶段，确保无侵入且风险可控：</p><ol><li><strong>代码改造</strong>：<ul><li>通过底层SDK适配Redis集群，封装缓存操作接口（<code>get</code>、<code>set</code>），业务代码无需改动。</li><li>配置动态切换缓存后端（Memcached或Redis）。</li></ul></li><li><strong>测试验证</strong>：<ul><li>模拟业务场景验证功能正确性。</li><li>测试Redis集群的扩容/缩容，确保无影响。</li></ul></li><li><strong>灰度发布</strong>：<ul><li>从5%流量开始，逐步增至20%，观察一周后全量切换。</li><li>按用户维度区分流量，避免数据一致性问题。</li></ul></li><li><strong>数据过渡</strong>：<ul><li>新请求写入Redis，旧数据在Memcached过期，无需显式迁移。这种策略能有效降低迁移复杂性。但对于某些关键缓存数据，可能需要更谨慎的迁移方案。</li></ul></li><li><strong>监控支持</strong>：<ul><li>使用Prometheus和Grafana，从测试到全量全程监控Redis和业务指标。关键监控指标包括Redis的CPU使用率、内存使用率、连接数、命中率、Key的数量，以及业务相关的错误率、请求量等。</li></ul></li></ol><h2 id="挑战与解决方案"><a href="#挑战与解决方案" class="headerlink" title="挑战与解决方案"></a>挑战与解决方案</h2><p>迁移中暴露了三个主要挑战，我们逐一解决：</p><ol><li><strong>大Key问题</strong>：<ul><li><strong>挑战</strong>：Memcached节点内存大，大Key不明显；Redis集群分片内存小，大Key导致负载不均。</li><li><strong>解决方案</strong>：将大Key拆分为多个小Key（如<code>user:123</code>拆为<code>user:123:profile</code>），均匀分布。</li><li><strong>效果</strong>：内存使用率从100%降至50%。</li></ul></li><li><strong>热Key问题</strong>：<ul><li><strong>挑战</strong>：Redis分片配置低，热Key高频访问导致QPS激增。</li><li><strong>解决方案</strong>：引入本地缓存（TTL 1分钟），允许短暂不一致，优先从本地读取。</li><li><strong>效果</strong>：Redis负载减少80%。</li></ul></li><li><strong>JVM崩溃</strong>：<ul><li><strong>挑战</strong>：在流量高峰时JVM崩溃，因为系统内部使用Redisson依赖的netty与gRPC依赖的netty版本冲突。</li><li><strong>解决方案</strong>：升级Redisson到最新版。</li><li><strong>效果</strong>：崩溃问题消失。</li></ul></li></ol><h2 id="迁移成果"><a href="#迁移成果" class="headerlink" title="迁移成果"></a>迁移成果</h2><ul><li><strong>性能与稳定性</strong>：<ul><li>迁移后性能和稳定性与Memcached持平，未见提升，因目标非性能优化。</li><li>压测显示两者在20万QPS下表现相当。</li></ul></li><li><strong>用户体验</strong>：<ul><li>页面加载时间和服务稳定性无变化，用户无感知反馈。</li></ul></li><li><strong>实际价值</strong>：<ul><li><strong>扩展性</strong>：Redis集群支持动态扩容，解决了Memcached的瓶颈。</li><li><strong>监控性</strong>：丰富指标提升了运维效率。</li></ul></li></ul><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol><li><strong>无侵入SDK</strong>：降低风险，业务代码稳定。</li><li><strong>灰度发布</strong>：分阶段切换，问题可控。</li><li><strong>关闭持久化</strong>：提升性能，适配需求。为了追求更高的读写性能，我们选择关闭了Redis的持久化功能。在生产环境中，需要根据具体的业务场景权衡是否开启持久化以及选择合适的持久化策略。</li><li><strong>全面监控</strong>：实时反馈，快速响应。</li><li><strong>聚焦扩展性</strong>：明确目标，预留潜力。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次迁移让我们从Memcached的局限中解脱，Redis集群为未来增长奠定了基础。虽然性能未提升，但扩展性和监控能力的改善达到了预期。关于成本方面，迁移到Redis集群可能会带来一定的服务器成本增加，但运维效率的提升有望在长期降低总体成本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着业务规模的增长，我们的缓存系统面临扩展性和运维效率的挑战。近期我们团队将缓存系统从Memcached迁移到Redis集群。&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>灰度发布过程中缓存数据一致性问题</title>
    <link href="https://www.yzhu.name/2023/05/13/Gray-Scale-Deployment-Cache-Consistency/"/>
    <id>https://www.yzhu.name/2023/05/13/Gray-Scale-Deployment-Cache-Consistency/</id>
    <published>2023-05-13T12:54:07.000Z</published>
    <updated>2025-04-06T13:36:49.951Z</updated>
    
    <content type="html"><![CDATA[<p>灰度发布是一种常见的上线策略。如果灰度发布时间较长，且在灰度期间各分组共用缓存，那么该过程中可能会面临缓存数据一致性的挑战。本文将讨论在灰度发布过程中导致缓存数据不一致的问题和解决方案。 <span id="more"></span></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通常，我们采用了灰度发布策略来确保新功能的平稳上线。我们将用户流量分为两个组（为了描述简单，假设灰度只有两个分组）：A组和B组。在灰度发布的第一阶段，我们选择将20%的流量分配给B组，将剩余的80%分配给A组。这样可以确保新功能在一部分用户中进行测试和验证，同时保持对大多数用户的稳定性。然而，在灰度发布过程中由于代码版本的不一致，导致A组和B组的缓存数据出现了不一致的情况。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在灰度发布期间可能出现以下两个场景导致数据不一致问题：</p><ol><li><p><strong>缓存增加元素：</strong> 在B组的代码版本（v2）中，我们增加了一个缓存对象的元素，但是A组的代码版本（v1）并没有包含这个元素。这导致A组写入缓存的数据，在B组读取时无法正确反序列化，导致数据解析失败。</p></li><li><p><strong>计算逻辑变化：</strong> 缓存对象的元素（e1）是逻辑计算得出的结果，在B组的代码版本（v2）中我们修改了该元素计算逻辑，但是A组的代码版本（v1）仍是旧的计算逻辑；这导致A组写入的缓存B组读出不符合预期，而B组写入的缓存A组读出不符合预期。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在面对这种缓存数据一致性问题时，我们采取了以下解决方案：</p><ol><li><p><strong>a/b组缓存隔离</strong>：A/B组分别访问不同的缓存，不同的分组可以连接不同的缓存或者不同的分组以不同的key前缀区分。然而实际情况是以上问题只会发生在极个别的缓存元素上。这种方案虽然能解决以上问题，但缓存数量会随着分组的增加而成倍增加，造成资源的严重浪费，同时缓存命中率也会下降。</p></li><li><p><strong>反序列化兼容增加的元素</strong>：基本所有的序列化/反序列化组件都支持该功能。比如JDK自带的功能确保<code>serialVersionUID</code>保持不变即可，或者使用protobuf、json等序列化类库都可以实现。该方法虽然能解决A组写入B读取反序列化失败的问题，但B组反序列化成功仍然缺少新增加的元素。</p></li><li><p><strong>使用新key</strong>：在B组代码中使用新的key，这样A/B组缓存可以彻底隔离。但对于某些底层数据结构，可能被上层很多缓存引用，而且是通过多级引用，开发人员容易遗漏某些key。</p></li><li><p><strong>版本控制</strong>：大致思路是每个缓存在key上携带本次变更的版本号。如果本次发布缓存元素没有变化，则版本号不变。具体实现过程如下：</p><ul><li>在Spring容器启动过程中获取所有标记<code>@Cacheable</code>注解的方法。</li><li>对方法返回值对象内元素按照元素类型和一定的算法计算对象code值。如果对象元素发生变化，则对象code值一定变化。如果是元素是自定义对象需要递归计算。</li><li>读写缓存时在缓存key增加code后缀。</li></ul></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后我们采用了<strong>版本控制</strong>的方案。在实施前，我们进行了充分的测试和验证，确保缓存的版本控制逻辑正确无误，并在灰度发布期间保持了缓存数据的一致性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;灰度发布是一种常见的上线策略。如果灰度发布时间较长，且在灰度期间各分组共用缓存，那么该过程中可能会面临缓存数据一致性的挑战。本文将讨论在灰度发布过程中导致缓存数据不一致的问题和解决方案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
    <category term="一致性" scheme="https://www.yzhu.name/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Session Memcached集群迁移至Redis集群</title>
    <link href="https://www.yzhu.name/2022/10/22/Session-Memcached-To-Redis/"/>
    <id>https://www.yzhu.name/2022/10/22/Session-Memcached-To-Redis/</id>
    <published>2022-10-22T14:51:20.000Z</published>
    <updated>2025-04-06T13:36:49.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>随着业务的快速发展，我们原有的 <code>session</code> 存储方案  <code>Memcached</code>  逐渐显露出一些瓶颈，主要体现在以下几个方面。：</p><ul><li>  <strong>扩展性受限</strong>：<code>Memcached</code> 集群不支持分片，要分片需要在客户端实现分片逻辑，<strong>扩容和缩容操作繁琐</strong>，运维成本较高，难以满足业务快速增长的需求<span id="more"></span>。</li><li>  <strong>监控能力薄弱</strong>：<code>Memcached</code>  提供的<strong>监控指标有限</strong>，难以全面掌握集群运行状态，<strong>故障排查和告警</strong>不够便捷。</li><li>  <strong>缺少持久化</strong>：<code>Memcached</code>  作为纯内存缓存，<strong>数据无法持久化</strong>，存在数据丢失风险，虽然 <code>session</code> 数据对持久化要求不高，但在某些极端情况下，数据丢失仍可能影响用户体验。</li></ul><p>为了解决  <code>Memcached</code>  的上述问题，并提升  <code>session</code>  存储的<strong>扩展性、可维护性和监控能力</strong>，我们决定将  <code>session</code>  存储方案迁移至  <strong>Redis 集群</strong>。<code>Redis</code>  集群在<strong>集群化、监控告警、数据持久化</strong>等方面都具备显著优势，能够更好地满足我们业务发展的需求。</p><h3 id="迁移方案与实施阶段"><a href="#迁移方案与实施阶段" class="headerlink" title="迁移方案与实施阶段"></a>迁移方案与实施阶段</h3><p>本次  <code>session</code>  迁移项目，我们采取了<strong>分阶段、平滑迁移</strong>的策略，最大程度降低迁移风险，保障业务的连续性和稳定性。整个迁移过程分为三个阶段：</p><pre class="mermaid">graph TD    subgraph "第一阶段"        A1[应用服务] --> |写| B1[Memcached]        A1 --> |写| C1[Redis]        B1 --> |读| A1    end        subgraph "第二阶段"        A2[应用服务] --> |写| B2[Memcached]        A2 --> |写| C2[Redis]        C2 --> |读| A2    end        subgraph "第三阶段"        A3[应用服务] --> |写| C3[Redis]        C3 --> |读| A3        B3[Memcached] -.-> |停止写入| A3    end</pre><ul><li><p><strong>第一阶段：双写 Memcached 和 Redis，读 Memcached</strong></p><ul><li>  <strong>目标</strong>：验证  <code>Redis</code>  集群的稳定性和性能，为后续切换读取流量做好数据准备。</li><li>  <strong>策略</strong>：应用系统同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>只从  <code>Memcached</code>  读取  <code>session</code>  数据</strong>。</li><li>  <strong>数据一致性保障</strong>：<strong>双写成功才算成功</strong>，确保  <code>Memcached</code>  和  <code>Redis</code>  数据一致性。任何写入失败都会记录详细日志并触发告警，方便后续数据补偿。</li><li><strong>持续时间</strong>：为了保证  <code>Redis</code>  集群中  <code>session</code>  数据的完整性，双写阶段持续 <strong>30 天</strong>，覆盖  <code>session</code>  的最长过期时间，确保  <code>Redis</code>  集群拥有全量  <code>session</code>  数据。</li></ul></li><li><p><strong>第二阶段：双写 Memcached 和 Redis，读 Redis</strong></p><ul><li>  <strong>目标</strong>：将读取流量平滑切换到  <code>Redis</code>  集群，验证  <code>Redis</code>  集群在高并发读取场景下的性能表现。</li><li>  <strong>策略</strong>：应用系统仍然同时向  <code>Memcached</code>  和  <code>Redis</code>  集群写入  <code>session</code>  数据，但<strong>读取操作切换至  <code>Redis</code>  集群</strong>。</li><li>  <strong>平滑切换</strong>：采用<strong>灰度发布</strong>策略，逐步将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，降低切换风险。</li><li><strong>回滚准备</strong>：<strong>保留  <code>Memcached</code>  的写入</strong>，为后续可能的回滚操作预留数据基础。</li></ul></li><li><p><strong>第三阶段：停止 Memcached 写入，读 Redis</strong></p><ul><li>  <strong>目标</strong>：完全切换到  <code>Redis</code>  集群，停用  <code>Memcached</code>。</li><li>  <strong>策略</strong>：<strong>停止向  <code>Memcached</code>  写入  <code>session</code>  数据</strong>，所有读写操作均转向  <code>Redis</code>  集群。</li><li><strong>风险评估</strong>：在进入第三阶段前，进行全面的<strong>风险评估</strong>，确认系统运行稳定，各项监控指标正常。由于第二阶段已经验证了  <code>Redis</code>  集群的读取能力，且  <code>Memcached</code>  写入持续运行，因此第三阶段的风险较低。</li></ul></li></ul><h3 id="关键技术挑战与解决方案"><a href="#关键技术挑战与解决方案" class="headerlink" title="关键技术挑战与解决方案"></a>关键技术挑战与解决方案</h3><p>在  <code>session</code>  迁移过程中，我们主要面临以下技术挑战：</p><ul><li>  <strong>数据一致性</strong>：在双写阶段，如何保证  <code>Memcached</code>  和  <code>Redis</code>  的数据一致性至关重要。我们通过<strong>双写强一致性策略</strong>和完善的<strong>异常监控告警机制</strong>来解决这个问题。</li><li>  <strong>平滑切换</strong>：如何平滑地将读取流量从  <code>Memcached</code>  切换到  <code>Redis</code>  集群，避免对用户体验造成影响。我们采用<strong>灰度发布</strong>策略，逐步切换流量，并密切监控系统运行状态。</li><li>  <strong>性能保障</strong>：<code>Redis</code>  集群在高并发场景下的性能是否能够满足需求，需要进行充分的验证。我们在第二阶段通过<strong>全量流量读取  <code>Redis</code>  集群</strong>，验证了  <code>Redis</code>  集群的性能表现。</li><li>  <strong>监控与回滚</strong>：如何全面监控迁移过程，及时发现和处理异常，并制定完善的回滚方案，保障迁移过程的安全可控。利用我们<strong>完善的监控体系</strong>，针对每个阶段制定了详细的<strong>回滚计划</strong>。</li></ul><h3 id="性能监控与回滚方案"><a href="#性能监控与回滚方案" class="headerlink" title="性能监控与回滚方案"></a>性能监控与回滚方案</h3><p>为了保障  <code>session</code>  迁移项目的平稳落地，我们建立了完善的性能监控和回滚方案：</p><h4 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h4><p>在整个迁移过程中，我们重点监控以下关键指标：</p><ul><li><strong>Redis 集群性能指标</strong>：<ul><li>  <strong>CPU 使用率、内存使用率</strong>：监控  <code>Redis</code>  集群资源使用情况，判断集群是否过载。</li><li>  <strong>请求延迟</strong>：监控  <code>Redis</code>  请求响应时间，评估  <code>Redis</code>  集群性能是否满足需求。</li><li>  <strong>错误率</strong>：监控  <code>Redis</code>  请求错误率，及时发现  <code>Redis</code>  集群异常。</li><li>  <strong>大key和热key</strong>：关注  <code>Redis</code>  的流量和CPU变化是否出现<strong>大key和热key</strong>。</li></ul></li><li><strong>Session 读写成功率</strong>：<ul><li>  <strong>Redis  <code>session</code>  读取成功率</strong>：监控从  <code>Redis</code>  集群读取  <code>session</code>  的成功率，确保读取操作正常。</li><li>  <strong>Redis  <code>session</code>  写入成功率</strong>：监控向  <code>Redis</code>  集群写入  <code>session</code>  的成功率，确保写入操作正常。</li><li>  <strong>Memcached  <code>session</code>  写入成功率</strong>：在双写阶段，监控向  <code>Memcached</code>  写入  <code>session</code>  的成功率，确保双写操作正常。</li></ul></li><li><strong>应用系统业务指标</strong>：<ul><li>  <strong>接口响应时间</strong>：监控应用系统接口响应时间，评估迁移对应用系统性能的影响。</li><li>  <strong>错误率</strong>：监控应用系统错误率，评估迁移是否引入新的错误。</li><li>  <strong>登录用户指标</strong>：监控登录用户数量变化，判断迁移是否影响用户登录。</li><li>  <strong>各阶段转化率</strong> (加购，生单，支付)：监控用户在各个关键业务流程的转化率，评估迁移是否对业务指标造成负面影响。</li></ul></li></ul><h4 id="2-回滚方案"><a href="#2-回滚方案" class="headerlink" title="2. 回滚方案"></a>2. 回滚方案</h4><ul><li>  <strong>回滚触发</strong>：当监控指标出现异常，例如：应用系统接口响应时间显著增加、业务指标出现明显波动等情况时，立即触发回滚。</li><li><strong>回滚步骤</strong>：<ol><li> <strong>流量切换</strong>：立即将  <code>session</code>  读取流量**回退到  <code>Memcached</code>**。由于第二阶段持续保持  <code>Memcached</code>  写入，<code>Memcached</code>  中仍然保有全量  <code>session</code>  数据，可以快速切换回读。</li><li> <strong>问题排查</strong>：回滚后，立即排查  <code>Redis</code>  集群异常原因，修复问题。</li><li> <strong>重新迁移</strong>：待问题解决后，重新评估并选择合适的时机再次进行迁移。</li></ol></li></ul><p>由于我们在第二阶段已经进行了充分的  <code>Redis</code>  集群读取验证，并且在第三阶段前进行了全面的风险评估，因此实际上<strong>并未触发回滚</strong>。  <strong>第二阶段保留  <code>Memcached</code>  写入的主要目的就是为了应对可能的回滚场景</strong>，为系统提供一层额外的安全保障。</p><h3 id="项目总结与收益"><a href="#项目总结与收益" class="headerlink" title="项目总结与收益"></a>项目总结与收益</h3><p><code>session</code> 从 <code>Memcached</code> 平滑迁移至 <code>Redis</code> 集群项目，历时数月，整个迁移过程较为顺利，最终<strong>平稳落地，达到预期目标</strong>。通过本次迁移，我们成功解决了 <code>Memcached</code> 在<strong>扩展性、监控能力</strong>等方面的瓶颈，为业务发展提供了更可靠、更高效的 <code>session</code> 存储方案。</p><p><strong>项目收益总结</strong>：</p><ul><li><strong>提升扩展性</strong>：<code>Redis</code> 集群具备良好的<strong>水平扩展能力</strong>，可以轻松应对未来 <code>session</code> 数据量的增长。相比原来需要在客户端实现分片的 <code>Memcached</code> 方案，<code>Redis</code> 集群的扩容和缩容操作更加简单直观，极大降低了运维成本。</li><li><strong>增强监控能力</strong>：<code>Redis</code> 集群提供<strong>更丰富的监控指标</strong>，并能与 <code>Prometheus</code> 等监控系统方便集成，提升运维效率。</li><li><strong>性能稳定</strong>：迁移后系统性能与原 <code>Memcached</code> 方案基本持平，但在运维性和可扩展性方面获得了显著提升，为未来业务增长预留了充足的扩展空间。</li><li><strong>为未来优化奠定基础</strong>：迁移至 <code>Redis</code> 集群，为后续 <code>session</code> 存储的<strong>性能优化、功能增强</strong>（例如，利用 <code>Redis</code> 更丰富的数据结构实现更复杂的 <code>session</code> 管理功能）奠定了基础。</li></ul><p>本次  <code>session</code>  迁移项目，  <strong>分阶段平滑迁移策略、完善的监控回滚方案、以及对数据一致性的高度重视</strong>，是项目成功的关键因素。  这些经验也为我们后续进行类似的大型系统迁移项目提供了宝贵的参考.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h3&gt;&lt;p&gt;随着业务的快速发展，我们原有的 &lt;code&gt;session&lt;/code&gt; 存储方案  &lt;code&gt;Memcached&lt;/code&gt;  逐渐显露出一些瓶颈，主要体现在以下几个方面。：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;扩展性受限&lt;/strong&gt;：&lt;code&gt;Memcached&lt;/code&gt; 集群不支持分片，要分片需要在客户端实现分片逻辑，&lt;strong&gt;扩容和缩容操作繁琐&lt;/strong&gt;，运维成本较高，难以满足业务快速增长的需求&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="技术方案" scheme="https://www.yzhu.name/tags/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用Apache HttpClinet连接池默认大小引发耗时瞬间升高</title>
    <link href="https://www.yzhu.name/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/"/>
    <id>https://www.yzhu.name/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/</id>
    <published>2022-07-30T05:54:02.000Z</published>
    <updated>2022-08-07T14:00:00.883Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由<code>HttpURLConnection</code>,<code>Apache HttpComponents</code>和<code>OkHttp</code>三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高<span id="more"></span></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>今天天收到报警说我们有一个服务A的接口TP95瞬间升高，打开监控检查发现流量瞬间升高时，耗时会瞬间升高，如图所示；<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/monitor.jpg" alt="图一"><br>打开链路跟踪查看调用链关系，发现该时接口耗时几乎全部耗费在调用下游服务B，如图所示；正常情况下服务B接口TP95耗时在500毫秒以内<br><img src="/2022/07/30/RestTemplate-HttpClinet-Connect-Pool/opentracing.jpg" alt="图二"><br>而且该服务接口连接超时设置2秒，读取超时设置2秒；所以预期内该接口在4秒内应该结束。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="监控检查"><a href="#监控检查" class="headerlink" title="监控检查"></a>监控检查</h4><ol><li>查看服务B的监控发现服务B的耗时一直很稳定，几乎没有波动</li><li>查看服务C对服务B相同接口的调用在该时刻也很稳定</li><li>查看服务A的GC监控，gc最长耗时60ms，也不会引起该问题 </li><li>查看网络监控，一切正常</li></ol><p>通过监控数据基本确定问题不在服务B，另外Ops工程师反馈近期也没做过任何infrastrucre调整；基本确定问题仍然在服务A，接下来review服务A请求服务B的相关代码</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>服务A代码中用<code>RestTemplate</code>调用服务B的接口, <code>RestTemplate</code>的Bean采用默认注入的Builder来生成，而且设置了连接超时和读取超时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">    return builder.setReadTimeout(Duration.ofMillis(readTimeoutConfig)).setConnectTimeout(Duration.ofMillis(connectTimeoutConfig)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码形式<code>RestTemplate</code>底层实现采用了<code>Apache HttpComponents</code>作为HTTP客户端，<code>Apache HttpComponents</code>在初始化过程中会用默认参数初始化连接池，最终代码会执行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public PoolingHttpClientConnectionManager(</span><br><span class="line">    final HttpClientConnectionOperator httpClientConnectionOperator,</span><br><span class="line">    final HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span><br><span class="line">    final long timeToLive, final TimeUnit tunit) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.configData = new ConfigData();</span><br><span class="line">    this.pool = new CPool(new InternalConnectionFactory(</span><br><span class="line">            this.configData, connFactory), 2, 20, timeToLive, tunit);</span><br><span class="line">    this.pool.setValidateAfterInactivity(2000);</span><br><span class="line">    this.connectionOperator = Args.notNull(httpClientConnectionOperator, &quot;HttpClientConnectionOperator&quot;);</span><br><span class="line">    this.isShutDown = new AtomicBoolean(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码第7行构造<code>CPool</code>时传递的常量<code>2</code>表示连接池请求相同域名最大连接数，<code>20</code>表示连接池访问所有域名的最大连接数 。</p><p>至此，问题已然清楚，当zeus-order请求量瞬间升高时zeus-order访问zeus的并发量也瞬间增大，如果超过2个并发的HTTP请求只能等待，由于没有设置从连接池获取连接的超时时间，会无限等待，直到连接池内有空闲的HTTP连接然后获取连接继续发出HTTP请求，这样整个请求耗时将可能超过设置的HTTP超时时间</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>基于以上分析，我们使用自定义的HttpClient传递相关参数即可，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        PoolingHttpClientConnectionManager connectMgr = new PoolingHttpClientConnectionManager() ;</span><br><span class="line">        connectMgr.setDefaultMaxPerRoute(defaultMaxPerRoute);</span><br><span class="line">        connectMgr.setMaxTotal(maxTotal);</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connectMgr)</span><br><span class="line">                .build();</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">                new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        requestFactory.setConnectTimeout(connectTimeoutConfig);</span><br><span class="line">        requestFactory.setReadTimeout(readTimeoutConfig);</span><br><span class="line">        requestFactory.setConnectionRequestTimeout(connectRequestTimeoutConfig);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(requestFactory);</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>自定义三个超时时间：<br><strong>connectTimeout</strong>:            建立连接的超时时间<br><strong>readTimeout</strong>:               读取数据的超时时间<br><strong>connectionRequestTimeout</strong>:  从连接池获取连接的超时时间</p><p>修改以后上线观察一天即时出现上述问题的高峰瞬间，耗时始终保持平稳。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Spring项目中，RestTemplate简化了HTTP请求和响应的封装，并且执行了Restful原则。底层HTTP请求由&lt;code&gt;HttpURLConnection&lt;/code&gt;,&lt;code&gt;Apache HttpComponents&lt;/code&gt;和&lt;code&gt;OkHttp&lt;/code&gt;三种实现。最近我们在使用Apache HttpClient作为RestTemplate底层实现时，由于使用不当导致耗时瞬间升高&lt;/p&gt;</summary>
    
    
    
    
    <category term="线上问题" scheme="https://www.yzhu.name/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基础组件升级策略与实践</title>
    <link href="https://www.yzhu.name/2022/03/26/Infra-Component-Upgrade/"/>
    <id>https://www.yzhu.name/2022/03/26/Infra-Component-Upgrade/</id>
    <published>2022-03-26T12:35:29.000Z</published>
    <updated>2023-12-20T00:57:35.798Z</updated>
    
    <content type="html"><![CDATA[<p>基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法； <span id="more"></span></p><h2 id="为什么需要基础组件"><a href="#为什么需要基础组件" class="headerlink" title="为什么需要基础组件"></a>为什么需要基础组件</h2><p>为什么我们的系统要引入基础组件，使用基础组件由什么优势,以下根据个人体会列出了几点：</p><ol><li>提高开发效率：基础组件为提供了可重用、可定制和可扩展的组件和库。通过使用这些组件，开发团队能够快速搭建系统，并在不必从头开始编写代码的情况下实现常见功能。这大大提高了开发效率，缩短了产品上线时间</li><li>降低开发成本：通过使用成熟的基础组件，我们能够减少自主开发和维护的工作量。这意味着可以节省开发资源，并将精力集中在增值业务和创新上。</li><li>统一标准和规范：基础组件有助于确保在整个系统中使用一致的标准和规范。这种一致性使得不同团队的开发人员能够更好地协同工作，并减少因为不一致性而导致的问题。例如，使用统一的redis客户端组件限制一些危险命令的使用。</li><li>提升系统可靠性和稳定性：基础组件经过专业的设计和测试，通常具有高度可靠性和稳定性。它们被广泛使用和验证，可以减少系统中的错误和故障。而且，这些组件通常具有自动化的监控和错误处理机制，能够及时发现和处理潜在的问题，提高系统的稳定性。</li><li>解偶业务系统与中间件，平台之间的代码：提高系统的稳定性，方便维护，开发人员聚焦到业务功能开发；</li><li>提高管理效率，通过技术手段将操作流程规范化</li><li>安全性：确保系统采用安全大版本</li></ol><h2 id="为什么进行基础组件升级"><a href="#为什么进行基础组件升级" class="headerlink" title="为什么进行基础组件升级"></a>为什么进行基础组件升级</h2><ol><li>修复组件Bug,提高系统稳定性: 随着时间的推移,基础组件中会暴露出各种Bug,这些Bug可能会导致系统崩溃或业务异常。升级组件可以修复已知的Bug,提高系统稳定性。</li><li>获取最新功能特性,满足业务需要：基础组件推出新版本时,通常会提供新的功能和特性。业务需求瞬息万变,升级组件可以获得最新功能来满足业务需求。</li><li>改善性能,提升效率：新版本的基础组件通常在性能和效率上有改进,如增加缓存、优化算法等。升级后可以减少响应时长,提升系统吞吐量。</li><li>优化资源利用,降低成本：基础组件的新版本可能在资源调度和分配上进行了优化,可以提高资源利用率,降低系统运营成本。</li><li>提高开发效率：新版本组件通常会优化API设计,提高开发效率。同时修复Bug也可以减少开发调试时间。</li><li>解除对旧版的依赖：旧版本组件停止维护后,存在安全风险和兼容性问题。升级可以避免对旧版组件的依赖。</li><li>减少技术债务：使用了较旧版本的基础组件，可能会有技术债务积累，包括安全漏洞、性能瓶颈等；升级基础组件是控制技术债务的重要措施之一，积压的技术债务会制约公司发展</li><li>处理兼容性问题: 随着系统的发展和业务的扩展，可能需要与其他系统进行集成和交互，升级基础组件可以提供更好的兼容性和互操作性；</li></ol><h2 id="升级前的准备工作"><a href="#升级前的准备工作" class="headerlink" title="升级前的准备工作"></a>升级前的准备工作</h2><p>在进行基础组件升级之前，进行充分的准备工作是至关重要的，这可以帮助确保升级过程的顺利进行并最小化潜在风险。以下是升级前需要做的一些准备工作：</p><ol><li>明确目标： 定义升级的具体目标，明确您希望通过升级实现的业务和技术目标。了解升级所需的功能、性能、安全性等需求。</li><li>收集现有信息： 收集关于当前系统和基础组件的详细信息，包括版本、依赖关系、功能和性能特征等。这将有助于为升级过程做出更准确的决策。</li><li>评估风险和影响： 识别潜在的风险和影响范围，包括与升级相关的功能中断、兼容性问题、性能下降等。评估这些风险的严重程度，以便制定应对策略。</li><li>数据策略： 在进行升级之前，确保对系统进行完整的备份。如果升级中出现问题，可以回滚到之前的状态。对于数据库等有状态的组件，可以创建快照； </li><li>制定升级计划： 制定详细的升级计划，包括升级的步骤、时间表、责任人等。确定升级过程中需要涉及的各方，并为他们提供清晰的指导。对于较大范围升级工作，可以拆分为多个里程碑，尽可能保证每个步骤影响范围降到最低；</li><li>制定回滚计划： 确定如何还原系统到升级前的状态，以便在紧急情况下进行干预。原则上对升级操作的每个步骤都有对应的回滚步骤，如果不能回滚的场景下必须给出快速解决的方法。</li><li>测试环境预演： 在测试环境中进行升级的测试预演，以模拟真实生产环境。测试环境应该尽可能地与生产环境相似，以便更准确地预测升级可能的影响。</li><li>性能和压力测试： 在压测环境中进行压力测试，以评估新版本基础组件在不同负载条件下的表现。这有助于预测在生产环境中可能出现的问题。</li><li>制定上线计划通知所有相关方</li><li>用户培训： 如果新版本引入了新的特性或变化，为团队成员提供培训，确保他们熟悉和适应新版本。</li></ol><h2 id="升级实践"><a href="#升级实践" class="headerlink" title="升级实践"></a>升级实践</h2><ol><li>版本选择： 仔细评估新版本的功能、性能和安全特性。选择与业务需求最匹配的版本，同时考虑其稳定性和用户反馈,重点关注开源社区对issue list。</li><li>兼容性检查： 检查新版本与现有系统的兼容性。确保新版本不会破坏现有的功能和集成。</li><li>测试环境验证： 在测试环境中进行升级测试，尽量模拟真实生产环境，确保测试到各种可能影响到的场景。</li><li>自动化测试： 针对关键业务场景和功能，创建自动化测试用例。这有助于快速验证新版本的稳定性和正确性。</li><li>性能测试： 在压测环境中进行压力测试，以评估新版本在不同负载条件下的表现。识别潜在的性能问题。</li><li>数据迁移计划： 如果升级涉及数据存储系统，制定数据迁移计划。确保数据的完整性和一致性。</li><li>备份和回滚： 在进行任何升级操作之前，确保对系统进行全面备份。制定回滚计划，以便在升级过程中遇到问题时能够迅速还原。</li><li>灰度发布： 如果条件许可尽可能采用渐进式发布策略，将新版本逐步引入生产环境，以减少风险。</li><li>监控和报警： 升级后留意监控和报警，以便实时监控系统的性能和稳定性，及时发现并快速解决潜在问题。</li></ol><h2 id="升级后的监测与迭代"><a href="#升级后的监测与迭代" class="headerlink" title="升级后的监测与迭代"></a>升级后的监测与迭代</h2><ol><li>性能监测： 持续监测系统的性能，包括响应时间、吞吐量、延迟等。比较升级前后的性能数据，确保新版本不会导致性能下降。</li><li>稳定性监测： 监测系统的稳定性，识别是否存在崩溃、死锁、内存泄漏等问题。及时处理并解决这些问题，以确保系统不会因此而崩溃或变得不稳定。</li><li>资源利用率监测： 监测服务器、内存、CPU、网络等资源的利用率。确保新版本不会导致资源耗尽。</li><li>错误日志报警： 关注错误日志报警，确保升级后不会出现更多错误，防止问题升级为严重故障。</li><li>快速响应和修复： 如果发现了严重问题，确保能够快速响应并进行修复。灵活地进行紧急发布，以解决可能影响业务的问题。</li><li>收集用户的反馈: 了解用户在使用新版本时遇到的问题，帮助用户解决问题或在在后续版本修复。</li></ol><h2 id="设计基础组件的注意事项"><a href="#设计基础组件的注意事项" class="headerlink" title="设计基础组件的注意事项"></a>设计基础组件的注意事项</h2><p>在设计基础组件时，有一些注意事项可以考虑，以确保其可靠性、可扩展性和易用性。以下是一些常见的注意事项：</p><ol><li>定义清晰的接口：确保组件的功能和接口定义清晰明确。这将帮助其他开发人员理解如何正确使用组件，并减少潜在的集成问题。</li><li>高可用性和容错性：基础组件通常是系统中不可或缺的一部分，因此必须具备高可用性和容错性。考虑使用冗余、自动故障转移和负载均衡等机制来提高系统的可用性。</li><li>可扩展性：设计组件时要考虑到系统未来的扩展需求。确保组件可以水平扩展，以应对增加的负载和数据量。</li><li>安全性：基础组件通常处理敏感数据和关键业务逻辑，因此安全性是至关重要的。实施适当的安全措施，如身份验证、访问控制和数据加密等，以保护组件免受潜在的威胁。</li><li>性能优化：确保组件在处理大量请求和数据时能够提供良好的性能表现。使用高效的算法和数据结构，并进行性能测试和优化，以确保组件能够满足系统的性能需求。</li><li>文档和日志记录：提供清晰、详细的文档和日志记录，以便开发人员和运维团队能够理解组件的工作原理和故障排查方法。</li><li>监控和警报：实施监控和警报机制，以及时检测和响应组件的问题。监控关键指标，并设置警报以便在出现异常情况时及时通知相关人员。</li><li>版本控制和发布管理：使用版本控制系统来管理组件的代码和配置，确保可追溯性和可靠的发布管理。考虑使用自动化工具和流程来简化部署和升级过程。</li><li>可测试性：设计组件时要考虑到测试的可行性。提供适当的接口和工具，以便开发人员能够方便地编写和运行单元测试、集成测试和端到端测试。</li><li>与其他组件的集成：如果组件需要与其他组件进行集成，要确保接口和数据格式的兼容性，并进行充分的集成测试，以验证组件的正确性和稳定性。</li><li>遵循规范：组件实现需要遵循行业设计规范和标准,以提升互操作性</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础组件是我们系统构成的关键要素，包括中间件SDK、基础架构组件等。它们为系统提供了核心功能和基本服务，为业务逻辑的实现提供支持; 近几年多做了一些基础组件的升级，有些经历了较长的升级周期，也有的一次上线直接成功，还有个别组件升级失败了，目前仍然在寻找改进方法；&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>基于protobuf的定义在跨语言消息传递中的应用</title>
    <link href="https://www.yzhu.name/2021/09/21/message-dsl-base-protobuff/"/>
    <id>https://www.yzhu.name/2021/09/21/message-dsl-base-protobuff/</id>
    <published>2021-09-21T09:46:14.000Z</published>
    <updated>2023-12-20T01:04:50.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中<span id="more"></span>通常通过文档约定消息格式各自定义自己的消息体。在我们实际使用过程中发现不同语言之间传递信息还是会出现一些问题；比如：Java用fastjson输出复杂数据在Go项目解析失败，而且各语言在配置mq参数时候有各自的约定,人工操作容易引起误操作，所以我们希望能有一套跨语言的工具能分别生出各自语言的代码和配置。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>现有系统跨语言之间RPC的调用我们采用了gRPC,很自然的想到可以借鉴gRPC Protobuf定义消息体。具体方法就是扩展<code>google.protobuf.MethodOptions</code>定义</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>下面以RabbitMQ为例，在Protobuf文件中定义MQ相关参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extend google.protobuf.MethodOptions &#123;</span><br><span class="line">    </span><br><span class="line">    // exchange类型: topic direct fanout ,默认: direct</span><br><span class="line">    string routeType = 7010101;</span><br><span class="line"></span><br><span class="line">// producer 发送到exchange上有效的routekey; 仅topic模式有效</span><br><span class="line">    repeated string routeKey = 7010102;</span><br><span class="line"></span><br><span class="line">    //consumer监听的队列名称，direct模式 该参数无效</span><br><span class="line">    repeated string listener = 7010103;</span><br><span class="line"></span><br><span class="line">   // 延迟队列的延迟时间</span><br><span class="line">   int32 delay = 6010106;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>: 如果exchange为topic模式，监听队列绑定的routekey必须根据此处定义的routKey定义设置;比如文件定义的routeKey是a.b.c则consumer端绑定到队列的routkey只能是 a.b.c, a.b.<em>, a.</em>, * 其中之一</p><h5 id="生产Java代码"><a href="#生产Java代码" class="headerlink" title="生产Java代码"></a>生产Java代码</h5><p>通常在Maven工程中我们使用<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成gRPC的Java代码。现在我们可以扩展<a href="https://github.com/xolstice/protobuf-maven-plugin">protobuf-maven-plugin</a>插件生成MQ的代码。核心扩展点如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @Mojo(</span><br><span class="line">        name = &quot;compile-mq&quot;,</span><br><span class="line">        defaultPhase = LifecyclePhase.GENERATE_SOURCES,</span><br><span class="line">        requiresDependencyResolution = ResolutionScope.COMPILE,</span><br><span class="line">        threadSafe = true</span><br><span class="line">)</span><br><span class="line">public class ProtocCompileMQMojo extends AbstractProtocCompileMojo&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</span><br><span class="line">        super.execute();  </span><br><span class="line">        // 利用 DescriptorProtos.FileDescriptorSet 读取proto文件的定义根据规范生出Java文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配合MQ的SDK可以大大提高开发效率而且减低配置的复杂性。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在需要消息队列的场景中，生产端和消费端会事先就消息体格式达成共识确保生产端发送的消息在消费端能正常识别；如果生产端和消费都是Java项目，我们通常会定义消息体的Jar，让生产端和消费端都引用Jar确保消息的一致性；但在跨语言消息传递中&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>消息的可靠投递</title>
    <link href="https://www.yzhu.name/2021/04/13/reliable-message-delivery/"/>
    <id>https://www.yzhu.name/2021/04/13/reliable-message-delivery/</id>
    <published>2021-04-13T09:43:57.000Z</published>
    <updated>2022-01-21T07:07:58.069Z</updated>
    
    <content type="html"><![CDATA[<p>在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递<span id="more"></span>,即：不能丢消息。</p><h3 id="MQ消费术语"><a href="#MQ消费术语" class="headerlink" title="MQ消费术语"></a>MQ消费术语</h3><pre><code>为了保证保证消息的可靠投递，先了解一下MQ的消费术语</code></pre><ul><li><p>At Lest Once(至少一次)<br> 消息在消费的过程中，至少被发送到一个consumer; 如果consumer处理失败，会再次发送到consumer； 所以消息可能会重复被消费，通常会要求consumer保证幂等性</p></li><li><p>At Most Once(至多一次)<br> 消息在消费的过程中，至多被一个consumer消费; 如果consumer处理失败，消息可能会丢失；只能用于可接受消息丢失的场景  </p></li><li><p>Exactly Once(仅有一次)<br>发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。常用MQ产品没有太多理想的实现 。</p></li></ul><h3 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h3><p>我们以<a href="https://www.rabbitmq.com/">RabbitMQ</a>为例从以下几个方面保证说明如何实现消息的可靠投递</p><h4 id="消息中间件可靠性"><a href="#消息中间件可靠性" class="headerlink" title="消息中间件可靠性"></a>消息中间件可靠性</h4><ul><li>使用RabbitMQ的集群模式，basic模式和镜像模式都可以保证消息不丢失；根据业务特点在吞吐量和高可用之间权衡选择合适的集群模式</li><li>确保exchange和queue的持久化<h4 id="生产端可靠性"><a href="#生产端可靠性" class="headerlink" title="生产端可靠性"></a>生产端可靠性</h4></li><li>发送消息时候设置消息持久化属性<strong>DeliverModel</strong> </li><li>消息持久化到数据库状态为发送中</li><li>消息到达exchange开启confirm模式，生产者发送完消息后等待broker的ack，超过一定时间没有收到broker的ack后启动job重试，直到收到broker的ack，数据库消息状态更新为已发送</li><li>消息未到达队列开启回退机制，如果消息从exchange无法投递到队列，回调通知调用者，调用者可以重试<h4 id="消费端的可靠性"><a href="#消费端的可靠性" class="headerlink" title="消费端的可靠性"></a>消费端的可靠性</h4></li><li>消费端确保消息处理逻辑的幂等性</li><li>关闭自动ack</li><li>消费端每处理完一次消息后手动回复ack; 如果处理消息程失败回复nack, 默认情况下broker会继续下发消息直到消费成功；注意：消息处理失败必须回复nack，否则broker认为该consumer节点down，不再下发消息到该节点</li></ul><h4 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h4><p>对中间件，存储系统，应用等增加监控，在出现问题的时候能第一时间发现</p><p>综上所述，为了保证消息的可靠投递我们需要从开发和运维的角度去考虑；确保每一个环节都能可靠。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在大型互联网项目中我们经常会用到消息队列(简称MQ)；主要用在异步消息，应用解耦，流量削锋等场景；在实际应用中经常需要保证消息的可靠投递&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>跨境电商支付系统重构实战：从单体到微服务的演进</title>
    <link href="https://www.yzhu.name/2021/01/09/Payement-Rebuild/"/>
    <id>https://www.yzhu.name/2021/01/09/Payement-Rebuild/</id>
    <published>2021-01-09T02:09:08.000Z</published>
    <updated>2025-03-25T11:20:13.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们的支付系统最初作为单体应用的子模块存在，随着业务规模扩大，高并发下的<strong>掉单</strong>和<strong>重复支付</strong>问题频发，日均人工对账成本高达数小时。为解决这些痛点并支持未来业务扩展，我们决定将支付系统重构为独立的微服务架构，核心目标包括：<span id="more"></span><br><strong>稳定性</strong>：消除中间状态不一致导致的掉单<br><strong>可扩展性</strong>：快速接入新的支付渠道<br><strong>可维护性</strong>：降低模块耦合，提升迭代效率</p><h2 id="系统架构概览"><a href="#系统架构概览" class="headerlink" title="系统架构概览"></a>系统架构概览</h2><p>新的支付系统采用微服务架构并使用Docker部署，主要分为以下四个子服务：</p><table><thead><tr><th>服务名称</th><th>职责描述</th><th>特性要求</th></tr></thead><tbody><tr><td><code>pay-front</code></td><td>处理用户端支付请求，高并发优化</td><td>秒级弹性扩展</td></tr><tr><td><code>pay-backend</code></td><td>对接后端系统（如 OMS），保障交易稳定性</td><td>99.99% 可用性</td></tr><tr><td><code>pay-admin</code></td><td>管理后台配置（支付路由、规则）</td><td>配置变更秒级生效</td></tr><tr><td><code>pay-job</code></td><td>执行定时任务（对账、退款补偿）</td><td>分布式任务调度</td></tr></tbody></table><h4 id="服务间交互"><a href="#服务间交互" class="headerlink" title="服务间交互"></a>服务间交互</h4><ul><li><strong>pay-front:</strong> 接收到用户支付请求后，调用第三方支付渠道的接口进行支付处理。支付成功后通过 RabbitMQ 推送支付成功消息。</li><li><strong>pay-backend:</strong> 通过RPC接口接收来自后端系统（如 OMS）的查询和人工退款请求。</li><li><strong>pay-admin:</strong> 通过操作数据库（主库）来管理支付规则、支付路由等配置，并会主动使Redis缓存中的相关配置失效，使得下次用户请求时能够从数据库加载最新的配置。</li><li><strong>pay-job:</strong> 主要与数据库进行交互，执行定时任务，例如检查长时间处于中间状态的订单（支付中、退款中），并同步第三方支付渠道的状态来更新订单的最终状态。</li></ul><h4 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h4><p><strong>主从分离 + 读写隔离</strong>：</p><pre class="mermaid">graph TD    A[主库（写）] --> B[从库1（pay-front读）]    A --> C[从库2（其他服务读）]</pre><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>为了降低学习成本和提高开发效率，我们选择了团队目前最熟悉的技术栈：</p><ul><li><strong>开发语言:</strong> Java</li><li><strong>微服务框架:</strong> SpringCloud</li><li><strong>配置中心和注册中心:</strong> Consul</li><li><strong>缓存:</strong> Redis集群</li><li><strong>数据库:</strong> MySQL 主从分离</li><li><strong>消息队列:</strong> RabbitMQ</li><li><strong>链路跟踪</strong> Jaeger</li><li><strong>监控报警</strong>：Prometheus+Grafana+AlertManager</li><li><strong>日志</strong>：ELK</li><li><strong>容器化:</strong> Docker </li></ul><h2 id="核心功能实现"><a href="#核心功能实现" class="headerlink" title="核心功能实现"></a>核心功能实现</h2><p>新的支付系统涵盖了跨境电商支付的核心功能，包括：</p><ul><li>下单支付</li><li>退款</li><li>支付查询</li><li>对账</li><li>与全球10+三方支付渠道的集成</li></ul><h4 id="幂等性保障"><a href="#幂等性保障" class="headerlink" title="幂等性保障"></a>幂等性保障</h4><p><strong>问题</strong>：第三方支付回调重复导致订单状态混乱</p><p><strong>解决方案</strong>：</p><ul><li><strong>幂等 Key 生成</strong>：<code>订单号+支付渠道+时间戳</code>哈希值</li><li><strong>存储层校验</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO payment (id, order\_id, status, version)&amp;#x20;</span><br><span class="line"></span><br><span class="line">VALUES (?, ?, &#x27;PROCESSING&#x27;, 1)&amp;#x20;</span><br><span class="line"></span><br><span class="line">ON DUPLICATE KEY UPDATE version=version+1;</span><br></pre></td></tr></table></figure></li><li>*第三方透传**：在请求参数中携带幂等 Key，确保唯一请求标识<h4 id="最终一致性保障"><a href="#最终一致性保障" class="headerlink" title="最终一致性保障"></a>最终一致性保障</h4></li></ul><p><strong>中间状态处理流程</strong>：</p><pre class="mermaid">sequenceDiagram    participant User    participant pay-front    participant 第三方支付    participant pay-job        User->>pay-front: 用户在电商平台发起支付    pay-front->>第三方支付: 携带幂等Key请求    第三方支付-->>pay-front: 返回支付中    pay-front->>pay-job: 记录中间状态    pay-job->>第三方支付: 定时查询状态（每5分钟）    第三方支付-->>pay-job: 返回最终状态    pay-job->>数据库: 更新订单状态</pre><h4 id="配置动态生效"><a href="#配置动态生效" class="headerlink" title="配置动态生效"></a>配置动态生效</h4><p><code>pay-admin</code> 修改数据库配置后，触发 Redis 缓存失效；<code>pay-front</code>下次请求时从数据库加载最新配置</p><h4 id="错误处理与一致性"><a href="#错误处理与一致性" class="headerlink" title="错误处理与一致性"></a>错误处理与一致性</h4><p>设计<code>支付中</code>和<code>退款中</code>的中间状态，通过定时任务检查并更新订单状态以保证数据最终一致性。</p><h2 id="高可用与监控"><a href="#高可用与监控" class="headerlink" title="高可用与监控"></a>高可用与监控</h2><h3 id="监控体系"><a href="#监控体系" class="headerlink" title="监控体系"></a>监控体系</h3><table><thead><tr><th>维度</th><th>工具</th><th>监控指标</th></tr></thead><tbody><tr><td>性能监控</td><td>Prometheus+Grafana</td><td>QPS、RT、线程池利用率</td></tr><tr><td>日志分析</td><td>ELK</td><td>支付链路日志、异常堆栈</td></tr><tr><td>分布式追踪</td><td>Jaeger</td><td>服务间调用耗时、错误节点定位</td></tr></tbody></table><h2 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h2><p><strong>灰度发布流程</strong>：</p><pre class="mermaid">graph LR    A[旧系统] --> B{流量分配}    B -->|5%| C[新系统]    B -->|95%| A    C --> D[监控中心]    D -->|异常| E[触发回滚]    D -->|稳定| F[逐步增加至100%]</pre><p>我们采用了灰度发布的方式来上线新系统。首先将少量（5%）的用户流量切换到新系统，在一周内逐步增加流量到20%，稳定运行一周后，才进行全量切换。同时，我们的新系统接口能够兼容新旧数据格式，确保可以平滑过渡。</p><h2 id="关键挑战与解决方案"><a href="#关键挑战与解决方案" class="headerlink" title="关键挑战与解决方案"></a>关键挑战与解决方案</h2><h4 id="挑战-1：新旧系统平滑切换"><a href="#挑战-1：新旧系统平滑切换" class="headerlink" title="挑战 1：新旧系统平滑切换"></a>挑战 1：新旧系统平滑切换</h4><p>本次重构最大的挑战在于如何在保障现有系统稳定运行的前提下，平滑地切换到新的支付系统，并且几乎不对现有业务造成任何影响。我们主要通过以下策略来应对：</p><ul><li><strong>灰度发布:</strong> 逐步将用户流量导向新系统，降低风险。</li><li><strong>接口兼容:</strong> 新系统接口兼容旧数据格式，减少调用方改动。</li><li><strong>完善的监控和回滚计划:</strong> 实时监控系统状态，并制定了详细的回滚方案，以应对可能出现的问题。</li></ul><h4 id="挑战-2：第三方支付渠道适配"><a href="#挑战-2：第三方支付渠道适配" class="headerlink" title="挑战 2：第三方支付渠道适配"></a>挑战 2：第三方支付渠道适配</h4><p><strong>统一接入层设计</strong>：</p><ul><li>工厂模式：抽象PaymentChannelFactory，根据渠道ID自动路由到具体实现（如PayPal、Stripe）；</li><li>​模板方法模式：定义支付流程标准骨架（创建订单→调用渠道→状态回调），子类仅实现差异步骤。</li></ul><h2 id="收益与总结"><a href="#收益与总结" class="headerlink" title="收益与总结"></a>收益与总结</h2><p>新的支付系统上线至今，我们已经取得了显著的收益：</p><table><thead><tr><th>指标</th><th>旧系统</th><th>新系统</th><th>提升幅度</th></tr></thead><tbody><tr><td>日均掉单数</td><td>20+</td><td>0</td><td>100%</td></tr><tr><td>支付接口响应时间</td><td>1000ms</td><td>300ms</td><td>70%</td></tr><tr><td>新支付方式接入周期</td><td>5 天</td><td>1.5 天</td><td>70%</td></tr><tr><td>人工对账成本</td><td>4 小时 / 天</td><td>0.5 小时 / 天</td><td>87.5%</td></tr></tbody></table><p>本次支付系统的重构是一次成功的实践，我们不仅解决了旧系统的历史遗留问题，也为未来的业务发展奠定了坚实的技术基础。通过采用微服务架构、熟悉的技术栈和稳健的部署策略，我们实现了系统的平滑过渡，并显著提升了系统的稳定性、可扩展性和可维护性。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们的支付系统最初作为单体应用的子模块存在，随着业务规模扩大，高并发下的&lt;strong&gt;掉单&lt;/strong&gt;和&lt;strong&gt;重复支付&lt;/strong&gt;问题频发，日均人工对账成本高达数小时。为解决这些痛点并支持未来业务扩展，我们决定将支付系统重构为独立的微服务架构，核心目标包括：&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>转载：寂静之城 -- 马伯庸</title>
    <link href="https://www.yzhu.name/2020/09/05/The-Silence-City/"/>
    <id>https://www.yzhu.name/2020/09/05/The-Silence-City/</id>
    <published>2020-09-05T03:37:53.000Z</published>
    <updated>2022-05-02T15:44:54.694Z</updated>
    
    <content type="html"><![CDATA[<p>转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻<span id="more"></span></p><blockquote><p>And in the naked light I saw ten thousand people, maybe more. People tal<br>king without speaking, people hearing without listening. People writing<br>songs that voices never shared, no one dared disturb the sound of silenc<br>e. 　　　　　　　　　　　　　　　 — The sound of silence 　美利坚合众国，2015年，纽约。</p><p>　　当电话响起来的时候，阿瓦登正趴在电脑前面睡觉。电话铃声十分急促，尖锐<br>，每一次振动都让他的耳膜难受好久。他揉了揉干涩的眼睛，十分不情愿地爬起来<br>，觉得脑子沉滞无比。<br>　　其实他的脑子一直就很沉滞，这种感受既然是生理上的也是心理上的。他身处<br>的房间很狭窄，空气不很好，唯一的两扇窗户紧闭着——即使打开窗户也没用，外<br>面的空气更加浑浊。这是一间大约只有三十平米的小屋子，屋子墙壁上泛黄的墙纸<br>有好几处开始剥落，天花板上的水渍渗成奇怪的形状；一张老式的军绿色行军床摆<br>在墙角，床腿用白漆写着编号；紧挨着行军床的是一张三合板制成的电脑桌，桌上<br>摆着一台浅白色的电脑，机箱后面五颜六色的电线纠缠在一起，把它们自己打成一<br>个古怪的死结，杂乱无章地蔓延到地板与墙角，仿佛常春藤一样。</p><p>　　阿瓦登走到电话前，慢慢坐到地板上，目光呆滞地盯着电话，手却没有动。这<br>部古怪的东西是老式的按键式电话，大概是十几年前的款式，这是阿瓦登有一次去<br>费城出差时偶尔在一家杂货店里买到的；他拿回家以后稍微修理了一下，发现居然<br>还能用，这让他当时小小地兴奋了一阵子。<br>　　电话继续在响着，已经是第七声。阿瓦登意识到自己不得不去接听了。于是他<br>弓下腰，用两个指头拈起电话，慢慢把电话放到耳边。<br>　　“请说出你的网络编号？”话筒里传来的声音并不急噪，事实上它也不带其他<br>任何的感情色彩，因为这是电脑合成的人工智能语音系统。<br>“19842015”<br>　　阿瓦登熟练地报出一连串数字，同时开始觉得胸有些更闷了。说实话他并不喜<br>欢这些空洞的电子声音， 他有时候想，假如打过电话来的是一位声音圆润的女性该<br>多好。阿瓦登知道这是一种不切实际的幻想，不过这幻想会让他的身体得到几秒钟<br>的舒缓。</p><p>　　话筒里的声音仍旧在继续着。</p><p>　　“关于你在十月四日提交的网络论坛用户注册申请已经被受理，经有关部门审<br>查后确认资格无误，请在三日内持本人身份证件、网络使用许可证及相关文件前往<br>办理登记手续，并领取用户名及密码。”</p><p>　　“知道了，谢谢。”</p><p>　　阿瓦登谨慎地选择词语，同时努力挤出一副满足的微笑，好象话筒的另一侧有<br>人在看着自己一样。放下电话，阿瓦登先是茫然地盯着它看了大约两分钟，然后站<br>起来活动一下手腕，坐回到电脑前面，缓慢地推动了一下鼠标。</p><p>　　</p><p>　　电脑屏幕“啪”地一声亮了起来，显示出一个登陆的界面，还有一行英文：“<br>请输入你的网络编号和姓名。”阿瓦登将那八位数字敲进去，又输入了自己的名字<br>，点击“登陆”。随即机箱的指示灯开始频繁地闪动起来，整个机器发出细微的噪<br>音。</p><p>　　每一个使用互联网的人都有一个网络编号，没有这个编号，就无法连接进互联<br>网络。每一个编号都是独一无二的，每个人只有一个；这是使用者在网上的唯一代<br>号，既不能修改，也不能取消。这些编号分别对应着使用者身份证上的名字，因此<br>19842015就是阿瓦登，阿瓦登就是19842015。阿瓦登知道有些记忆力不好的人会把<br>自己的编号印在衣服的后面，那看起来颇为滑稽，也容易引发一些不正当的联想。</p><p>　　有关部门说使用网络实名制是为了规范网络秩序方便管理，杜绝因匿名使用网<br>络而产生的一系列重大问题和混乱。阿瓦登不太清楚那一系列重大问题会是什么，<br>他自己没试过用假名上网，他所认识的任何人里也不曾有人尝试过——事实上，从<br>技术角度来说，他根本没办法匿名登陆互联网络，没有编号就没有权限上网，而编<br>号则连接着他的详细档案，换句话说，没人能在网上隐藏自己。有关部门把这一切<br>都考虑的很周详。</p><p>　　“有关部门”，这是一个语意模糊、但却有着权威与震慑力的词组。它既是泛<br>指，又是确指，其所涵盖的意义相当广泛。有时候，它指的是为阿瓦登颁发网络编<br>号的美国联邦网络管理委员会；有时候它是将最新通告及法规发到阿瓦登EMAIL信箱<br>的服务器；还有时候它是监察网络的FBI特属网络调查科；总之一句话，有关部门是<br>无处不在，无职不司的，总会在适当的时候出现，给予指导、监控或者警告，无论<br>你是在网上还是网下。</p><p>　　简直就象是老大哥一样无微不至。</p><p>　　电脑仍旧在持续运转着，阿瓦登知道这得花上一阵子。这台电脑是有关部门配<br>发给他的，具体型号和配置阿瓦登并不清楚，机箱是被焊死的，无法打开。于是他<br>拿出一小瓶清凉油，用右手小拇指的指甲挑出一点抹在自己的太阳穴，然后从脚下<br>堆积如山的杂物里翻出一个塑料杯子，从桌子旁的饮水机里接了半杯蒸馏水，就着<br>一片镇痛片一饮而尽。蒸馏水穿过喉咙和狭长的食道滑进胃里，空泛的味道让他有<br>些恶心。</p><p>　　音响里忽然传来一阵美国国歌的旋律，阿瓦登放下杯子，重新把目光投到电脑<br>上去。这是已经连入互联网络的标志。屏幕上首先跳出来的是有关部门的通告，白<br>底黑色四号字，里面陈述了使用互联网的意义以及最新的规章制度。</p><p>　　“缔造健康的互联网络，美国万岁！”</p><p>　　音响里传来激昂的男性呼声，阿瓦登不大情愿地跟着大声念了一遍。“缔造健<br>康的互联网络，美国万岁！”</p><p>　　这段呼号持续了三十秒钟，然后消失，取而代之的是写着“缔造健康的互联网<br>络”标语的桌面背景。另外一个窗口慢慢浮上开，上面开列出几个选项：工作、娱<br>乐、电子信箱和BBS论坛。其中BBS选项呈现灰色，说明这项功能还没有开通。</p><p>　　整个操作系统简洁明了，这台电脑的浏览器没有地址输入栏，只是在收藏夹里<br>有几个无法修改的的网站地址。理由很简单，这些网站都是健康向上的，假如其他<br>站点和这些网站一样，那么只保留这些网站就够了；假如其他站点与这些网站不一<br>样，那么就是不健康的，是低级趣味，不能保留。这是有关部门精心设计的，是为<br>了公民的精神健康着想，生怕他们受到不良信息的侵染。</p><p>　　阿瓦登首先点开了“工作”，一连串和他工作相关的站点列表与相关软件在电<br>脑上显示出来。阿瓦登是一名程序员，他每天的工作就是根据上级的要求编写程序<br>。这份工作很无聊，不过可以保证他有稳定的收入。他不知道自己的源代码会被用<br>到哪里去，上级也从来没有跟他说过。 　　他打算继续昨天的工作，但是很快发现<br>自己很难继续下去。阿瓦登觉得今天的情绪比以前要烦躁，无法集中精神，大脑还<br>是很呆滞，胸口仍旧发闷。他试图娱乐自己，但是他发现“娱乐”选项里只有纸牌<br>与挖地雷，根据有关部门的说法，这是两个健康的游戏，没有暴力，没有色情，不<br>会让人产生犯罪冲动，也不涉及任何政治色彩。据说美国境外也是有互联网络站点<br>的，不过无法连上去，因为本国的互联网络自成格局，独立自主，普通人无法直接<br>连接到国外——IE浏览器没有地址栏，就算知道地址也没有用处。</p><p>　　“您有一封新邮件。”</p><p>　　系统忽然跳出来提示，阿瓦登终于找到了可以暂停工作的理由，他很快移动鼠<br>标到电子信箱的选项上，点开，很快一个新的界面出现了。</p><p>　　“To: 19842015</p><p>　　From：10045687</p><p>　　Subject: 模块、已经、完成、当前、项目、是否、开始。”</p><p>　　阿瓦登微微地叹了一口气，觉得有些失望。每一次他收到新的电子邮件，都希<br>望能够有一次新鲜的刺激来撞击他日益迟钝的脑神经，每一次他都失望了。其实他<br>早就知道这一点，只不过他觉得保持期待至少能够享受到几秒钟快感。就好象他期<br>待着打电话过来的是一个圆润温柔的女性声音一样。不给自己一些渺茫的希望，阿<br>瓦登觉得自己迟早会疯掉的。</p><p>　　这封信很简短，但是内容很充实。19842015是阿瓦登的网络编号，而10045687<br>则是他的一位同事的编号，这种工作性质的信件通常都以编号相称。信的内容是几<br>个不连续的英文单词，这是有关部门所提倡的一种电子邮件书写方式，因为这样可<br>以方便软件检查信件中是否含有敏感词汇。</p><p>　　阿瓦登打开回信的页面，同时另开了一个窗口，打开一份名字叫做“网络健康<br>语言词汇列表”的TXT文档。这是有关部门要求每一位网民所必须使用的词汇。当他<br>们书写电子邮件或者使用论坛服务的时候，都得从这个词汇列表中寻找适合的名词<br>、形容词、副词或者动词来表达自己想要说的话。一旦过滤软件发现网民使用了列<br>表以外的词，那么这个词就会被自动屏蔽，取而代之的是“请使用健康语言”。</p><p>　　“屏蔽”是个专有名词，被屏蔽的词将不允许再度被使用，无论是在书信里还<br>是口头都不允许。讽刺的是，“屏蔽”一词本身也是被屏蔽的词汇之一。</p><p>　　这个列表是经常更新的，每一次更新都会有几个词在列表上消失，于是阿瓦登<br>不得不费劲脑汁寻找其他词语来代替那个被屏蔽掉的词语或者单字。比如在以前，<br>“运动”这个词是可以使用的，但后来有关部门宣布这也是一个敏感词汇，阿瓦登<br>只好使用“质点位移”来表达相同的意思。</p><p>　　他对照着这份列表，很快就完成了一封文字风格与来信差不多的EMAIL——健康<br>词汇表迫使人们不得不用最短的话来表达最多意思，而且要尽量减少不必要的修辞<br>，所以这些信件就好象是那杯蒸馏水一样，淡而无味，阿瓦登有时候想，他早晚也<br>会和这些水和信一样腐烂，因为这些信是他写的，水是他喝的。</p><p>　　接下来阿瓦登启动检查软件先扫了一遍，确保自己没无意中加入什么敏感词汇<br>。等这一切都完成后，他按下了发送键，邮件被送出去了。</p><p>　　阿瓦登没有留下备份，因为他的机器里没有硬盘，也没有软驱、光驱或者USB接<br>口。这个时代宽带技术已经得到了很大发展，应用软件可以集中在统一的一个服务<br>器中，个人用户调用时的速度丝毫不会觉得迟滞。因此个人不需要硬盘，也不需要<br>本地存储，他们在自己电脑里写的每一份文档、每一段程序、甚至每一个动作都会<br>被自动传送到有关部门的公共服务器中，这样便于管理。换句话说，阿瓦登所使用<br>的电脑，仅仅具备输入和输出两种功能。</p><p>　　完成了这封信后，阿瓦登再度陷入了软绵绵的焦躁状态，这是一个连续工作了<br>三天的程序员的正常反应。这种情绪很危险，因为它让人效率低下精神低迷，而且<br>没有渠道发泄。“疲劳”、“烦躁”以及其他负面词汇都属于危险词汇，如果他写<br>信给别人抱怨的话，那么对方收到的将会是一封写满“请使用健康语言”的EMAIL。</p><p>　　这就是阿瓦登每天的生活，今天比昨天更糟糕，但应该比明天还稍微好一点。<br>事实上这个叙述也很模糊，因为阿瓦登自己并不清楚什么是“好一点”，什么是“<br>更糟糕”。“好”与“坏”是两个变量，而他的生活就是一个定量，只有一个常数<br>叫“压抑”。</p><p>　　阿瓦登推开鼠标，把脑袋向后仰去，长长地呼了一口气。（至少“呼”这个字<br>还没有被屏蔽）这是空虚的表现，他想哼些歌，但却又不记得什么，转而吹了几下<br>口哨，但那听起来与一只生了肺结核的狗差不多，只得做罢。有关部门象幽灵一样<br>充斥在整个房间里，让他无法舒展自己的烦闷。就好象一个人在泥沼里挣扎，刚一<br>张口就被灌入泥水，甚至无法大声呼救。</p><p>　　他的头不安分地转了几转，眼神偶尔撇到了摆在地板上的老式电话机，他忽然<br>想到还必须要去有关部门申请自己的BBS论坛浏览许可证。于是他关掉“工作”和“<br>电子邮件”窗口，退出了网络登陆。阿瓦登在做这些事的时候毫不犹豫，他很高兴<br>能够暂时摆脱互联网络，在那上面他只是一串枯燥的数字和一些“健康词汇”的综<br>合体。</p><p>　　阿瓦登找出一件破旧的黑色呢子大衣，那件大衣继承自他的父亲，袖口和领子<br>已经磨损的很严重，个别地方有灰色的棉花露出来，但还是很耐寒。他把大衣套到<br>身上，戴上一副墨绿色的护镜，用过滤口罩捂住嘴。他犹豫了一下，拿起“旁听者<br>”别在耳朵上，然后走出家门去。</p><p>　　纽约的街上人很少，在这个时代，互联网的普及率相当地高，大部分事务在网<br>上就可以解决，有关部门并不提倡太多的户外活动。太多的户外活动会导致和其他<br>人发生物理接触，而两个人发生物理接触后会发生什么事则很难控制。</p><p>　　“旁听者”就是为了防止这种事而发生的，这是一种便携式的语言过滤器，当<br>携带者说出敏感词汇的时候，它就会自动发出警报。每一位公民外出前都必须要携<br>带这个装置，以便随时检讨自己的言语。当人们意识到旁听者存在的时候，他们往<br>往会选择沉默，至少阿瓦登是如此。有关部门正逐步试图让网络和现实生活统一起<br>来，一起“健康”。</p><p>　　这时候正是11月份，寒风凛冽，天空漂浮着令人压抑的铅灰阴云，街道两旁的<br>电线杆仿佛落光了叶子的枯树，行人们都把自己包裹在黑色或灰色的大衣里面，浓<br>缩成空旷街道上的一个个黑点飞快移动着。一层若有若无的烟雾将整个纽约笼罩起<br>来，不用过滤口罩在这样的空气里呼吸将会是一件很有挑战的事情。</p><p>　　距离上一次离开家门已经有两个月了吧，阿瓦登站在公共汽车站的站牌下，不<br>无感慨地想，周围的一切看起来很陌生，泛黄，而且干燥。那是上一次沙尘暴的痕<br>迹。不过沙尘暴这个词也已经被屏蔽了，因此阿瓦登的脑海里只是闪过那么一下，<br>思想很快就转移到别的事情上去了。</p><p>　　站在阿瓦登旁边的是一个穿着蓝色制服的高个男人。他先是狐疑地看了阿瓦登<br>一眼，看到后者沉默地沉在黑色大衣里，他的两只脚交替移动，缓慢地凑了过去，<br>装做漫不经心对阿瓦登说：</p><p>　　“烟，有吗？”</p><p>　　男人说，每一个字都说的很清晰，而且词与词之间间隔也足够长。这“旁听者<br>”还没有精密到能够完全捕捉到每一个人语速和语调的程度，因此有关部门要求每<br>一位公民都要保持这种说话风格，以方面检测发言人是否使用了规定以外的词汇。</p><p>　　阿瓦登转过头去，看了他一眼，舔舔自己干裂的嘴唇，回答说：</p><p>　　“没有。”</p><p>　　男人很失望，又一次不甘心地张开嘴。</p><p>　　“酒，有吗？”</p><p>　　“没有。”</p><p>　　阿瓦登又重复了一次这个词，他也已经很久没有收到烟和酒了，也许是缺货的<br>关系吧，这是常有的事。不过有一点很奇怪，“旁观者”这一次却没有发出警报。<br>以阿瓦登的经验，以往一旦烟、酒或者其他生活必需品发生短缺现象，这个词就会<br>暂时成为被屏蔽掉的敏感词汇，直到恢复供给为止。</p><p>　　这个男人看起来很疲惫，红肿的眼睛是这个时代的人们普遍的特征，这是长时<br>间挂在网上的关系。他的头发蓬乱，嘴边还留着青色的胡子碴，制服下的衬衣领口<br>散发着刺鼻的霉味。能看的出，他也很久不曾到街上来了。</p><p>　　阿瓦登这时候才注意到，他的耳朵上空荡荡的，没有挂着那个银灰色的小玩意<br>“旁听者”，这实在是一件严重的事情。不携带“旁听者”外出，就意味着语言不<br>会再被过滤，一些不健康的思想和言论就有可能孳生，因此有关部门相当严厉地规<br>定公民上街必须携带旁听者。而这个男人的耳朵旁却什么也没有。阿瓦登暗暗吃惊<br>，一时间不知道是该去提醒还是装做没看到。他暗自想，也许向有关部门举报会更<br>好。</p><p>　　这时候那个男人又朝他靠近了一点，眼神变的饥渴起来。阿瓦登心里一阵紧张<br>，下意识地向后退去。这难道是一次抢劫？还是说他是个压抑太久的同性恋者？那<br>个男人忽然扯住他的袖子，阿瓦登狼狈地挣扎却没有挣开。出乎他的意料，那个男<br>人并没有进一步的动作，而是大吼一声，用一种阿瓦登已经不太习惯了的飞快语速<br>向他倾泻起话语来。阿瓦登被这突如其来的爆发弄的莫名其妙，不知所措。</p><p>　　“我只是想和你多几句话，就几句，我很久没有说过话了。我叫斯多葛，今年<br>三十二岁，记得，是三十二岁。我一直梦想有一套在湖边的房子，有一副钓鱼竿和<br>一条小艇；我讨厌网络，打倒网管；我妻子是个可恶的网络中毒者，她只会用枯燥<br>乏味的话叫我的网络编号；这个城市就是一个大疯人院，里面大疯子管着小疯子，<br>并且把所有没疯的人变的和他们同样疯狂；敏感词汇都去他X的，老子受够了……”</p><p>　　男人的话仿佛一瓶摇晃了很久然后突然打开的罐装碳酸饮料，迅猛，爆裂，而<br>且全无条理。阿瓦登惊愕地望着这个突然狂躁起来的家伙，却不知道如何应对；更<br>可怕的是，他发现自己居然对他产生了一点同情，那种“同病相怜”式的同情。男<br>人的话这时候已经从唠叨变成了纯粹谩骂，全部都是最直抒胸臆的那种。阿瓦登已<br>经有五、六年不曾说过这些脏话，最后一次听到这些也是四年前。有关部门认为这<br>都有碍精神文明，于是全部都屏蔽掉了。</p><p>　　而现在这个男人就在公众场合对着他大吵大嚷，似乎要将被屏蔽掉的敏感词汇<br>一口气全倒出来。他的目光和手势并不针对任何人，甚至也不针对阿瓦登，更象是<br>在一个人在自说自话。阿瓦登的耳膜似乎不习惯这种分贝，开始有些隐隐做痛，他<br>捂着耳朵，拿不定主意是干脆逃掉还是……这时候，远处街道出现两辆警车，一路<br>闪着警灯直直冲着这座公共汽车站而来。</p><p>　　警车开到站台旁时，男人仍旧在痛骂着。警车门开了，涌出了五、六名全副武<br>装的联邦警察。他们扑过去将那个男子按在地上，用橡皮棍痛打。男人两条腿挣扎<br>着，嘴里的语速更快了，骂出来的话也越来越难听。其中一名警察掏出一卷胶带，<br>“嚓”地一声扯下一条向男人的嘴贴去。男人在嘴被胶带封住之前，突然提高嗓门<br>，冲着警察痛快无比地喊了一句：“FUXKYOU, YOUSONOFBITCH！”阿瓦登看到他的<br>表情由疯狂变成享受，面带着微笑，似乎完全陶醉在那一句话所带来的无上快感和<br>解脱感中。</p><p>　　联邦警察们七手八脚地将男人送进了警车，这时才有一名警察走到了阿瓦登的<br>跟前。</p><p>　　“他，是，你朋友？”</p><p>　　“我，不，认识。”</p><p>　　警察盯了他一阵，取下他耳朵上的“旁观者”查看记录，发现他并没有提及任<br>何敏感词汇，于是重新给他戴回去，警告他说那名男子说的全部都是极度反动的词<br>汇，要求他立刻忘掉，然后转身押着那男子离开了。</p><p>　　阿瓦登松了一口气，其实刚才他有一瞬间涌现出一种冲动，也想在这空旷的街<br>道上大喊一声“FUXKYOU, YOUSONOFBITCH”那一定很爽快，他心里想，因为那男子<br>说出这句话的时候表情很享受。不过他也知道，这也是妄想的一种，“旁观者”紧<br>帖在耳朵上的冰凉感觉时刻提醒着他。 　　街上很快就恢复了冷清，十分钟后，一<br>辆公共汽车慢吞吞地开进站里，锈迹斑斑的车门哗啦一声打开，一个电子女声响彻<br>整个空荡荡的车厢：“请乘客注意文明用语，严格按照健康词汇发言。”</p><p>　　阿瓦登把自己缩进大衣，压抑住自己异样的兴奋，决定继续保持沉默下去。</p><p>　　大约过了一个小时，公共汽车到了目的地。从破碎的车窗玻璃里吹进来的寒风<br>让阿瓦登脸上挂起一层暗灰色的霜气，面部被风中的沙砾和煤渣刮的生疼。他听到<br>电子女声报出了站名，就站起身来，象一条狗一样抖抖身上的土，走下车去。</p><p>　　车站对面就是阿瓦登要去的地方，那是有关部门负责受理BBS论坛申请的网络部<br>。这是一间五层的大楼，正方形，全水泥混凝土结构，外表泛灰。如果没有那几个<br>窗户的话，那么它的外貌将与水泥块没有任何区别：生硬、死气沉沉，让蚊子和蝙<br>蝠都退避三舍。</p><p>　　BBS论坛是一种奇特的东西，从理论上来讲它完全多余，BBS的功能完全可以由<br>EMAIL新闻组来取代，后者更容易管理和审查。而且申请使用BBS论坛资格不是件容<br>易的事，申请人必须要通过十几道手续和漫长的审查才能有浏览资格，浏览资格三<br>个月才会被允许在指定论坛发布帖子，至于自己开设BBS则几乎是不可能。</p><p>　　因此真正对BBS有兴趣的人少之有少。阿瓦登当初之所以决定申请BBS论坛资格<br>，纯粹是因为他那种模糊但却顽强的怀旧心态，就好象他从杂货店里买的那部老式<br>电话一样。他也不知道自己为什么会自找麻烦，也许是为了给生活带来些刺激，还<br>是说为了强调自己和曾经旧时代的那么一点点联系，也许两者兼有之。</p><p>　　阿瓦登恍惚记得在他小的时候，互联网与现在并不太一样。并不是指技术上的<br>不同，而是一种人文的感觉。他希望能通过使用BBS论坛回想起一些当年的事情。</p><p>　　阿瓦登走进网络部的大楼，大楼里和外面一样寒冷，而且阴森。走廊里没有路<br>灯，蓝白色调的两侧墙壁贴满了千篇一律的网络规章条文与标语，冰冷的空气呼吸<br>到肺里，让阿瓦登一阵痉挛。只有走廊尽头的小门缝隙里流泻出一丝光亮，小门的<br>上面挂着一块牌子，上面写的是“网络部BBS论坛科。”</p><p>　　一走进这间屋子，阿瓦登立刻感觉到一阵温洋洋的热气。屋子里的暖气（或者<br>是空调）开的很大，让阿瓦登冻麻了的手脚和脸麻酥酥的，有些发痒，他不禁想伸<br>出手去挠挠。</p><p>　　“公民，请您站在原地不要动。”</p><p>　　一个电子女声忽然从天花板上的喇叭里传来，阿瓦登触电似地把手放下，恭敬<br>地站在原地不同。他借这个机会观察了一下这间屋子。这屋子准确来说应该是一个<br>狭长形的大厅，一道拔地而起的大理石柜台象长城一样将房间割裂成两部分，柜台<br>上还装着一排银白色的圆柱形栅栏，直接连到天花板。屋子里没有任何装饰，没有<br>观赏植物，没有塑料鲜花，甚至没有长椅和饮水机。</p><p>　　“缔造健康的互联网络，美国万岁。”</p><p>　　阿瓦登跟着声音重复了一遍。</p><p>　　“请前往八号窗口。”</p><p>　　电子女声的语调很流畅，因为这是电脑制作出来的，因此没有敏感词汇的限制<br>。</p><p>　　阿瓦登转头看到在自己右手边的不远处，大理石柜台上的液晶屏幕显示着八号<br>的字样。他走过去，拼命抬起头，因为柜台实在太高了，他只能勉强看到边缘，而<br>无法看到柜台另一侧的情形。不过他能听到，一个人走到柜台对面，坐下去，并有<br>翻动纸张与敲击键盘的声音。</p><p>　　“请把文件放入盒子里。”</p><p>　　柜台上的喇叭传来命令。出乎意料，这一次在喇叭里的声音却变了。虽然同样<br>冷漠枯燥，但阿瓦登还是能分辨出它与电子女声的不同——这是一个真正的女性的<br>声音。他惊讶地抬头望去，却什么都看不到，柜台太高了。</p><p>　　“请把文件放入盒子里。”</p><p>　　声音又重复了一次，语气里带着一丝烦躁，似乎对阿瓦登的迟钝很不满。</p><p>　　“是的，这是真正的女声……”阿瓦登想，电子女声永远是彬彬有礼不带任何<br>感情色彩的。他把相关的电子身份证、网络许可证、网络编号和敏感词汇犯罪记录<br>等一系列个人资料卡片一起放进柜台外的一个小金属盒子里，然后把盒子插进柜台<br>上一个同样大小的凹槽中，关好门。 很快他听到“唰”的一声，他猜测这也许是对<br>面的人——也许是个女人——将盒子抽出去的声音。</p><p>　　“你申请BBS服务的目的是什么？”</p><p>　　</p><p>　　喇叭后的女声浸满了纯粹事务性的腔调。</p><p>　　“为了、提高、互联网络、工作效率、为了、缔造、一个、健康、的网络、环<br>境，更好地、为、祖国、做出、贡献。”</p><p>　　阿瓦登一字一句地回答，心里知道这只是一道官方程序，只需要按标准回答就<br>可以。</p><p>　　对面很快就陷入沉默，大约过了十五分钟，喇叭再度响起。</p><p>　　“最后手续确认，你已经获得BBS论坛浏览权。”</p><p>　　“谢谢。”</p><p>　　“砰”的一声，金属盒子从柜子里弹了出来，里面除了阿瓦登的证件以外还多<br>了五张小尺寸光盘。</p><p>　　“这是有关部门核发给你的BBS论坛统一用户名与密码，BBS论坛列表、互联网<br>BBS论坛使用指南及相应法规、以及最新健康网络词汇列表。”</p><p>　　阿瓦登向前踏了一步，从盒子里将这些东西一股脑全拿出来，揣进大衣的大兜<br>里。那些东西其实是可以全部放在同一张光盘里的，不过有关部门认为每一张光盘<br>装一份文件有助于用户理解这些文件的严肃性和重要性，并产生敬畏。</p><p>　　他心里盼望着那个喇叭能再说两句。让他失望的是，对面传来的是一个人起身<br>并且离开的声音，从脚步声的韵律判断，阿瓦登愈发相信这是一名女性。</p><p>　　“手续办理完毕，请离开网络部回到自己的工作岗位上。”</p><p>　　甜美空洞的电子女声从天花板上传来，阿瓦登厌恶地抽动鼻翼，拿手揉了揉，<br>转身离开这间温暖的大厅，重新进入到寒冷的走廊。</p><p>　　在回家的路上，阿瓦登蜷缩在公共汽车上一动不动，顺利申请到BBS的使用权让<br>他有些虚无缥缈的兴奋。他闭着眼睛，找了一个合适的角度躲开破窗而入的寒风，<br>右手在兜里不断摩挲那一系列光盘，还在怀念着那一个神秘的女声。</p><p>　　如果能再一次听到该多好，他不能抑制自己这样的想法，同时用拇指的指肚在<br>光盘上轻轻地摩擦，幻想这几张光盘也曾经被她的手触摸过。他兴奋的几乎也想破<br>口大骂一句“FUXKYOU, YOUSONOFBITCH”，真奇怪，那名男子的骂声在他的记忆里<br>根深蒂固，并时不时不自觉地滑到唇边。</p><p>　　忽然，他的手指在光盘上发觉到一丝异常的感觉。阿瓦登下意识地朝四周望去<br>，确认周围一个乘客也没有后，他小心翼翼地把光盘全拿出来，就着窗外的光亮仔<br>细端详。</p><p>　　阿瓦登很快注意到，在装有BBS论坛列表的光盘背面，被人用指甲轻轻地划了一<br>道刮痕。这条刮痕很轻，如果不是阿瓦登仔细地抚摩光盘的话，是很难发觉到的。<br>这条刮痕很奇特，是一条直线，而在这条直线末端的不远处，则是另外一条极短的<br>刮痕，似乎刻意想弯成一个圆点。整体看上去就好象是一个叹号，或者倒过来说，<br>象是字母i。</p><p>　　很快他在其他四张光盘上也发现了类似的刮痕，它们造型都不同，但都似乎代<br>表着某种符号。阿瓦登回想起喇叭里那个女声最后一句提到过的文件顺序，于是把<br>这五张光盘按照BBS论坛统一用户名与密码、BBS论坛列表、互联网BBS论坛使用指南<br>、相应法规、以及最新健康网络词汇列表的顺序排列好，接着依次把那五道刮痕用<br>手指临摹到汽车窗户上。很快那些刮痕构成了一个英文单词：</p><p>　　title</p><p>　　题目？这是什么意思？</p><p>　　阿瓦登看着这个单词莫名其妙，这究竟是纯属无意的痕迹，还是有人刻意为之<br>？如果是有人刻意为之，他这么做的用意是什么？</p><p>　　这时候汽车停住了，又有几名乘客走上车来。阿瓦登挪动一下身体，不让他们<br>看到自己在车窗上写出来的字迹，然后装做打呵欠的样子抬起袖子，轻轻把那五个<br>字母擦掉。</p><p>　　阿瓦登暗自庆幸，如果他没有在现在发现这些光盘上的痕迹，那么以后就永远<br>没有机会发觉了。按照规定，个人电脑是不允许使用任何存储存设备的，因此阿瓦<br>登的电脑并没有光驱。他下一步所要做的是将这些光盘送交到管区网络安全部，由<br>他们将光盘内资料登陆到服务器中，再转发给阿瓦登。这是为了防止个人私自在家<br>里制造、阅读或者传播黄色或者反动信息，网络安全部发出的通告是这么解释的。<br>联邦的网络警察经常会突入到个人家中进行临时检查，看用户是否非法拥有信息贮<br>存设备，阿瓦登曾经亲眼见过一个邻居被警察带走，原因仅仅是因为他私自藏了一<br>张光盘在家里——其实他只是打算拿那个当茶杯垫用。那个邻居再没回来过。</p><p>　　无论这些符号代表的是什么意思，它都是一种全新的体验，这让阿瓦登感觉到<br>兴奋。怀旧与渴望新奇是阿瓦登生活在这个时代的两根精神支柱，否则他会与这座<br>城市一样变的僵硬，然后窒息而死。</p><p>　　他先来到网络安全分部，将光盘交给那里的负责人，负责人反复地检查光盘和<br>阿瓦登的表情，好象所有使用BBS论坛的人都不可信赖一样。末了负责人终于找不到<br>什么破绽，只得将光盘收下，然后举起右手，阿瓦登和他一起高呼“缔造健康的互<br>联网络”。这句话是唯一被允许可以连贯着被说出来的句子。</p><p>　　回到家里，阿瓦登脱掉大衣，摘了过滤口罩，将旁观者扔到了行军床上，然后<br>整个人也倒进枕头里。每次出去外面都会让他疲劳，这一半是因为他孱弱的肉体已<br>经不大适合室外活动；另外一半原因是因为他必须花费大量的精力来应付旁观者。</p><p>　　过了四十分钟，他才悠悠地醒过来，头还是和平常一样地疼，胸口还是一如既<br>往地闷。胡乱吃了一点东西以后，阿瓦登爬到电脑桌前，打开电脑，按程序登陆上<br>网络，习惯性地先检查了一遍信箱。</p><p>　　信箱里有七、八封新的信件，其中两封是同事发来的事务信。另外五封则是网<br>络安全部发给他的，内容就是他送交的那几张光盘。</p><p>　　阿瓦登打开了包含有BBS论坛的用户名、密码和BBS论坛列表的两封信。他看到<br>自己的论坛通用用户名叫做19842015，和自己的网络编号完全一样，不由得有些失<br>望。他依稀记得在小的时候，BBS论坛的用户名是可以自己决定的，而且每一个论坛<br>都可以不同，一个人在网上并不单只是一串枯燥数字。</p><p>　　小时候的记忆往往是跟童话和幻想混杂在一起，未必与实际相符。现实中你只<br>能使用有关部门指定的用户名和密码，理由很简单，用户名和密码内也可能含有敏<br>感词汇。</p><p>　　阿瓦登又打开了那份BBS列表，全部都是有关部门开设的官方论坛，没有私人的<br>——事实上个人能够合法持有的电脑设备从技术上来说也无法架设新BBS——这些论<br>坛的主题各有侧重点不同，但基本上是围绕着如何更好响应国家号召，缔造健康互<br>联网络来说的。比如其中一个电脑技术论坛，主题就是如何更好地屏蔽掉敏感词汇<br>。</p><p>　　居然在这些论坛中还有一个是关于游戏的。里面正在讨论的是一个如何帮助别<br>人使用健康词汇的网络游戏，玩家可以操纵一名小男孩在街上侦察，看是否有人使<br>用了敏感词汇，小男孩可以选择上前指责或者通知警察，抓到的人越多，小男孩得<br>到的褒奖就越高。</p><p>　　阿瓦登随便打开了几个论坛，里面的人都彬彬有礼，说话很“健康”，就好象<br>街上的那些行人一样。不，准确地说，比街上的气氛还要压抑。在街上的人也许还<br>有机会保留一下自己的小动作，比如阿瓦登刚才在公共汽车上就偷偷地写了TITLE五<br>个字母；而在网上论坛，人的最后的一点隐私也全被暴露出来，有关部门随时可以<br>调看你的一切行动，无从遁形，这就是科学技术发展所带来的进步。</p><p>　　一阵失落和失望袭上阿瓦登的心头，他合上眼睛，把鼠标甩开，重重地向后靠<br>去。原来他天真地以为BBS论坛也许会少许宽松一些，现在看来甚至比现实中更叫人<br>窒息，他感觉到自己好象陷入沉滞的电子淤泥之中，艰于呼吸。“FUXKYOU, YOUSO<br>NOFBITCH”再一次涌现到他的唇边，强烈无比，要化好大的力气才控制住。</p><p>　　忽然，他又想到了那个神秘的title，那究竟是什么意思？那五张光盘里或许隐<br>藏着什么？也许这跟title有关系？</p><p>　　阿瓦登想到这里，把目光重新转向电脑屏幕，仔细去看网络安全部发来的五封<br>信的title部分。五张光盘各隐藏着一个字母，凑到一起就是title，那么按照这个<br>方式，那五封EMAIL的title凑到一起，就变成了一句话：去用户学习论坛。”</p><p>　　阿瓦登记得刚才他确实看到其中一个论坛的名字叫做“用户学习”，于是他抱<br>着姑且一试的心态连接到这个论坛去。他希望这并不是一个巧合。</p><p>　　用户论坛是一个事务性论坛，里面是一些关于BBS用户资料的投诉帖和管理帖，<br>斑竹的是一个叫19387465的人；发帖的人和回帖的人数量都很少，里面冷冷清清的<br>。阿瓦登打开帖子列表，按照刚才的规律去搜寻每一个帖子的标题，并把它们综合<br>到一起，很快他就得到了另外一句话： 　　“每周日辛普森大楼5层B户。”</p><p>　　又是一个谜团，阿瓦登想。但这却坚定了他的信心，这其中必定隐藏着玄机。<br>光盘、EMAIL和BBS论坛，连续三次都可以通过首词组组合的方式得到暗示，绝非巧<br>合。</p><p>　　究竟是什么人会在有关部门的官方文件中隐藏着这样的信息呢？每周日在效率<br>大楼5层B户又会发生什么事情呢？</p><p>　　阿瓦登终于找到了久违的兴奋感，未知事物的新奇刺激着他麻木很久的神经。<br>更重要的是，这种在有关部门正式文件中玩弄的文字技巧，叫他有一种喘息的快感<br>，仿佛一个密不透风的铁面罩上几个透进空气的小孔。</p><p>　　营造健康的互联网络。</p><p>　　FUXKYOU, YOUSONOFBITCH。</p><p>　　阿瓦登盯着屏幕上的桌面背景，用嘴唇比出了那句粗话的口型，并且比出了中<br>指。</p><p>　　在接下来的日子里，阿瓦登一直处于一种潜藏的兴奋状态，就象是一个摆出无<br>辜表情嘴里却藏着糖果的小孩子，在大人转身过去之后露出狡黠的笑容，尽情享受<br>心中藏有秘密的乐趣。</p><p>　　日子一天一天地过去，健康词汇在列表里又少了几个，窗外的空气又浑浊了几<br>分，这已经是生活的常态。阿瓦登自己已经开始拿网络健康词汇表当日历来用，划<br>掉三个词就证明过了三天，划掉七个就证明过了一周，于是周日终于到来了。</p><p>　　阿瓦登抵达辛普森大楼的时间是中午，暗示的句子里并没有指明时间，阿瓦登<br>认为在中午前往应该是比较可以接受的。当穿着深绿军大衣，耳朵上别着旁观者的<br>阿瓦登来到辛普森大楼的入口时，他的心开始忐忑不安地跳跃起来。他在上一星期<br>设想了无数种可能发生的情景，而现在这个谜底就要揭晓了。无论在周日效率大楼<br>会发生什么，也不会比现在的生活更加糟糕，阿瓦登心里想，所以他并不怎么害怕<br>。</p><p>　　他走进大楼内部，发现这里的人也很少，空旷的走廊里只听到他哒哒的脚步声<br>与回音。一部老电梯里贴着“缔造美好网络家园”的广告，以及一个充满了正义感<br>的男性头像海报，背景是星条旗，他在纸里用右手食指指向观看者，头上写着一行<br>字是“公民，请使用健康词汇。”阿瓦登厌恶地转过身去，发现另外一侧也贴着同<br>样的海报，避无可避。</p><p>　　值得庆幸的是五楼很快就到了，电梯的门一开，对面的门上就赫然挂着B户的牌<br>子。门是掉了漆的绿色，门框上还点了几滴墨水，一部简易的电子门铃挂在右上角<br>。</p><p>　　阿瓦登深深吸了一口气，伸手去按电纽。</p><p>　　电铃响起，很快屋子里传来脚步声。阿瓦登觉得这脚步的韵律很熟悉，似乎是<br>在哪里见到过。门“咔拉”一声被打开一半，一名年轻女子一手握着把手，把身体<br>前倾望着阿瓦登，警惕地说：</p><p>　　“你，找谁？”</p><p>　　女子疑惑地问道。阿瓦登一下子就认出了她的声音，就是那个在网络部BBS论坛<br>科柜台后面的女性。她很漂亮，穿着墨绿色绒线衫，头上梳着这时代流行的短发，<br>皮肤特别的白，只有嘴唇能看到一些血色。</p><p>　　看着女子的眼神，一瞬间阿瓦登不知道该说什么好，犹豫了一下，他举起右手<br>，轻声回答说：“title。”</p><p>　　阿瓦登不知道这句话能否奏效，也不知道自己是否真的找对了地方，但这是他<br>唯一能想到的回答了。他紧张地望着那女子，假如那女子忽然报警，那么自己就会<br>被抓起来仔细审问为什么无缘无故跑到陌生人家里。“肆意游走罪”只比“使用敏<br>感词汇罪”轻那么一点。</p><p>　　女子听到他这么说，脸上还是毫无表情，只是把头幅度很轻微地点了一下，右<br>手谨慎地做了一个“进来”的手势。阿瓦登刚要张口，那女子严厉地瞪了他一眼，<br>吓的他把话又吞回去了，乖乖地跟着她进了屋子。</p><p>　　一进屋子，女子首先做的就是把门关好，然后拉起来一层铅灰色的门帘挡在门<br>口。阿瓦登不安地眨着眼睛，趁她拉门帘的时候环顾四周。这屋子是标准的两室一<br>厅，在厅里摆放的是一套双人沙发与一个茶几，茶几上居然还有几束红紫色的塑料<br>花。靠墙是电脑桌和电脑，墙上挂着普通的白色日历， 但被主人用粉红色的纸套了<br>边，看起来颇为温馨。一盏粗笨的日光灯从天花板上垂下来，上面象是恶作剧一样<br>挂了几缕绿色的电线，象是垂下藤蔓的葡萄架。阿瓦登注意到厅口的鞋架上有四双<br>鞋，尺码不同，说明今天的客人并不只他一个。</p><p>　　阿瓦登正踌躇不安，忽然女子从背后拍了拍他的肩膀，示意他朝里面走。于是<br>两个人穿过客厅另一侧的短小回廊来到其中一间卧室。卧室上挂着同样质地的铅灰<br>色帘子，女子伸手举起帘布，推开了门。阿瓦登迈了进去，首先映入眼帘的是三名<br>面带微笑的人类，以及一间用真正的鲜花装点的房间。屋子里有很多旧日记忆里的<br>古老物品，比如一幅印象派的油画、一尊乌干达木雕，甚至还有一个银烛台，唯独<br>没有电脑。</p><p>　　他正在迟疑，女子也进了屋子。她谨慎地拉好门帘关上门，将耳边的旁观者取<br>下，回过身来对阿瓦登用曼妙的声音说道：</p><p>　　“欢迎加入说话会！”</p><p>　　“说话会？”</p><p>　　出于习惯，阿瓦登并没有把这三个字说出口，因为他不确定是否“健康”，只<br>是用眼神表示自己的疑惑。</p><p>　　“在这里你可以随便说话，这个该死的东西不会起作用的。”女子把自己的旁<br>观者晃了晃，那个小东西象死掉了一样，对女子句子里两个敏感词汇“随便”和“<br>该死”充耳不闻。</p><p>　　阿瓦登一下子想到上星期在公共汽车站前碰到的男子，如果他摘下旁观者，会<br>不会也会落到同一境地呢？那女子见他犹豫不决，指了指门口的铅灰色门帘说：“<br>放心好了，这里是可以屏蔽掉旁观者信号的，不会有人觉察到。”</p><p>　　“你们，是什么，人，这，是，哪里？”</p><p>　　阿瓦登一边摘下耳朵上的旁观者，一边小声说道，语调还是改不了那种有关部<br>门规定的说话方式。</p><p>　　“这里是说话会，是一个完全自由场所，在这里你可以畅所欲言，请不要拘束<br>。”</p><p>　　另外一个人起身对他说道，这是一名瘦高的中年男子，鼻梁上的眼镜非常地厚<br>。</p><p>　　阿瓦登嗫嚅着，却找不到发音的焦点，在四个人的注视下显得窘迫不堪，脸都<br>要红起来。女子同情地看了他一眼：“可怜的家伙，不用太紧张，每一个刚到这里<br>的人都是这样。慢慢就习惯了。”</p><p>　　她把手搭到阿瓦登的肩上：“我们其实见过的，当然，我见过你，而你没见过<br>我。”她一边说，一边将自己的头发解下来，原来她留的是一头齐肩的乌黑长发，<br>头发披下来的一瞬间阿瓦登觉得她真的很美。</p><p>　　“我……我记得你，记得你的声音。”阿瓦登终于说出了一句完整的话，虽然<br>不够流畅。</p><p>　　“是吗，那可太好了。”女子笑起来，拉着他的手，让他坐到沙发上，递给他<br>一杯水。阿瓦登注意到这是一个款式古老的茶杯，上面还刻着花纹，杯子里的水带<br>着浓郁的香气，阿瓦登尝了一点，那种甜丝丝的味道对喝惯纯净水的舌头来说刺激<br>格外地大。让他觉得浑身一下子被注进了许多活力。</p><p>　　“弄到这个可不容易，我们也不是每周都能喝到。”女子坐到他身边，两只乌<br>黑的眼睛注视着他，“你是怎么知道这个集会的？”</p><p>　　阿瓦登把发现光盘暗示的过程说了一遍，其他四个人都赞许地点了点头。“果<br>然是个聪明人，脑筋还没被陈腐的空气腐蚀掉。”一个三十多岁的胖子称赞道，他<br>的嗓门大的要命。那个戴眼镜的中年人把两只手交叉在一起，表示赞同。</p><p>　　“这正是天生的说话会成员，聪明、敏锐，而且不甘屈从于沉默。”</p><p>　　“那么。”胖子提议，“先让我们鼓掌欢迎说话会的新成员吧。”</p><p>　　于是四个人鼓起掌来，小小的屋子里响起一片掌声。阿瓦登羞涩地举起杯子做<br>回应，他还不太习惯这样的场面。等到掌声稍息，他抬起头怯生生地问道：</p><p>　　“可以问个问题吗？说话会到底是什么？”</p><p>　　带他进屋的女子伸出食指，在他鼻子前两公分的地方比了一比，解释道：</p><p>　　“说话会，就是可以畅所欲言的集会。在这里你不必顾忌什么，说出任何你想<br>说的东西。这里没有敏感词汇，也没有健康互联网络。这里是绝对自由的空间，你<br>可以尽情释放你的灵魂，舒展你的身体，没有任何禁锢与束缚。”说着说着，她的<br>声音变的高亢、奔放，里面饱含了许多早已经被屏蔽掉的词汇，阿瓦登不曾听到这<br>样流畅连贯的话语很久了。</p><p>　　“我们的宗旨就是，说话，就这么简单。”中年人扶扶眼镜，补充道。</p><p>　　“可是，要说些什么呢？”阿瓦登又问道。</p><p>　　“任何事情，你心里想的任何事情都可以说出来。”中年人露出宽和的笑容，<br>“尤其是那些被美国政府限制的思想。”</p><p>　　这可真是一个大胆的集会啊，这分明就是犯罪，阿瓦登心想，但他发觉自己却<br>被这种犯罪慢慢地吸引住了。</p><p>　　</p><p>　　“当然，有件事我们会事先说明。说话会是危险的，每一个成员都冒着被有关<br>部门拘捕的风险。联邦执法人员也随时可能破门而入，以非法集会以及非法使用不<br>合法词语的名义把我们抓起来。你现在有权拒绝加入，并且离开。”</p><p>　　阿瓦登听到女子的警告，心里一度犹豫起来。但一想到此刻离去的话，那么又<br>要开始持续那种窒息的泥沼生活，他就难以压抑自己的烦闷。阿瓦登第一次发现，<br>原来“说话”对他来说是一个致命的诱惑，他先前并不知道自己原来是如此地渴望<br>着说话。</p><p>　　“我不会离开的，我要加入你们，说话。”</p><p>　　“那太好了。唔，那么不妨就从自我介绍开始吧。”女子高兴地说，同时站起<br>身来，把右手搭到胸前，“从我开始。我的名字叫阿尔特弥斯，至于网络编号和身<br>份证号码，让他们见鬼去吧！谁会去管那个！我有我自己的名字，我不是数字。”</p><p>　　她的话让所有人包括阿瓦登都笑了起来。接着她继续说道：“不过，这其实只<br>是一个假名，这是希腊神话里的女神。”</p><p>　　“假名？”</p><p>　　“是的，和我户籍本上的名字是不同的。”</p><p>　　“可是，为什么？”</p><p>　　“你不会对自己在档案里的名字厌倦吗？我想起一个自己喜欢的名字，哪怕只<br>有一次机会也好，自己想叫什么就叫什么。在这个说话会里的每一个人都有一个自<br>己喜欢的名字，我们彼此拿这个称呼。”</p><p>　　阿瓦登若有所思地点点头，他很理解阿尔特弥斯的想法。事实上当他在使用网<br>络论坛的时候，也希望能够自己取一个称心如意的名字，而不是被分配一个用户名<br>。</p><p>　　通过介绍，阿瓦登了解到阿尔特弥斯是网络部BBS论坛管理科的职员，今年23岁<br>，未婚，最讨厌蟑螂和蜘蛛，喜欢缝纫与园艺，屋子里的花就是她偷偷从城市边缘<br>摘回来的。</p><p>　　接下来是那名中年人，他自我介绍说名字叫兰斯洛特，41岁，是城市电厂的一<br>名工程师；兰斯洛特这名字出自英国的亚瑟王传说，是一名忠贞的骑士。他有自己<br>的老婆和两个孩子，一男一女；男孩三岁，女孩四岁，他们最喜欢吃的就是柠檬味<br>道的水果糖。说到这里，兰斯洛特说希望下次聚会能把他们也带了，孩子们正是学<br>说话的时候，他想教给他们真正的说话。</p><p>　　那个三十多岁的胖子是网络部的一名网管，叫瓦格纳。这个身份让阿瓦登吃惊<br>不已，他的印象里网管都是些绷着脸全无表情的冷漠生物，但眼前的瓦格纳脸圆滚<br>滚的，油光锃亮，嘴边两条翘起的小胡子神气十足。他喜欢的是雪茄和歌剧，利用<br>网管的特权这两样东西都不难弄到。</p><p>　　“这个能屏蔽掉信号的门帘就是他弄的。”阿尔特弥斯补充说，瓦格纳冲她做<br>了个“乐意为您效劳”的手势，然后点燃了雪茄，把它放到嘴里，很快屋子里就笼<br>罩起一片稀薄的烟雾。</p><p>　　说话会的第四名成员是一位穿着黑色制服的女性，今年刚满三十。她的名字是<br>杜拉丝，城市日报（那个时代的报纸已经全部都数字化了）的编辑，她比阿尔特弥<br>斯还瘦，颧骨高高耸起，眼窝身陷，两片薄薄的嘴唇即使在最说话的时候也很少分<br>开，看不到牙齿。爱好是饲养狗和猫，尽管她并没有养。</p><p>　　“那么，到你了。”阿尔特弥斯对阿瓦登说。阿瓦登想了想，结结巴巴地把自<br>己的情况说了一遍，当谈到自己的爱好时候，他一时间居然想不到自己喜好什么，<br>似乎什么都没有，在那之前他甚至从来没想过。</p><p>　　“那，你最想做的是什么事呢？”阿尔特弥斯把手再一次放在他肩上，诱导着<br>问道。</p><p>　　“真的什么都可以？”</p><p>　　“什么都可以，在这里没有任何限制。”</p><p>　　阿瓦登觉得自己终于找到机会了，他咳了一声，抓抓头，脱口而出一句响亮的<br>叫喊：“FUXKYOU, YOUSONOFBITCH！”</p><p>　　在一瞬间，在座的四个人都被他这句话震惊了。瓦格纳率先反应了过来，他先<br>叼住雪茄，用力鼓掌，然后用右手把雪茄取下来，张嘴大声地赞叹道：“真棒，痛<br>快，这简直是最完美的入会誓词。”</p><p>　　“我宁可听十遍这样的脏话，也不想再去碰那个乏味的电子女声。”兰斯洛特<br>也是一脸陶醉，毫不掩饰自己对电子女声的厌恶。而阿尔特弥斯和杜拉丝全都咯咯<br>地笑起来，杜拉丝发现自己的笑容幅度大了一点，不好意思地把嘴掩住。阿瓦登觉<br>得他们与其说是觉得新奇，不如说是在享受这句脏话所带来的对体制的蔑视与挑战<br>。</p><p>　　“那你叫希望自己叫什么名字呢？” 阿尔特弥斯歪着头问。</p><p>　　“唔……王二。“ 阿瓦登沉吟了一下，回答说。这是一个中式的名字，他以前<br>有一个中国人朋友，喜欢讲故事，故事里的主角名字总是叫王二。</p><p>　　屋子里的气氛现在完全融洽了，大家都开始谈些比较自然的话题，每个人都摆<br>出了最舒服的姿势，阿尔特弥斯不时拿起茶壶来为大家续水。阿瓦登紧张的心情逐<br>渐放松下来，他感觉到自己的脑子前所未有地轻松。</p><p>　　“你知道的。”阿尔特弥斯又给他倒了一杯甜水，“我们一直想把说话会保持<br>在一定规模，平日是没有办法畅所欲言的，我们需要空间。麻烦的是，我们没办法<br>公开征集会员，又不可能直接通过物理接触去寻找，那风险太大。于是兰斯洛特就<br>设计了一套暗示系统，只有发现这些暗示的人才能知道本会的存在。”</p><p>　　“这套系统考虑到的还不止是安全问题。”兰斯洛特把自己的眼镜摘下来仔细<br>擦拭了一下，得意地说，“这其实也是一个会员资格验证。说话会所吸纳的成员，<br>必须有智慧，有头脑，内心渴望激情，并且对自由有着渴望。”</p><p>　　瓦格纳用两根指头夹着雪茄，在事先准备好的烟灰缸里弹了弹烟灰，大声说道<br>：“据我的经验，申请BBS论坛服务的人，大多数都是为了怀旧，或者说渴望一些新<br>鲜的东西，这样的人往往都怀有激情，认为BBS论坛也许能给他们一些与现实不一样<br>的东西——当然，事实上并非如此，美国政府对BBS论坛的管理甚至严厉过电子邮件<br>——这暗示着他们心里渴望解脱束缚。因此我们将暗示隐藏在申请BBS论坛的光盘之<br>中，只有申请人才有机会接触到这些暗示。而只有那些有智慧、观察敏锐的人才会<br>发觉到这些暗示的存在，并顺利解读出来，找到这里。”</p><p>　　“归根到底，说话会也不过是一群渴望自由说话的秘密小团体罢了。”兰斯洛<br>特笑道。</p><p>　　“你是第二个找到说话会的人，第一个是杜拉丝小姐。”</p><p>　　阿尔特弥斯告诉阿瓦登。阿瓦登敬佩地看了杜拉丝一眼，后者淡淡地回答道：<br>“这没什么，这是我的工作，我的工作就是摆弄文字。”</p><p>　　阿瓦登想到上一周在公共汽车站碰到的那个疯狂男子，于是把这件事讲给其他<br>成员听。听完之后，兰斯洛特摇了摇头，从嘴唇里滑出一声叹息：</p><p>“这样的事情我也是见过的，我的一个同事就是如此。所以说话会的存在是必要的<br>，这是缓解压力的阀门。长时间的敏感词汇限制会让人都疯掉的，因为他们既无法<br>思考又没办法表达。”</p><p>“这正是美国政府有关部门所希望看到的，这样只有傻瓜能够存活下来，一个全是<br>傻瓜的社会是稳定的。” 瓦格纳费力地把自己肥胖的身躯挪了一下位置，轻蔑地说<br>。</p><p>“你也是有关部门的一分子，瓦格纳先生。”阿尔特弥斯一边往茶杯里续了些热水<br>，一边抬头轻声说道。</p><p>“阿尔特弥斯小姐，我只是一个能比普通人多使用几个敏感词汇的普通人而已。”</p><p>　　大家都笑了起来。阿瓦登从来没有见过这么多的人说这么多的话，这是前所未<br>有的奇妙经验。他惊讶地发现自己居然很快就融进了这个小圈子里，隔阂与陌生感<br>很快就消失了；同时消失的还有胸闷与头晕等习惯性的毛病。</p><p>　　很快话题就从说话会本身扩展到了更加宽泛随意的话题，阿尔特弥斯唱支歌，<br>兰斯洛特说了几个笑话，杜拉丝则给大家讲了美国南部诸州的风土人情；瓦格纳甚<br>至还唱了一段歌剧，虽然阿瓦登一个字也听不懂，但他一点也不吝惜掌声。在这个<br>城市的某一个被屏蔽掉的角落里，五个不甘沉默的人正在享受着在这个时代视为奢<br>侈品的事情——说话。</p><p>　　“王二，你可曾看过《1984》？”</p><p>　　阿尔特弥斯忽然问道，她就靠着阿瓦登坐下，阿瓦登摇摇头，反问道：“这是<br>网络编号的一段么？”</p><p>　　“这是一本书的名字。”</p><p>　　“书？”阿瓦登听到这个名词，头摇的更大了。这是个古老的名词，在这个电<br>脑技术非常发达的时代，网络可以承载一切信息，任何人都可以在网上图书馆查到<br>电子版；因此有关部门认为实体书籍变成了一种没有必要存在的浪费，实体书也就<br>逐渐消亡了。瓦格纳对此的评论是：“有关部门喜欢电子书籍的心情是可以理解的<br>，电子书籍的话，只需要FIND和REPLACE两个命令就可以消灭掉全部不健康词汇，替<br>一本书消毒；而实体书籍的校对与修订却是件旷日持久的工作。”</p><p>　　“这是一本伟大的书，是旧世界哲人们对我们这个时代的预言。”阿尔特弥斯<br>认真地说。“它很早以前就洞察到了肉的束缚与解脱，灵的束缚与解脱，这是说话<br>会的基石。”</p><p>　　阿瓦登不无惊奇地发现他的网络编号开头恰好是这这本书名字：19842015。</p><p>　　“那么，该怎么样才能看到呢？”阿瓦登盯着阿尔特弥斯乌黑色的眼睛问。</p><p>　　“我们也无法找到纸质版，网络图书馆不可能存在这样的书。”兰斯洛特摇摇<br>头，然后重新露出笑容，左手向着杜拉丝摆了个请的姿势，“但我们的杜拉丝小姐<br>应该为她的记忆力而自豪，她在很早已经有幸阅读过这两本书，并且能够记得里面<br>的大部分文字。”</p><p>　　“太好了，然后她写下来了，对吗？”</p><p>　　“那太危险，这时代持有实体书是个大罪过，也容易让说话会暴露。我们只是<br>在每次聚会的时候请杜拉丝小姐为我们背诵。既然是说话会，那么把这两个故事讲<br>出来不是更名符其实吗？”</p><p>　　大家都安静下来，杜拉丝站起来走到屋子中央，其他四个人坐在旁边看着她。<br>阿瓦登不经意地把手搂在阿尔特弥斯肩上，后者微微朝这边靠过来，女性头发的幽<br>香“咝咝”地划过他的鼻子，让他的心里一阵荡漾。屋子里非常暖和，他分不清这<br>是花香还是阿尔特弥斯的味道。</p><p>　　杜拉丝的声音并不高，不过却很清晰有力；她的记忆力确实惊人，不仅记得情<br>节，包括一些细节和句子都可以复述下来。杜拉丝讲到了朱丽亚假装摔倒，然后偷<br>偷递给温斯顿一张写着“我爱你”的纸条，绘声绘色，这让听众们都听的入神了，<br>阿尔特弥斯听的尤其认真，以至于都没有注意到阿瓦登一直注视着她。</p><p>　　“1984的作者预见到了专制的进步，却没有预见到技术的进步。”瓦格纳在杜<br>拉丝停下来喝水的时候发表自己的评论，阿瓦登觉得他与外貌不太相称，是个很有<br>洞察力的技术官僚。</p><p>　　“在大洋国人们还可以靠传递纸条来偷偷表达自己的想法，但是现在不一样了<br>。美国政府有关部门把我们全赶到了网上，而在网络技术发达的今天，我们即使想<br>发一条短信都会被系统或者网管看的一清二楚，无从遁形。现实里呢，还有旁观者<br>在。”瓦格纳在腿上敲了敲雪茄根部，“一句话，技术是中性的，但技术的进步会<br>让自在的世界更自在，集权的世界更加集权。”</p><p>　　“这句话说的很有哲学家的味道哟。”阿尔特弥斯冲瓦格纳挤了挤眼睛，从抽<br>屉里取来一把饼干和曲奇散发给大家。</p><p>　　“就好象同样是0和1，有的人就能写出工具软件，有人却拿那个编出恶性病毒<br>？”</p><p>　　阿瓦登想到一个类似的比喻，瓦格纳听了以后满意地打了个响指。</p><p>　　“很不错的比喻，王二，就是如此，真不愧是程序员。”</p><p>　　谈话持续了不知道有多久，杜拉斯看了一眼墙壁上的挂钟，连忙提醒谈兴正浓<br>的四个人时间快到了。说话会不能持续很长时间，旁听者被屏蔽的越久，暴露的危<br>险就越大。</p><p>　　“那么好吧，我们就抓紧最后半个小时来完成今天的活动。”</p><p>　　阿尔特弥斯一边说着，一边将桌子上的空杯子收走。兰斯洛特和瓦格纳也都站<br>起身来，活动一下已经有些酸疼的肩膀和腰，只有杜拉丝坐在位子上没有动。</p><p>　　“活动？还有什么活动？”</p><p>　　阿瓦登奇怪地问道，说话会除了说话还有其他活动？</p><p>　　“唔，对啊，我们还有其他活动。”阿尔特弥斯撩起额前的长发，对他妩媚一<br>笑：“我们还会和对方完全交流。”</p><p>　　“完全交流？”</p><p>　　“就是intercourse”</p><p>　　“………………”阿瓦登一下子变的脸色苍白，呼吸急促起来，仿佛胃里被灌<br>进去零下三十度的寒风，他几乎不相信自己的耳朵。</p><p>　　“说话会有说话的自由，也有选择与谁上床的自由。”阿尔特弥斯毫不羞涩地<br>说，“我们互相谈话，然后选择合适的人做爱，就象我们选择我们喜欢的词汇说话<br>一样。”</p><p>　　兰斯洛特看阿瓦登很窘迫，走过去拍拍他的肩膀，慢慢地说：“当然，我们不<br>会强迫任何人，这完全是在自愿的基础上。今天我还要早点回去照顾小孩，你们人<br>数正好合适。”</p><p>　　阿瓦登的脸色涨红，热的仿佛夏季的电脑CPU，他甚至不敢多看阿尔特弥斯一眼<br>。他憧憬过女性很长时间，但如此接近还是第一次。</p><p>　　还要回家去照顾小孩子的兰斯洛特向大家道别后就先行离去了，阿尔特弥斯将<br>房间留给瓦格纳与杜拉丝，然后带着惶恐不安的阿瓦登来到了另外一间房间。这间<br>显然是阿尔特弥斯的卧室，屋子里很简单，但却收拾的十分干净，在床上枕头旁还<br>摆着一个手制的布娃娃，床单和窗帘都是粉红色的。</p><p>　　最初的是由阿尔特弥斯主动开始的，丝毫没心理准备的阿瓦登只是被动地任她<br>摆布。经过了几轮挑逗，阿瓦登才逐渐放开，任由潜藏在自己心内的原始欲望奔流<br>出来，那种期待听到圆润女声的青春憧憬本来只是苦闷生活的意淫，而在今天它加<br>倍实现了。很快这种憧憬与他在现实中被压抑的郁闷合流，转化成了猛烈的冲动，<br>让他一次又一次与阿尔特弥斯融为一体。阿瓦登不知道这种冲动和他想大声说出“<br>FUXKYOU, YOUSONOFBITCH”冲动有什么不同，不过现在不是考虑这个的时候，他现<br>在脑子里想的只有尽情地、全无束缚地让自己释放激情，完全没有任何束缚。</p><p>　　强烈的刺激一波波地冲击着兴奋中枢，最终一阵快感浪潮在狂暴洋面扬起头来<br>，达到了一个极高的顶端。阿瓦登在那一瞬间感觉到了前所未有的自由，那种轻盈<br>无比的自由，以及因自由而生的快乐与疲惫。浑身是汗的他喘息着倒在了阿尔特弥<br>斯身上，一阵舒畅的倦意如潮水般淹没了他的身体……</p><p>　　……当他醒来的时候，发现阿尔特弥斯躺在自己身边，赤裸的身体好象一尊白<br>玉雕像，睡姿恬美静谧。他侧过身子去，慵懒地打了个呵欠，然后阿尔特弥斯睁开<br>了眼睛。</p><p>　　“很舒服，对不对？”她问道。</p><p>　　“是啊……”阿瓦登不知道该说什么好，他顿了顿，犹豫地说道：“你以前和<br>兰斯洛特、瓦格纳他们也……呃，我是说，象刚才那样子过吗？”</p><p>　　“是的。”阿尔特弥斯温柔地回答，她半支起胳膊，长发从肩膀披到了胸口。<br>她的大方坦白反而让阿瓦登有些不知所措。屋子里出现了一段时间的沉默，然后阿<br>尔特弥斯忽然开口问道：</p><p>　　“还记得今天杜拉丝讲的那段故事吗？女主角偷偷递给男主角写着“我爱你”<br>的纸条。”</p><p>　　“唔，还记得。”阿瓦登回答，很高兴终于能从那个拙劣的话题摆脱出来了。</p><p>　　“在有关部门的健康互联网络词汇列表里，没有爱这个字呢。在我们这个时代<br>，我爱你也是一个敏感词汇，被屏蔽掉了。”阿尔特弥斯的眼神里似乎是感慨，又<br>象是失落。</p><p>　　“我爱你。”阿瓦登不禁脱口而出，他知道在这间屋子里可以说出任何自己想<br>说的话，不必顾忌。</p><p>　　“谢谢你。”</p><p>　　阿尔特弥斯听到之后只是笑了笑，起身穿上衣服，催促阿瓦登时间差不多了。<br>阿瓦登有些失望，因为她没有预期反应的热烈，仿佛他刚才说的只是有些无关紧要<br>的东西。</p><p>　　这时候杜拉丝和瓦格纳已经离开了，屋子里只剩他们两个人。阿尔特弥斯把他<br>送到门口，将旁观者交给他，然后叮嘱他说：“记得在外面绝对不要提及说话会的<br>任何事情或者任何人，我们在说话会以外的地方是完全不认识的。”</p><p>　　“我记住了。”阿瓦登回答，然后转身要走。</p><p>　　“王二。”</p><p>　　阿尔特弥斯忽然叫道，阿瓦登连忙转身，还没等他反应过来，两片柔软温暖的<br>嘴唇忽然贴到了他的双唇，然后是一个细切的声音在耳边响起：“谢谢你，我爱你<br>。”</p><p>　　阿瓦登觉得眼睛有些湿润，他戴上旁观者，推开门，重新步入到那一片令人窒<br>息的世界中去，但他此时已与来时的心境大不相同。</p><p>　　此后阿瓦登的精神面貌明显有了改善。他谨慎地享受着这种秘密集会的乐趣，<br>并且乐在其中。每一周或者两周，他们五个人都会在周日秘密地举行说话会的活动<br>，聊天，唱歌或者听杜拉丝讲1984的故事。阿瓦登同阿尔特弥斯又“完全交流”了<br>几次，偶尔他也会跟杜拉丝“交流”。他有了两个身份，一个是现实中和网上的阿<br>瓦登，编号19842015，还有一个是说话会里的王二。他很享受这个名字，觉得这就<br>是自己另外的一个人生。</p><p>　　有一次集会，他们谈到了敏感词汇的问题。阿瓦登记得很早的时候——他对这<br>方面的记忆有点模糊——有关部门给出的是一份敏感词汇列表，由网站的内部管理<br>人员秘密参考使用，他对如何演变成现在的局面大惑不解。那一天瓦格纳带了一瓶<br>葡萄酒，兴致很高，于是索性给他们讲了讲“屏蔽”的进化史，身为网管的他经常<br>可以接触到这些资料。</p><p>　　在最开始美国政府只是单纯地屏蔽掉敏感词汇，但很快他们就发现这样的措施<br>根本没有用处。很多人会采取在词组中夹杂符号或者数字的方式来绕开系统检查；<br>于是有关部门不得不将这些近似敏感词汇也一一屏蔽掉。然而众所周知，数字与符<br>号之间的组合方式是近乎无限的，只要你有想象力，就完全可以组合出一个新的词<br>组而且不失掉他的原意。比如说“politic”这个词，就有“politi/c”、“政pol<br>it/ic”、“pol/itic”等近乎无限种表达方式。</p><p>　　当有关部门意识到这个问题时，他们采取了新的策略。既然无法辨识词组，那<br>么就用单词屏蔽。这一举措在一开始是奏效的，违规交谈的人显著减少，但很快人<br>们就发现可以用同音字或者谐音的方式来继续表达自己的危险思想。即使有关部门<br>封掉全部敏感词汇的同音字，也无济于事，思想活跃的美国人充分发挥了自己的想<br>象力，使用隐喻，借代、类比、引申及其他修辞方法，或者将一个敏感词用数个不<br>敏感的字来代替。人类的思维方式要比电脑开阔许多。电脑屏蔽掉一条路，他们还<br>会有更多的路可以选择。</p><p>　　这一场水面以下的角力看起来似乎是美国大众要取得胜利。这时候，一个具有<br>逆向思维精神的人出现了。他的身份不明。有人说他是有关部门的主管；也有人说<br>他是因过度使用敏感词汇而被捕的危险人士。无论他是谁，总之整个局面被扭转过<br>来。他向有关部门建议，不再告诉大众禁止说什么，而是规定他们只能说什么，用<br>什么方式去说。有关部门很快就心领神会，制订了新的规章制度：取消了敏感词汇<br>列表，取而代之的是互联网络健康语言列表，并把这举措推广到了日常生活中的语<br>言屏蔽系统中去。</p><p>　　这一次，大众终于处于下风。以往他们与有关部门尽情地在网络与现实中捉着<br>迷藏，而现在他们却被有关部门扼住了咽喉。这样一来，有关部门可以有效率地掌<br>握住言论，因为整个语言的框架都被彻底控制了。在有限的空间内，大众几乎是无<br>计可施。</p><p>　　尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他<br>们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思<br>就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一<br>动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使<br>用。</p><p>　　“当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组<br>，那么就可以继续自由交流——你知道莫尔斯电码吧？”</p><p>　　瓦格纳说到这里，拿起茶杯一饮而尽，满意地打了一个嗝。</p><p>　　“可是，这场战争的代价就是语言的失落。表达能力会越来越贫乏，越来越淡<br>而无味，人们会越来越倾向于沉默，这对有关部门反而是好事。”兰斯洛特摆出一<br>副忧虑的表情，有节奏地用指关节敲击着桌面，“这样一来，岂不就等于是大众的<br>自由意识将语言推向死亡的边缘？真讽刺啊。按照这个趋势，有关部门是不会败的<br>，他们会笑到最后。”</p><p>　　“不，不，笑这种情感他们是不会了解的。”瓦格纳淡淡地回答。</p><p>　　“我倒是觉得，美国是一直处于恐惧的情感之中呢，生怕人们掌握了太多的词<br>汇，表达出太多的思想，变的难以掌握。”阿尔特弥斯说完摆出一副她在上班期间<br>冷若冰霜的呆板脸孔，学着僵硬的腔调喊了一句：“营造健康的网络环境，美国万<br>岁！”</p><p>　　杜拉丝、兰斯洛特与瓦格纳都哈哈大笑，唯一没笑的是王二（阿瓦登）。他对<br>于兰斯洛特刚才的那句话始终耿耿于怀：大众与有关部门的对抗，其最终结局就是<br>语言的消亡。那么他们现在这个小小的说话会，也只不过是在一列开向悬崖的列车<br>里关上窗帘，享受坠毁前最后的宁静罢了。</p><p>　　不过他没有说出口，因为这太煞风景了。阿瓦登不希望破坏说话会的气氛，这<br>对他很重要。</p><p>　　从说话会回到家里，阿瓦登躺在行军床上，双手枕着脑袋，陷入了沉思。自从<br>加入说话会以后，他变的比以前更容易陷入思考。有时候他想的是这个社会、这个<br>互联网络或者这座城市中存在的荒谬性；有时候他想的是自己的生活；还有时候他<br>想的是阿尔特弥斯。他不知道是不是在一个压抑的世界里，人的情感会变的格外强<br>烈，他现在陷入对阿尔特弥斯的迷恋无法自拔。阿瓦登一直很羡慕杜拉丝讲的《19<br>84》里面的温斯顿，他和朱利亚有一间两个人独处的小屋，一个只属于他们两个人<br>的小世界。</p><p>　　他在与阿尔特弥斯“完全交流”的时候曾经吐露过自己的心声，阿尔特弥斯没<br>有直接回答，而是表示两个人的关系无法再比说话会更近一步——维持现在的状态<br>就已经是个人行为的极限，有关部门可不会一直打瞌睡。“我们只能把感情生活压<br>缩在每周一次的说话会活动里，这已经很奢侈了。”她对他说，同时温柔地抚摩他<br>的胸膛。“只有在说话会里，我们才是阿尔特弥斯和王二。而在其他时间里，你是<br>19842015，而我是19387465。”</p><p>　　对此，阿瓦登只能发出一声轻轻的叹息，确实他不该奢求更多。</p><p>　　除了感情，发生变化的还有互联网络。自从加入说话会以后，阿瓦登逐渐发现<br>互联网表面下潜藏的一些东西。正如瓦格纳在一次活动的时候指出，普罗大众与有<br>关部门的战争从未结束，总会有思想和言论从严厉管制的缝隙中流泻出来。阿瓦登<br>发现，在完全公式化的EMAIL与网络论坛中其实隐藏着不少耐人寻味的细节，就好象<br>那个title一样，存在着各式各样的密码与隐藏寓意。这些东西出自不同人的手里，<br>样式和破译方式都不同，阿瓦登不知道那些密码背后隐藏的是怎样的内容。不过有<br>一点可以确知的是，说话会并不是唯一的一个地下集会，瓦格纳说的对，始终还是<br>有人在试图用“健康”词汇表达“不健康”思想。</p><p>　　讽刺的是，给阿瓦登感触最深的，是有关部门的管制。以往他只是模糊地感觉<br>到自己被绑缚起来，现在他能清晰地看清这种束缚与压抑的脉络，以及加诸在自己<br>身上的各种手段。在小小说话会中享受到的自在让他更加深刻地感受到在宽阔现实<br>中的不自在。</p><p>　　“FUXKYOU, YOUSONOFBITCH！”</p><p>　　每一次的聚会，三位男士都会轻蔑地一起高喊这一句粗话。他们清楚这不会给<br>有关部门带来什么不良影响，不过这确实很痛快。</p><p>　　这一周，阿瓦登特别地忙碌，他的同事因为不明原因而被屏蔽掉了，这样一来<br>整个项目就全压在了他一个人身上。这项目是为有关部分设计一种软件，用来控制<br>大功率主动式“旁观者”的能源分配控制。软件很复杂，他不得不每天在电脑前工<br>作十几个小时，只有在身体实在支撑不住的时候才停下来随便吃一点东西，喝一口<br>纯净水，困了就躺在旁边的行军床上睡上一觉，爬起来继续工作。屋子里满是浑浊<br>的烟味与袜子脏衣服的酸臭味，阿瓦登就在这种环境下蓬头垢面地敲着键盘，并不<br>时揉揉满布血丝的眼睛。</p><p>　　偏偏在这个时候屋子里的暖气坏掉了。洋灰色的暖气片从昨天开始就变的冰凉<br>，不再有热水流动。阿瓦登检查了一下，发现并不是管道问题，而且邻居们也碰到<br>同样的事，看来是供热系统出了问题。这一变故的正面影响是稍微淡化了屋子内的<br>酸臭味，负面影响是整个屋子变的有如冰窖一样。紧闭的窗户和门能挡住寒风，却<br>挡不住寒冷，低温让本来就寒酸的房间更笼罩上一层霜气。无论是那把木椅还是行<br>军床都象是冷酷的冰雕，屋子里唯一还有些热气的就只剩下电脑。阿瓦登不得不披<br>上所有的御寒衣物，蜷缩在床上，把电脑的散热口对准自己。</p><p>　　有关部门宣布“供热”和“暖气”暂时也被列入敏感词汇，于是阿瓦登没办法<br>写信向供热部门询问，只好静待，除了用来敲键盘的指头以外，尽量保持全身一动<br>不动，以节约热量。在停止供暖后的第四天，暖气片里终于传来“哗啦哗啦”的声<br>音，带着热气的水开始流动，屋子里恢复了温暖，“供热”和“暖气”又可以恢复<br>使用了。于是EMAIL与网络论坛上全都是“庆祝有关部门恢复供应暖气，急人民之所<br>急”的帖子，EMAIL新闻组里也全是类似主题。</p><p>　　不过这对阿瓦登来说太晚了，他生了病，感冒，而且是重感冒。他面色苍白，<br>全身软弱无力，头疼的象是被一枚达姆弹射入头部，只能躺在床上等医生。医生来<br>到他家里，给他做了两三次点滴，喂了一些叫不上名字的药片，叫他静养。这一场<br>病足足持续了数天，他不得不放弃参加这一星期的说话会，身体状况实在太差了，<br>阿瓦登甚至怀疑自己搞不好会因此而死掉。</p><p>　　阿瓦登躺在床上，心里懊悔不已，说话会是他唯一的乐趣，现在他却没办法参<br>加。他把头蒙在被子里胡思乱想，瓦格纳这一次会带什么特别的东西来呢？兰斯洛<br>特有没有把两个孩子也领过来？还有阿尔特弥斯，他没参加的话，她会和谁“完全<br>交流”呢？瓦格纳还是兰斯洛特？他还想到了杜拉丝，上一次的聚会里，杜拉丝讲<br>到了温斯顿在秘密幽会的屋子里对朱丽亚说“我们已经死了”，朱丽亚附和着说“<br>我们已经死了”，这时候第三个声音说道“你们已经死了。”</p><p>　　杜拉丝就讲到这里，就停住了。阿瓦登急切地想知道接下来发生了什么，第三<br>个声音是谁，是党吗？温斯顿和朱丽亚是否会被捕，他们会有什么样的下场？不光<br>是他，阿尔特弥斯也很希望知道后续情节的发展，不过她并没有去追问杜拉丝。</p><p>　　“让这成为一个悬疑，这样接下来的一周我们的生活都会在期待的乐趣中度过<br>。”她对阿瓦登说，然后两个人继续沉溺于intercourse的快乐。</p><p>　　“也许他们都会死。”阿尔特弥斯在交流结束后，看着天花板说。</p><p>　　“也许那只是奥布林的声音，他去探望他们。”阿瓦登安慰她道，但是他的心<br>里也不确定。</p><p>　　阿瓦登的病持续了十天，然后他终于痊愈了。他痊愈后的第一件事就是从床上<br>爬起来，然后去看墙上的日历：这一天恰好是星期日，说话会活动的日子。阿瓦登<br>已经缺席了一周，这已经令他如饥似渴，甚至做梦都在和他们一起喋喋不休地说着<br>话——所幸他并没有说梦话的习惯，所以24小时工作的旁观者并没发出任何警报。</p><p>　　阿瓦登简单地洗了一下脸，用一把有些生锈的剃刀沾着肥皂仔细地刮掉脸上粗<br>硬的胡须，然后咕噜咕噜地刷了刷牙齿，用手和毛巾沾着热水将自己蓬起的乱发压<br>下去。因为生病，有关部门发了一些补贴给他，其中包括两块羊角面包、两瓶姜汁<br>啤酒和一份精制砂糖。他将这些东西都用塑料布仔细包好，揣到宽大的军大衣里，<br>打算带到说话会上去与大家分享。</p><p>　　今天的天气和往常一样地冷，阿瓦登把自己裹在大衣里，登上前往效率大楼的<br>公共汽车。一路上车厢里的广播重复着“营造健康的互联网络”以及一些优秀网络<br>用户的先进事迹；车厢前面的电子屏幕不断滚动显示着最新的健康词汇列表，一个<br>旁观者自车顶垂下来睥睨着车内的每一个表情呆滞的人。阿瓦登坐在最后一排，望<br>着窗外不断向后移动的建筑物与枯黄的树木发呆。</p><p>　　车子很快就到达了辛普森大楼附近的车站，阿瓦登下了车，把手放到怀里摸了<br>摸塑料布包着的食物，朝着大楼走去。他在半路无意中抬起头，忽然一阵冰冷的寒<br>流刺入他的胸腔，迫使他停住了脚步。</p><p>　　有什么地方不对劲！</p><p>　　他看到了效率大楼的第五层阿尔特弥斯家的窗户发生了一些奇怪的变化。以前阿尔特弥斯家面向大街的窗户总是挂着粉红色的窗帘，而现在窗帘则被扯到了两边<br>，窗户大开，用肉眼可以勉强看到窗玻璃和屋子里雪白的墙壁。假如今天有说话会<br>的话，阿尔特弥斯绝对不会把有屏蔽效果的窗帘打开。而且打开窗户这件事也绝不<br>寻常，在这个城市里的室外空气十分浑浊，几乎不会有人会去开窗换气。</p><p>　　也就是说，今天并没有说话集会召开，而是发生了另外一些事情。阿瓦登望着<br>那窗户，心情开始变的有些慌乱，他把手从兜里掏出来，叼起一支香烟，把身体靠<br>在一根电线杆旁故做镇静，以免被行人怀疑。究竟说话会发生了什么，为什么这一<br>周停办了呢？要知道，只要还有复数的成员能够出席，说话会就会一直办下去，难<br>道说瓦格纳、兰斯洛特、杜拉丝和阿尔特弥斯同时无法出席？这种概率实在太小了<br>。阿瓦登一边这样想着，一边向四周不安地张望。忽然他看到了一样东西，一个念<br>头霎时占据了他的全部心灵，让他几乎眩晕过去。</p><p>　　“说话会本周不会有了，以后也不会有了。”阿瓦登嘴唇默默地蠕动着，面如<br>死灰。</p><p>　　他看到在街道内侧一处不起眼的地方隐藏着一个类似雷达天线的东西，其造型<br>很象是两个背部贴在一起的大碗。阿瓦登心里清楚这是什么东西：这正是他负责软<br>件设计的大功率主动式“旁观者”，这造型他很熟悉。这装置可以主动发射电波去<br>探测人们的声音，并检查其中是否存在敏感词汇。</p><p>　　这样的装置居然就安放在阿尔特弥斯家附近，那么就等于说话会完全暴露在了<br>有关部门的监控之下。主动式旁观者的强大刺探电波会轻易刺穿她家中的铅质窗帘<br>，把所有成员的话原封不动地传到有关部门耳朵里。</p><p>　　这是一个划时代的发明，这一技术的突破意味着有关部门可以不再被动地等待<br>警报，可以主动出击去刺探人们在任何时间任何地点说的任何话语。阿瓦登可以想<br>象接下来会发生什么，阿尔特弥斯他们的每一句话都被有关部门记录下来，会有机<br>器统计出到底有多少违禁词汇被他们使用过；然后联邦警察会冲进她的屋子，将正<br>在聚会的成员们都带走，只留下搜查过后空荡荡的房间和窗户。</p><p>　　阿瓦登想到这里，心如刀绞，他一点也不为自己的侥幸逃脱而感到幸运。他的<br>胃袋翻腾起来，一种恶心的感觉从胃里直接升到嘴边，让他想吐，却又不能吐——<br>因为“呕”也是个敏感词汇；大病初愈的孱弱身躯无法承受这种打击，象害了风寒<br>一样颤抖起来，几乎站立不住。</p><p>　　他不敢继续朝前走去，仓皇地转过身去，登上另外一辆公共汽车，把嘴闭的更<br>紧了。等阿瓦登回到自己家楼下，看到楼房附近另外一架新的主动式旁观者正在兴<br>建中，漆黑的天线在半空舒展开来，仿佛一面巨大的蜘蛛网。看来有关部门已经着<br>手在整个纽约市部署这种新兴高科技产品。</p><p>　　他不敢驻足观看，低着头从那巨大装置旁边走过，一路不停地走回家，然后把<br>自己的脸紧紧地压在枕头里，却不敢哭出声音来，连一句“FUXKYOU, YOUSONOFBIT<br>CH”都不能说。</p><p>　　从那以后，阿瓦登的生活回到了普通状态——就是说和原来一样沉滞、压抑、<br>欠缺激情，健康向上，缺乏低级趣味。兰斯洛特说过：“战争的结果就是，大众的<br>自由意识会将语言推向死亡的边缘”，现在看来，他的预言是很准确的：说话会的<br>覆灭，导致“说话”、“歌剧”、“完全”、“交流”几个词先后被剔除出了健康<br>词汇列表，成为敏感词汇。</p><p>　　另外，虽然阿拉伯数字还能用，但“1984”这一个数字组合也被屏蔽掉了，这<br>让包括阿瓦登在内的程序员在编写程序时不得不谨慎地检查数字是否违规，这额外<br>增加了很多工作量，让他更加疲惫。</p><p>　　阿瓦登不是没有担心过，也许在某一天的深夜，他就会忽然接到一封EMAIL，让<br>他留在家里不要动，不要试图在网络做任何动作；接着电话会响起，电子女声会把<br>这一要求重复再重复，直到警察打开他家的大门，把他带去未知的地方，那里有未<br>知的命运等待着他。《1984》后面的情节发展阿瓦登始终不知道，唯一知道的杜拉<br>丝已经彻底失踪了，所以温斯顿和朱丽亚的结局始终是个谜；就好象兰斯洛特、瓦<br>格纳、杜拉丝和阿尔特弥斯的结局一样，也不从得知。其实这两件事对于阿瓦登来<br>说没什么本质性的区别，所以它们也可以看做是同一个谜。</p><p>　　其实他最担心的，是阿尔特弥斯。每次想到这个名字，阿瓦登就难以抑制心中<br>的郁闷。她究竟会怎么样，彻底被屏蔽掉吗？如果是那样，那么她在这世界上遗留<br>下来的唯一痕迹，就是一个程序员记忆里的假名而已了。</p><p>　　说话会消失后三个星期，仍旧风平浪静，没有任何人来找过阿瓦登，他也没收<br>到过任何类似内容的EMAIL，阿瓦登一直在想，也许是他们没有吐露出自己的下落，<br>也可能是因为他们根本不知道——他们认识的只是一个叫王二的程序员。这个城市<br>里有数以千计的程序员，而王二是个假名。</p><p>　　因此，生活一如既往地平静。不，确切地说，还是有一点不同的，那就是互联<br>网络健康词汇列表：那上面的词组消失的速度比以前要快的快，每小时每分钟都有<br>词与单字飞快地在名单上消失，阿瓦登不得不花上大量时间去更新列表，以跟紧当<br>前形势。</p><p>　　与词汇列表更新速度相对的，EMAIL和网络论坛上的东西越来越乏味。因为人们<br>不得不用极有限的词去表达广泛的意思，大家都变得寡言少语。就连那些秘密的暗<br>语和联系方式也少了许多；整个网络就象是前些天阿瓦登家里出了问题的暖气片一<br>样：虽然名义上是给人带来温暖的东西，但却变的冰冷、僵硬，让人如坠冰窟。</p><p>　　这一天，阿瓦登从电脑前抬起头来，他看了看窗外迷茫的灰色天空，胸口一阵<br>抽搐，不由得痛苦地咳了一声。他拿起塑料杯，将杯子里的纯净水一饮而尽，杯子<br>丢进同样是塑料质地的垃圾桶里，发出钝钝的撞击声，他觉得自己的脑子也是一团<br>垃圾，举起手敲了敲，果然发出同样钝钝的撞击声。</p><p>　　然后他拿起大衣，戴上墨绿色的护目镜，走出门去。阿瓦登没带便携式的旁观<br>者，那东西已经不需要了，城市里到处都是主动式的旁观者，随时监听是否有违禁<br>词汇的存在。整个纽约现在就象是互联网络一样，被有关部门营造成十分健康。</p><p>　　阿瓦登这一次外出是有正当理由的，他决定去取消网络论坛服务，这服务已经<br>用不着了，因为无论EMAIL，新闻组，BBS论坛还是其他什么现在全部都变成了一样<br>的东西。</p><p>　　从日历来说现在应该是春季，但外面还是很冷，高大的灰色建筑矗立在平地上<br>，仿佛绝对零度下的石林。大团大团的风裹着黄沙与废气穿行其间，风沙无处不在<br>，让人置身其中而难以摆脱。阿瓦登把手揣进兜里，脖子缩进领口，畏缩着向网络<br>部的大楼走去。</p><p>　　忽然，他停下了脚步，惊讶地站在原地无法动弹。他看到阿尔特弥斯正站在前<br>面的路灯下，穿着黑色的制服。可是她的变化有多么大啊，面容象是老了十岁，满<br>脸都是衰老的皱纹，年轻的活力荡然无存；她听到脚步声，转过头来，两个乌黑的<br>大眼睛显得异常空洞，目光越过阿瓦登延伸到远方，没有一个明晰的焦点。</p><p>　　阿瓦登万万没有想到会在这个时间这个地点碰到她，这让他已经沉寂已久的心<br>灵泛起了几点火花，可惜他迟钝的神经已经无法表达出“激动”这一个简单的情感<br>了。两个人互相对视了一阵，他终于木然走到她身边，张了张嘴唇，想对她说些什<br>么。但是他掏出今天新发布的健康词汇列表，发现上面是一片空白——终于连最后<br>一个词组也被有关部门屏蔽了。<br>　于是阿瓦登只好保持着沉默，默默地与面无表情的她擦肩而过，继续向前走去<br>。他的身影逐渐融入同样安静的灰色人群之中，整个城市都显得寂静极了。</p></blockquote><p>全文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载马伯庸一篇短篇小说 「寂静之城」 ；记得好多年前看的时候认为是科幻小说，现在想想还是自己太年轻&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个三年前的Bug导致上线失败</title>
    <link href="https://www.yzhu.name/2020/05/30/History-Bug-And-Code-Review/"/>
    <id>https://www.yzhu.name/2020/05/30/History-Bug-And-Code-Review/</id>
    <published>2020-05-30T03:16:26.000Z</published>
    <updated>2022-01-19T07:06:58.601Z</updated>
    
    <content type="html"><![CDATA[<p>上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。<span id="more"></span></p><h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><ol><li>17:10：开始发布B组 </li><li>17:20：开始出现内存，接口超时报警；开发和SA开始介入</li><li>17:25：认为是新版本有问题立刻回滚</li><li>回滚后持续半小时问题没有出现</li></ol><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>根据开发反馈，本次上线功能逻辑非常简单，只有20多行代码，而且测试过程中没发现任何问题；于是，大家开始review那段代码，review后得出一致多结论，该代码没问题。逻辑非常简单，只有一个地方调用了一个方法；这个方法已经存在了好你年了，而且被多个场景在调用；另外，这个方法逻辑复杂，团队内没有人了解。大家一致认为这个方法不会有问题，毕竟经历了「时间的考验」。</p><h3 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h3><p>在测试环境又做了一轮压力测试，一切正常。根据目前点情况看来这个bug跟数据有关；就是说，可能是某条数据触发了这个bug的临界条件.所以，我们决定在生产环境发布一台机器做测试; 这次发布后5分钟后出现了内存飙升现象,马上切掉该机器的流量而且dump Jvm内存 。</p><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><p>拿到dump文件后立刻启动MAT分析；发现占用内存最多一个对象有3000多万个，分析该对象的调用盏都指向了同一行代码；「这段代码正是经历过时间考验的代码」。review这行代码相关部分马上发现有死循环的问题，只是满足这个条件的数据不容易出现。而这次的数据正好满足了这个条件。找到了原因，解决方法就很容易了；修改完代码review后没问题，测试，上线后一切正常；至此，该问题解决。这里可能有人会说死循环一般会首先导致CPU报警，怎么没看到我们提到CPU到问题；因为这台机器是16核CPU，所以一个核跑满并没有触发报警规则 。</p><h3 id="后续措施"><a href="#后续措施" class="headerlink" title="后续措施"></a>后续措施</h3><ol><li>必须严格执行code review，从流程上去控制</li><li>需要监控各项指标到同比变化 </li></ol><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>我们总是强调code review到重要性，但执行的时候总有这样那样的原因导致落实不彻底；我不了解当时的情况，但这次的问题我相信只要做过code review是一定可以发现的。另外，我始终相信代码质量最终要依赖开发人员来保证，测试只能保证功能性问题。特别是一些非功能性的边界条件，只能依赖开发保证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周某核心服务上线过程中内存瞬间飙升，导致上线失败。经查是一个三年前的bug引发的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线上问题" scheme="https://www.yzhu.name/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC(ShardingSphere)多数据库与springboot集成 -- 读写分离</title>
    <link href="https://www.yzhu.name/2020/04/11/ShardingSphere-Springboot/"/>
    <id>https://www.yzhu.name/2020/04/11/ShardingSphere-Springboot/</id>
    <published>2020-04-11T10:54:30.000Z</published>
    <updated>2022-01-19T07:06:58.612Z</updated>
    
    <content type="html"><![CDATA[<p>Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入<code>sharding-jdbc-spring-boot-starter</code>可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。<span id="more"></span></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h3><ul><li><p> 实现<code>EnvironmentAware</code>接口 ，在方法<code>setEnvironment</code>解析properties配置可以获取所有配置信息</p></li><li><p>获取以<code>spring.ydal</code>为前缀的所有数据库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; databases = PropertyUtil.handle(environment, &quot;spring.ydal&quot; , Map.class);</span><br></pre></td></tr></table></figure></li><li><p>构造每个数据库的数据库的MasterSlave数据源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;datasource&quot;, Map.class);</span><br><span class="line"> Preconditions.checkState(!dataSourceProps.isEmpty(), &quot;Wrong datasource properties!&quot;);</span><br><span class="line"></span><br><span class="line"> DataSource datasource = DataSourceUtil.getDataSource(dataSourceProps.get(&quot;type&quot;).toString(), dataSourceProps);</span><br><span class="line"> Optional&lt;DataSourcePropertiesSetter&gt; dataSourcePropertiesSetter = DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get(&quot;type&quot;).toString());</span><br><span class="line"> if (dataSourcePropertiesSetter.isPresent()) &#123;</span><br><span class="line">     dataSourcePropertiesSetter.get().propertiesSet(environment, prefix, dataSourceName, datasource);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">masterSlaveRule = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.masterslave&quot;, YamlMasterSlaveRuleConfiguration.class);</span><br><span class="line">MasterSlaveRuleConfiguration msConfig = new MasterSlaveRuleConfigurationYamlSwapper().swap(masterSlaveRule);</span><br><span class="line"></span><br><span class="line">Properties dsProps = PropertyUtil.handle(environment, &quot;spring.eldal.&quot; + dataBaseName+&quot;.props&quot;, Properties.class);</span><br><span class="line">MasterSlaveDataSourceFactory.createDataSource(datasource, msConfig, dsProps)</span><br></pre></td></tr></table></figure></li></ul><h3 id="禁用ShardingSphere的Springboot的自动配置"><a href="#禁用ShardingSphere的Springboot的自动配置" class="headerlink" title="禁用ShardingSphere的Springboot的自动配置"></a>禁用ShardingSphere的Springboot的自动配置</h3><p>实现该扩展后以jar包的形式提供出去供多个项目使用，所以我们必须在jar里面禁用ShardingSphere的Springboot的自动配置；可以实现如下接口:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class YdalAutoConfigurationImportFilter implements AutoConfigurationImportFilter &#123;</span><br><span class="line">    private static final Set&lt;String&gt; SHOULD_SKIP = new HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(&quot;org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration&quot;));</span><br><span class="line">    @Override</span><br><span class="line">    public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">        boolean[] matches = new boolean[autoConfigurationClasses.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt; autoConfigurationClasses.length; i++) &#123;</span><br><span class="line">            matches[i] = !SHOULD_SKIP.contains(autoConfigurationClasses[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return matches;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将<code>YdalAutoConfigurationImportFilter</code>加入<code>META-INF/spring.factories</code></li></ul><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><ul><li>详细代码： <a href="https://github.com/yinghuzhu/ydal-spring-boot-starter">https://github.com/yinghuzhu/ydal-spring-boot-starter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sharding-JDBC(ShardingSphere)作为分布式数据库中间件,在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务。引入&lt;code&gt;sharding-jdbc-spring-boot-starter&lt;/code&gt;可以快速完成与springboot的集成; 但是默认情况下只能支持到一个数据库，如果支持多数据库，需要做部分扩展；本文记录支持多数据库所做的扩展。&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://www.yzhu.name/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM初探</title>
    <link href="https://www.yzhu.name/2020/03/29/JVM-NEW/"/>
    <id>https://www.yzhu.name/2020/03/29/JVM-NEW/</id>
    <published>2020-03-29T03:30:40.000Z</published>
    <updated>2022-01-19T07:06:58.601Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常有人跟我一起讨论JVM的相关话题，所以将以前分享过的一篇JVM的基础知识在这里分享出来，欢迎大家指正.<span id="more"></span></p><div class="pdfobject-container" data-target="/pdf/jvm.pdf" data-height="500px"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近经常有人跟我一起讨论JVM的相关话题，所以将以前分享过的一篇JVM的基础知识在这里分享出来，欢迎大家指正.&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://www.yzhu.name/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Open Tracing(Jaeger) 遭遇多线程</title>
    <link href="https://www.yzhu.name/2019/12/27/Jaeger-Thread/"/>
    <id>https://www.yzhu.name/2019/12/27/Jaeger-Thread/</id>
    <published>2019-12-27T10:33:50.000Z</published>
    <updated>2022-01-19T07:06:58.601Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在Java技术体系中，链路跟踪严重依赖ThreadLocal；因此在多线程的场景下会导致链路跟踪失效.<span id="more"></span></p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>前几天一位开发同学反馈了一个问题，在链路跟踪UI上看到某个链路Rpc的span数量比实际调用少了很多；我听完第一反映是我们最近升级的SDK出问题了? 根据该同学反馈该接口是一个新接口，上线后一直没关注过链路；我们随即在链路跟踪UI上将多个系统的常用接口都检查了一遍发现一切正常，基本排除了SDK可能引起的问题。接着开始检查开发同学的代码,顺着该请求发现代码里面用到了<strong>线程池</strong> ,该同学解释该接口内部需要多次调用多个Rpc接口，为了提升效率所以采用了多线程。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析opentracing的源码发现tracing相关的的信息保存在<code>io.opentracing.util.ThreadLocalScopeManager</code>的ThreadLocal变量里:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScopeManager</span> <span class="keyword">implements</span> <span class="title">ScopeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalScope&gt; tlsScope = <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalScope&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">activate</span><span class="params">(Span span, <span class="keyword">boolean</span> finishOnClose)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalScope(<span class="keyword">this</span>, span, finishOnClose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tlsScope.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以解释为什么多线程中的Rpc请求没有将相关Tracing信息传递下去;</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>多线程中ThreadLocal变量的传递:<br>关于多线程中ThreadLocal变量的传递我们可以用阿里巴巴的<a href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a> ,所以整个思路就是自己实现一遍<code>ThreadLocalScopeManager</code>用<code>TransmittableThreadLocal</code>替换<code>ThreadLocal</code>，以及跟它关联的类<code>ThreadLocalScope</code>(它里面申明了<code>ThreadLocalScopeManager</code>变量)； </p></li><li><p>修改Opentrcing里面默认的<code>ThreadLocalScopeManager</code>为用户自定义<code>ThreadLocalScopeManager</code><br>检查Jaeger的Springboot自动配置文件<code>io.opentracing.contrib.java.spring.jaeger.starter.JaegerAutoConfiguration</code>源码, 在构造Bean <code>io.opentracing.Tracer</code>时有用户自定义方法: <code>tracerCustomizers.forEach(c -&gt; c.customize(builder))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JaegerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;TracerBuilderCustomizer&gt; tracerCustomizers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> io.opentracing.<span class="function">Tracer <span class="title">tracer</span><span class="params">(Sampler sampler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Reporter reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Metrics metrics,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      JaegerConfigurationProperties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> JaegerTracer.Builder builder =</span><br><span class="line">        <span class="keyword">new</span> JaegerTracer.Builder(properties.getServiceName())</span><br><span class="line">            .withReporter(reporter)</span><br><span class="line">            .withSampler(sampler)</span><br><span class="line">            .withTags(properties.determineTags())</span><br><span class="line">            .withMetrics(metrics);</span><br><span class="line"></span><br><span class="line">    tracerCustomizers.forEach(c -&gt; c.customize(builder));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><p>于是，我们只需要自定义<code>TracerBuilderCustomizer</code>调用<code>builder.withScopeManager</code>方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlTracerBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title">TracerBuilderCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(JaegerTracer.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.withScopeManager(<span class="keyword">new</span> TracingScopeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SpringBoot自动配置文件中构造Bean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TracerBuilderCustomizer&gt; <span class="title">tracerCustomizers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> TtlTracerBuilderCustomizer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，问题解决； 代码参考<a href="https://github.com/yinghuzhu/request-tracing">request-tracing</a></p></li></ol><h3 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h3><p>我不建议在互联网高并发请求接口内部采用多线程；以Java技术体系为例，请求到达系统后一般会有容器(Tomcat之类)或者Rpc框架先接收，然而这些框架本来就是多线程在运行,如果系统本来已经到瓶颈了，即使增加线程也不会提升效率；如果系统需要增加线程，首先我们应该增加容器或者Rpc框架的线程数量；另外如果接口性能差，我们首先应该考虑是Sql的问题还是代码逻辑的问题；或者系统达到了瓶颈是否可以通过增加机器提升性能；如果接口逻辑本身太复杂，可能是我们的方案或者设计有问题，或许可以考虑按照离线请求的模式设计接口。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个问题虽然没有对业务造成影响，但收集到链路肯定是有问题的；这也暴露出了我们开发过程中的一些问题，对非功能性验证做的不到位，这方面还需要加强。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道在Java技术体系中，链路跟踪严重依赖ThreadLocal；因此在多线程的场景下会导致链路跟踪失效.&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="链路跟踪" scheme="https://www.yzhu.name/tags/%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>Java与Go之间gRPC调用失败问题排查</title>
    <link href="https://www.yzhu.name/2019/06/02/gRPC-Go-Java/"/>
    <id>https://www.yzhu.name/2019/06/02/gRPC-Go-Java/</id>
    <published>2019-06-02T01:29:15.000Z</published>
    <updated>2022-01-21T09:48:11.668Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手了一个新项目，被告知Java代码的gRPC客户端无法访问当前项目中Go代码的gRPC服务。通过问题的排查和部分代码改造个人对gRPC的理解更深入了一层.<span id="more"></span></p><h3 id="项目背景："><a href="#项目背景：" class="headerlink" title="项目背景："></a>项目背景：</h3><p>接手该项目后跟该项目相关人员多次沟通后得到如下背景信息:</p><ol><li>该项目Go服务端采用的是2016年9月以前发布的gRPC ；</li><li>项目组对官方提供的Go语言gRPC类库做了部分改造，但，由于改造该代码的工程师已经离职，目前没有人知道具体修改了什么​；</li><li>由于项目周期紧张，没有富余的人力排查该问题；</li><li>目前Java与Go互相交互的接口不到10个，双方先采用HTTP交互;</li><li>服务端总是需要维护两套接口，HTTP和gRPC接口，链路跟踪等公共组件都要适配两套接口，增加了维护成本</li></ol><h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><ol><li>采用Java版本gRPC-Java-1.18.0访问现有的Go服务，请求发出以后被hang住没有任何反馈直到客户端设置的连接超时后断开，Java客户端和Go服务端没有任何输出信息；</li><li>抓包看包文发现在完成TCP的3次握手后，客户端发送了第一HTTP2的包文后，没有收到服务端的任何回复，整个过程被hang；初步估计是双方采用的HTTP2协议不兼容。</li><li>采用低版本的Java gRPC, 调研发现Java的gRPC在2016年9月以前的最新版本是1.0.0，所以从1.0.0开始测试，最终发现0.9.0可以完成正常请求。</li></ol><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>调研发现0.9.0版本的Java gRPC依赖了4.1.0.Beta6的Netty，该Netty版本发布与2015年9月， 而HTTP2在2015年有多次修订，版本号也升级到了17；我估计该版本的Netty是根据HTTP2修订版17以前的规范实现的,而且该版本为Beta版，导致跟其它语言的协议存在某些差异。</p><h3 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h3><p>采用0.9.0版本的gRPC后会带来以下新问题：</p><ol><li>现有的Java项目框架采用springcloud2.0.0，该版本依赖了Netty的4.1.27.Final版本，项目集成后会出现版本冲突导致各种异常出现；</li><li>0.9.0版本的gRPC缺少很多重要的特性，比如：nameresolver，负载均衡 等 …</li><li>最终还是要升级到新版本</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>综合沟通下来最好的方案就是Go服务端升级gRPC到新版本 ，但是团队将官方代码改造后已经无法做到无缝升级，必须要做部分改造才能投入生产​；目前生产环境运行的Go服务超过50+，而且大部分是核心服务；改造后需要充分的测试，总体成本太大，而且目前没有更多的资源投入。最终决定才有用低版本的Java gRPC​，采用以下的措施应对低版本面临的问题:</p><ol><li>所有的Java项目提供统一的parent pom文件，所有的版本信息在parent pom的dependencyManagement中维护；</li><li>增加新功能：nameresolver，负载均衡，兼容Go服务的服务发现，等…</li></ol><h3 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h3><p>我们在技术选型的不能过于保守也不能过于激进；太过保守不能充分利用新技术的优势，甚至会影响到团队士气；太过激进会遭遇太多的不确定性，面临着遇到问题没有先例可以参考，遭遇新的bug，等；所以，在团队没有足够的技术支撑的情况下，我不太建议生产环境采用1.0以下的版本。作为技术人员应该随时关注业界的新技术，但在生产环境采用新技术前必须考虑清楚所面对的各种风险，包括以后的升级能否做到无缝升级。​</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h5><p><a href="https://grpc.io/">https://grpc.io/</a><br><a href="https://github.com/grpc/grpc-java">https://github.com/grpc/grpc-java</a><br><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/">https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2/history/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接手了一个新项目，被告知Java代码的gRPC客户端无法访问当前项目中Go代码的gRPC服务。通过问题的排查和部分代码改造个人对gRPC的理解更深入了一层.&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="RPC" scheme="https://www.yzhu.name/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>技术给业务赋能</title>
    <link href="https://www.yzhu.name/2019/04/27/Tech-VS-Biz/"/>
    <id>https://www.yzhu.name/2019/04/27/Tech-VS-Biz/</id>
    <published>2019-04-27T07:40:16.000Z</published>
    <updated>2022-01-21T09:49:53.032Z</updated>
    
    <content type="html"><![CDATA[<p>技术人员在技术选型的时候如何做好技术与业务的平衡，如何推广技术方案，甚至与产品人员沟通改变某些功能的实现方式，这些问题值得每一个技术人员思考。我们不管采用什么技术方案，最终目的是为了帮助业务发展，使公司在商业上获取回报。如果技术人员能有一些产品和运营的思维，对整个业务的发展会起到更好的效果。<span id="more"></span></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型我们要考虑很多因素：产品所处的阶段，技术栈，当前的技术实力，技术债务，时间,等… 。特别是产品的不同阶段其目标也不同：</p><ol><li><p>初创阶段：这个阶段重点考虑两个方面：</p><ul><li>1.1 <strong>快</strong>：这个时候重点是<strong>快速上线</strong>，快速验证。同时，技术人员应该注意到有些需求产品人员没有提出来，但以后肯定有这个需求，只是当前优先级比较低。所以技术人员应该考虑到这些需求对现有方案可能存在的影响；如果是举手之劳的事情就顺便实现，至少在设计表结构时应该考虑到。可能有人会说该阶段到底哪些需求应该考虑，哪些不应该考虑；我个人的想法是支撑半年内业务的发展不需要重构为目标。所以在出方案前一定要跟产品，运营等业务方充分沟通拿到所有的数据，比如：半年后PV到多少，单量是多少等业务数据，以此为目标。</li><li>1.2 <strong>可维护性</strong>：产品第一版上线后，会持续迭代和bug修复；从可维护性的角度应该考虑这几点：<ul><li>当前团队有相应的技术储备</li><li>业界有大量的工程师正在使用的技术</li><li>如果是开源项目,其社区足够庞大，如果是商业项目需要有充分的技术支持</li><li>一定是让团队内部最资深的工程师开始写第一行代码，因为所有的项目在重构前，代码一定会越写越烂 </li></ul></li></ul></li><li><p>成长阶段 ：这个阶段产品的商业模式已经被验证过，产品正在为大量的用户提供服务，而且业务正在快速发展中，此时的技术方案以不影响现有业务为前提，或者说将影响降到最低，就是行业内所说的<strong>给飞行中的飞机换引擎</strong> 。 个人认为此阶段的技术方案应该重点考虑<strong>可落地</strong> ,一般这个阶段团队也会扩大，同时会引入一些外部人才。这个时候会出现一些新的思想，新的方案，此时要特别注意这些方案是不是立足于本团队的实际情况。特别一些大厂背景的工程师，可能会给出一些高大上的方案，但是各项成本可能非常高。即便是一些规模相当友商团队的工程师过来给出的方案也不一定能马上落地，因为没有一家企业的流程，制度，文化跟另一家企业是完全一样的，技术方案本质是用技术的手段解决业务的问题，流程的问题，质量的问题，效率的问题，成本的问题。</p></li></ol><h3 id="技术方案推广"><a href="#技术方案推广" class="headerlink" title="技术方案推广"></a>技术方案推广</h3><p>有人说一个技术方案的效果只有在实施后才能知道，我个人认为一个技术方案如果推广成本太高一定不是一个好的方案。在出方案时候就应该考虑到如何去推广，一般情况下开发团队时间很紧迫，不可能为了一个技术改造耽误太多时间。我个人的做法是在出方案前跟相关团队沟通清楚当前面对的问题，以及各个团队的诉求。根据具体的问题给出适合的方案，接下来跟自己的领导沟通方案以及部分细节，确保能得到领导的支持「这点非常重要」；再准备方案，包括但不限于相应的文档，代码，工具，流程等；在正式推广之前，召集所有团队相关负责人「甚至所有技术人员」宣讲，主要包括几个方面：面对的问题，应对方案，如何实施，相关团队如何配合与执行，达到的效果，deadline 。特别是团队配合与执行部分给出详细的执行步骤，以及常见的QA。要站在执行团队的立场上考虑问题，让执行团队充分意识到，采用了新方案后可以提升效率，提升质量或者节省成本，等；可能经过多次沟通后仍有部分团队不能配合执行，此时只能将问题上升到更高一层管理者来协调 。技术方案的实施要充分权衡成本与业务的影响，比如一个案例：业务方要求实施方案不允许停机，然而跟业务方沟通告知不停机的成本太高，最终选择了凌晨业务低峰时期停机20分钟来完成，实际实施的过程中真正停机的时间只有5分钟；然而，该时间段对业务的影响也非常低，因此最终的方案都是权衡各方的利益后博弈的结果。方案实施后要监控各项指标，查看各项指标是否符合预期，如果没有达到预期目标，一定要找到根本原因是方案本身的问题，还是执行过程的问题，避免相同的问题再次出现。</p><h3 id="与产品人员沟通"><a href="#与产品人员沟通" class="headerlink" title="与产品人员沟通"></a>与产品人员沟通</h3><p>我们经常看到一些关于产品人员和技术人员相爱相杀的段子，我认为现实中这样的例子并不多「也许我经历少」。技术人员拿到PRD后要仔细分析PRD背后的逻辑和诉求，有些看似简单需求背后可能需要复杂的技术支撑，不是每一个产品人员都有技术背景，此时需要技术人员跟产品人员充分沟通该需求的实现成本「理论上来说所有的需求都是可以实现的」，帮助产品人员梳理出重点和优先级，适当的时候可以减少需求或者改变产品逻辑。切忌一句“这是一个伪需求”或“这个需求实现不了” ；如果认为是伪需求请给出具体的数据，一切以数据为依据 ，即使实现不了也应该告知当前的困难，是资源问题，还是时间的问题等。如果多次沟通都没效果建议换个产品人员伺候，如果你没有选择的余地或者你认为公司都是这种产品人员，建议还是换工作吧。</p><h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>技术的世界比较简单，确定的输入一定可以得到确定的输出，然而，我们的世界并不总是这样，有很多东西是没有绝对的对错之分。技术人员可以经常与非技术人员聊聊，听听他们看问题的角度，听听他们的诉求；也许这样可以让技术更好的帮助业务成长。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;技术人员在技术选型的时候如何做好技术与业务的平衡，如何推广技术方案，甚至与产品人员沟通改变某些功能的实现方式，这些问题值得每一个技术人员思考。我们不管采用什么技术方案，最终目的是为了帮助业务发展，使公司在商业上获取回报。如果技术人员能有一些产品和运营的思维，对整个业务的发展会起到更好的效果。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式调度系统选型</title>
    <link href="https://www.yzhu.name/2019/03/30/Schedule-Job/"/>
    <id>https://www.yzhu.name/2019/03/30/Schedule-Job/</id>
    <published>2019-03-30T05:56:45.000Z</published>
    <updated>2022-01-19T07:06:58.609Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么需要调度系统"><a href="#为什么需要调度系统" class="headerlink" title="为什么需要调度系统"></a>为什么需要调度系统</h4><p>我们可能有这样的需求:</p><ol><li>在某个指定的时间点执行一个任务, 比如凌晨对前一天的数据进行汇总;</li><li>在某个操作后的指定时刻执行某一操作，比如：电商下单后一小时没有支付的订单需要被取消; </li><li>微服务失败后补偿操作;<span id="more"></span></li></ol><p>类似的需求我们都可以通过定时任务去完成。当然对于需求2，我们也可以利用MQ的延时投递功能去实现；但是，与外部系统交互只能用定时任务。</p><h4 id="Java领域主要分布式调度系统"><a href="#Java领域主要分布式调度系统" class="headerlink" title="Java领域主要分布式调度系统"></a>Java领域主要分布式调度系统</h4><ol><li>xxl-job：是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 。</li><li>Elastic-Job： 当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成；Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务；Elastic-Job-Cloud采用自研Mesos Framework的解决方案，额外提供资源治理、应用分发以及进程隔离等功能；</li><li>Saturn：是唯品会开源的一个分布式任务调度平台，在当当开源的Elastic Job基础上，取代传统的Linux Cron/Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理；</li><li>light-task-scheduler：阿里员工开源的个人项目,主要用于解决分布式任务调度问题，支持实时任务，定时任务和Cron任务。有较好的伸缩性，扩展性，健壮稳定性</li><li>Quartz: Java定时任务的标配。利用数据库的锁机制实现集群调度，业务代码需要考虑调度的逻辑，对业务代码有入侵。</li></ol><p>可能还有一些其它的系统个人不太了解，或者长期不在维护，它不在我们讨论的范畴。在这些系统中以xxl-job和Elastic-Job影响力最大，所以在调研的过程中以这两个系统为主.</p><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><ol><li><p>xxl-job架构 </p><p><img src="/2019/03/30/Schedule-Job/xxl-job.png" alt="xxl-job架构"></p></li><li><p>Elastic-Job-Lite架构</p><p><img src="/2019/03/30/Schedule-Job/Elastic-Job-Lite.png" alt="Elastic-Job-Lite架构"></p></li></ol><p>从两个系统的架构上可以看出最大的区别是xxl-job有中心化的调度中心，所有的job由调度中心统一调度。而Elastic-Job-Lite没有统一调度中心，由每个Job各自任务节点通过选举算法选出调度节点，确切的说各个job之间没有统一的调度中心 ；Elastic-Job-Cloud依赖Mesos完成调度，资源隔离等工作。</p><h4 id="主要功能特性"><a href="#主要功能特性" class="headerlink" title="主要功能特性"></a>主要功能特性</h4><table><thead><tr><th></th><th>xxl-job</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>调度中心HA</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>执行器HA</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>弹性扩容缩容</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>失效转移</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>任务失败重试</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>作业分片一致性</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>资源隔离</strong></td><td>Y</td><td>Y</td></tr><tr><td><strong>多语言</strong></td><td>Y</td><td>N</td></tr><tr><td><strong>权限管理</strong></td><td>N</td><td>N</td></tr></tbody></table><p>从主要功能看上去两者都能提供很好的支持；在多语言支持方面，xxl-job提供通用HTTP任务Handler,业务方只需要提供HTTP链接即可，不限制语言。Elastic-Job目前只能支持Java，其它语言支持需要自行扩展。</p><h4 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h4><p>对于开源项目的选择，社区支持是非常重要的因素；强大的社区意味着，在遇到问题的时候可以得到社区资源的支持，否则只能自己解决了；社区支持我们以github的数据为准:</p><table><thead><tr><th></th><th>xxl-job</th><th>Elastic-Job</th></tr></thead><tbody><tr><td><strong>Star</strong></td><td>7408</td><td>4707</td></tr><tr><td><strong>Fork</strong></td><td>3121</td><td>2216</td></tr><tr><td><strong>Contributers</strong></td><td>17</td><td>17</td></tr><tr><td><strong>Open Issues</strong></td><td>82</td><td>115</td></tr><tr><td><strong>Close Issues</strong></td><td>602</td><td>384</td></tr><tr><td><strong>Latest Updated</strong></td><td>24天前</td><td>一年前</td></tr><tr><td><strong>已登记使用的公司</strong></td><td>163</td><td>63</td></tr></tbody></table><p>从以上数据可以看出来，xxl-job在社区支持方面有更大优势 。</p><h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h4><ul><li>xxl-job可以做到开箱即用，配置信息在管理控制台有UI统一配置，更容易上手 ; 包括监控，报警都可以在管理控制台完成。</li><li>Elastic-Job配置信息在执行器的spring xml文件完成，监控，报警需要自己定制 。</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>从两者的架构可以发现，在大任务量的情况下，Elastic-Job性能要高于xxl-job 。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>  如果对于技术实力比较强大的团队，而且对性能要求比较搞的情况下，建议选择Elastic-Job，在该基础上进行定制开发，可以取得更好效果；对于技术实力不足，性能能要求不是很高，而且希望快速开发，快速上线建议选择了xxl-job 。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.xuxueli.com/xxl-job">http://www.xuxueli.com/xxl-job</a><br><a href="http://elasticjob.io/">http://elasticjob.io</a><br><a href="https://vipshop.github.io/Saturn">https://vipshop.github.io/Saturn</a><br><a href="https://github.com/ltsopensource/light-task-scheduler">https://github.com/ltsopensource/light-task-scheduler</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;为什么需要调度系统&quot;&gt;&lt;a href=&quot;#为什么需要调度系统&quot; class=&quot;headerlink&quot; title=&quot;为什么需要调度系统&quot;&gt;&lt;/a&gt;为什么需要调度系统&lt;/h4&gt;&lt;p&gt;我们可能有这样的需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在某个指定的时间点执行一个任务, 比如凌晨对前一天的数据进行汇总;&lt;/li&gt;
&lt;li&gt;在某个操作后的指定时刻执行某一操作，比如：电商下单后一小时没有支付的订单需要被取消; &lt;/li&gt;
&lt;li&gt;微服务失败后补偿操作;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://www.yzhu.name/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="定时任务" scheme="https://www.yzhu.name/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>海恩法则与生产Bug</title>
    <link href="https://www.yzhu.name/2019/03/01/product-bug/"/>
    <id>https://www.yzhu.name/2019/03/01/product-bug/</id>
    <published>2019-03-01T14:03:43.000Z</published>
    <updated>2022-01-21T09:49:20.979Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/01/product-bug/heinrich-law.jpeg"><br>「海恩法则」是航空涡轮发动机的发明者帕布斯·海恩提出一个在航空界关于飞行安全的法则。海恩指出：每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。法则强调两点：一是事故的发生是量的积累的结果；二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。「海恩法则」虽然针对的是飞行领域，在软件开发领域遭遇生产bug<span id="more"></span>，用「海恩法则」也可以解释。</p><p>当生产环境出现bug的时候，通常情况下，我们会很快定位出bug产生的原因具体在哪一行代码上，然后根据实际情况决定回滚或者修复。然而事后总结发现，每一个线上bug的出现绝不仅仅是代码的问题，会涉及到开发、测试和运维多个环节；更多暴露出的是流程的问题，管理的问题，执行力的问题。特别是初创团队和架构大规模升级后最容易暴露出代码以外的问题。以我个人处理过的生产bug，事后分析原因最多的一次有14项措施要么缺失，要么执行不到位，其中与代码相关的只有2项，更多的原因是方案和流程执行不到位。</p><p>上线前通常会采取一些措施来保证质量；比如：开发阶段的code review，ut以及测试阶段的压测等；而且会有配套的流程确保必要的步骤都执行到位；然而即便采取多么复杂的流程也不能避免bug的出现。归根结底，代码是人写的，是人就可能出错 ；我们要做的<strong>不是不出bug，而是不出低级bug</strong> 。对于可能出现的低级bug要擅于通过工具发现；诚然，再好的工具和流程也比不上人自身的素质和责任心。</p><p>上线后系统会有各种维度的监控确保系统正常运行；在出现生产bug前监控系统通常会有异常表现，比如CPU，内存，IO，线程等指标可能会有同比变化；此时报警策略的精准性和人的责任心就比较重要；发现异常后第一时间根据各项指标分析出异常的根本原因，是正常波动，是受到攻击还是程序bug。特别是新功能或者bug修复后上线要特别注意这些指标。在确认系统出现问题时候后立刻采取相应措施，回滚，扩容，限流，熔断等，避免或者尽可能减少造成的损失 。</p><p>其实所有的问题都可以归结为人的问题。最后想到奈飞文化准则的第一条「我们只招成年人」 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2019/03/01/product-bug/heinrich-law.jpeg&quot;&gt;&lt;br&gt;「海恩法则」是航空涡轮发动机的发明者帕布斯·海恩提出一个在航空界关于飞行安全的法则。海恩指出：每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。法则强调两点：一是事故的发生是量的积累的结果；二是再好的技术，再完美的规章，在实际操作层面，也无法取代人自身的素质和责任心。「海恩法则」虽然针对的是飞行领域，在软件开发领域遭遇生产bug&lt;/p&gt;</summary>
    
    
    
    
    <category term="线上问题" scheme="https://www.yzhu.name/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
